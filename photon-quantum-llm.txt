# 00-summary.md

# Photon Quantum Documentation Summary

This collection of notes provides a comprehensive reference for Photon Quantum, a high-performance deterministic multiplayer framework for Unity. These documents focus on code accuracy and practical usage of the Quantum ECS framework.

## Core Concepts

1. [**Quantum Introduction**](01-quantum-intro.md)
   - Overview of Photon Quantum's architecture
   - Predict/rollback networking explanation
   - ECS (Entity Component System) architecture
   - Quantum and Unity integration

2. [**Domain-Specific Language (DSL)**](02-quantum-dsl.md)
   - Core syntax for defining game state
   - Components, structs, and data types
   - Collection types (lists, dictionaries, hashsets)
   - DSL special types (entity_ref, player_ref, etc.)

3. [**Entity Prototypes**](03-entity-prototypes.md)
   - Data-driven entity composition
   - Creating and configuring prototypes in Unity
   - Runtime instantiation from prototypes
   - EntityView system

## Communication and Input

4. [**Input System**](04-input.md)
   - Defining and polling input in DSL
   - Optimizing input bandwidth
   - Input vs. Commands
   - Button state handling

5. [**Commands**](05-commands.md)
   - Occasional action transmission
   - Command definition and serialization
   - Compound commands
   - Command setup and registration

6. [**Events**](06-events.md)
   - Frame events for simulation-to-view communication
   - Event subscription in Unity
   - Special keywords (synced, nothashed, local/remote)
   - Extending events

## ECS Implementation

7. [**Systems**](07-systems.md)
   - SystemMainThread, SystemMainThreadFilter, SystemSignalsOnly
   - System lifecycle and control
   - Entity creation and management API
   - Stateless requirements and determinism

8. [**Components**](08-components.md)
   - Component definition and usage
   - Safe and unsafe API
   - Singleton components
   - Filters and component iterators

## How to Use These Notes

- Start with the [Introduction](01-quantum-intro.md) for a high-level overview
- Review the [DSL](02-quantum-dsl.md) document to understand how to define game state
- Explore [Entity Prototypes](03-entity-prototypes.md) for the data-driven approach to entity creation
- Dig into the communication patterns ([Input](04-input.md), [Commands](05-commands.md), [Events](06-events.md))
- Study the ECS implementation details ([Systems](07-systems.md), [Components](08-components.md))

Each document contains detailed code examples that can be directly applied to your Quantum projects. The focus is on providing clear, accurate code snippets that demonstrate best practices for working with the Quantum framework.

## Sample Project Documentation

For an in-depth look at a complete Quantum game implementation, check out the [**Quantum Platform Shooter 2D**](../quantum%20platform%20shooter/00-project-overview.md) documentation. This sample project demonstrates:

- A complete multiplayer game built with Quantum
- Character movement and combat systems
- Weapons and skills implementation
- Unity-Quantum integration
- Input handling across platforms

The Platform Shooter documentation includes:
1. [Project Overview](../quantum%20platform%20shooter/00-project-overview.md)
2. [Game State Definition](../quantum%20platform%20shooter/01-game-state-definition.md)
3. [Character System](../quantum%20platform%20shooter/02-character-system.md)
4. [Movement System](../quantum%20platform%20shooter/03-movement-system.md)
5. [Weapons and Combat](../quantum%20platform%20shooter/04-weapons-and-combat.md)
6. [Skills System](../quantum%20platform%20shooter/05-skills-system.md)
7. [Unity Integration](../quantum%20platform%20shooter/06-unity-integration.md)
8. [Input Handling](../quantum%20platform%20shooter/07-input-handling.md)

These detailed breakdowns provide practical examples of how to implement Quantum's core concepts in a real game.

## Additional Resources

- [Asteroids Tutorial](https://doc.photonengine.com/quantum/current/tutorials/asteroids/1-overview)
- [Complete Course to Quantum 3](https://doc.photonengine.com/quantum/current/tutorials/video-tutorial)
- [Game Samples](https://doc.photonengine.com/quantum/current/game-samples/platform-shooter-2d/overview)

These notes are designed to be used as a reference while developing with Photon Quantum. They focus on the code aspects to help with accurate implementation rather than theoretical explanations.

---

# 01-quantum-intro.md

# Photon Quantum Introduction

## Overview

Quantum is a high-performance deterministic ECS (Entity Component System) framework for online multiplayer games made with Unity, supporting up to 128 players.

- Uses predict/rollback networking
- Ideal for latency-sensitive games (sports, fighting, FPS)
- Robust with larger latency network connections
- Free for development with scaling pricing model

## Architecture

Quantum decouples:
- Simulation logic (Quantum ECS)
- View/presentation (Unity)
- Network implementation (predict/rollback + transport layer + game server logic)

![Quantum Decoupled Architecture](/docs/img/quantum/v2/getting-started/quantum-intro/quantum-sdk-layers.jpg)

### Core Components
- Server-managed predict/rollback simulation core
- Sparse-set ECS memory model and API
- Deterministic libraries (math, 2D/3D physics, navigation, animation, bots)
- Unity editor integration and tooling
- Built on Photon products (Photon Realtime transport, Photon Server)

## Predict/Rollback Networking

In deterministic systems:
- Game clients exchange only player input
- Simulation runs locally on all clients
- Clients can advance simulation locally using input prediction
- Rollback system handles restoring state and re-simulation when needed

Key concepts:
- Game-agnostic authoritative server component runs on Photon servers
- Synchronizes clocks and manages input latency
- Clients don't wait for slower clients (unlike lockstep networking)
- Server can be extended for matchmaking, player services, etc.

![Quantum Server-Managed predict/Rollback](/docs/img/quantum/v2/getting-started/quantum-intro/quantum-client-server.jpg)

## Entity Component System (ECS)

Quantum uses a high-performance sparse-set ECS model:
- Pointer-based C# code with custom heap allocator
- No C# heap memory allocation at runtime (no garbage)
- Efficient handling of re-simulations from input mispredictions
- Preserves CPU budget for Unity view/rendering code

### Code Generation

Game state is stored in:
- Sparse-set ECS data structures (entities and components)
- Custom heap-allocator (dynamic collections and custom data)
- Stored as blittable memory-aligned C# structs

#### Qtn DSL

Quantum uses a domain-specific language (Qtn) to generate C# code:

```qtn
// Components define reusable game state data groups
component Resources 
{
  Int32 Mana;
  FP Health;
}
```

Generated API provides functions to query and modify game state:

```csharp
var es = frame.Filter<Transform3D, Resources>();

// Sets the entity ref and pointers to the components
while (es.NextUnsafe(out var entity, out var transform, out var resources)) {
  transform->Position += FPVector3.Forward * frame.DeltaTime;
}
```

### Stateless Systems

Game logic is implemented through Systems:
- Stateless pieces of logic
- Execute on game state data
- Organized to process entities with specific components

Example of a system:

```csharp
public unsafe class LogicSystem : SystemMainThread
{
  public override void Update(Frame frame) 
  {
    // customer game logic here 
    // (frame is a reference for the generated game state container).
  }
}
```

## Quantum and Unity Integration

Since Quantum and Unity are decoupled, their communication is well defined:

![Quantum Inputs and Outputs](/docs/img/quantum/v3/getting-started/quantum-intro/quantum-inputs-outputs.jpg)

### Asset Database

Unity's editor and asset pipeline integrate with Quantum through:
- [Assets defined in Quantum](/quantum/current/manual/assets/assets-simulation)
- [Assets created within Unity](/quantum/current/manual/assets/assets-unity) specifically to be shared with Quantum
- Designers can work flexibly with familiar Unity workflows

![Character Classes - Asset Linking](/docs/img/quantum/v3/asset-linking.png)

### Input

[Input](/quantum/current/manual/input) must be defined and is sent to the server and distributed to all game clients every tick. This typically includes:
- Subset of keyboard/controller buttons
- Mouse/controller stick positions required by the game

### Commands

[Commands](/quantum/current/manual/commands) are for occasional actions and only sent when required.

### Events

[Events](/quantum/current/manual/quantum-ecs/game-events) transfer information from the Quantum simulation to the Unity view.

### Full Simulation State

The full simulation state from Quantum is observable from Unity:
- Common cases like synchronizing GameObject transforms to corresponding Quantum Entities are supported out of the box
- See [Entity Prototypes](/quantum/current/manual/entity-prototypes)
- Game-specific data (e.g., character health) can be read directly from the simulation state

## Getting Started

Recommended starting points:
- [Asteroids Tutorial](/quantum/current/tutorials/asteroids/1-overview) - Teaches all necessary basics
- [Complete Course to Quantum 3](/quantum/current/tutorials/video-tutorial) - Video tutorial stream
- [DSL Documentation](/quantum/current/manual/quantum-ecs/dsl) - Core programming concepts for the simulation
- [Entity Prototypes](/quantum/current/manual/entity-prototypes) - Core design concepts for the view
- [Game Samples](/quantum/current/game-samples/platform-shooter-2d/overview) - Downloadable examples

---

# 02-quantum-dsl.md

# Quantum DSL (Domain-Specific Language)

## Introduction

Quantum requires components and other runtime game state data types to be declared with its own DSL (domain-specific-language).

Key characteristics:
- Written in text files with `.qtn` extension
- Quantum compiler parses them into an AST (Abstract Syntax Tree)
- Generates partial C# struct definitions for each type
- Definitions can be split across multiple files (compiler merges them)

Benefits of using Quantum DSL:
- Abstracts away complex memory alignment requirements
- Supports Quantum's ECS sparse set memory model
- Required for deterministic predict/rollback simulation
- Eliminates boilerplate code for:
  - Type serialization (snapshots, game saves, killcam replays)
  - Checksumming
  - Debugging functions (printing/dumping frame data)

Creating a new `.qtn` file:
- Using Unity's Project tab context menu: `Create > Quantum > Qtn`
- Or create a file with `.qtn` extension directly

## Components

Components are special structs that can be attached to entities and used for filtering them.

Basic component definition example:

```qtn
component Action
{
  FP Cooldown;
  FP Power;
}
```

These are compiled to regular C# structs with:
- Appropriate code structure
- Marker interface
- ID property
- Other required metadata

### Pre-built Quantum Components

Quantum includes several pre-built components:

- **Transform2D/Transform3D**: position and rotation using Fixed Point (FP) values
- **PhysicsCollider, PhysicsBody, PhysicsCallbacks, PhysicsJoints (2D/3D)**: used by Quantum's stateless physics engines
- **PathFinderAgent, SteeringAgent, AvoidanceAgent, AvoidanceObstacle**: navmesh-based path finding and movement

## Structs

### DSL-Defined Structs

Regular structs can also be defined in the DSL:

```qtn
struct ResourceItem
{
  FP Value;
  FP MaxValue;
  FP RegenRate;
}
```

Features:
- Fields declared in same order but with adjusted memory offsets
- Optimal packing
- Avoids padding
- Can be used as types in other DSL definitions

Example of using a struct within a component:

```qtn
component Resources
{
  ResourceItem Health;
  ResourceItem Strength;
  ResourceItem Mana;
}
```

The generated struct is partial and can be extended in C#.

### C#-Defined Structs

You can also define structs directly in C#, but must manually:
- Define the memory layout using `LayoutKind.Explicit`
- Add a const int `SIZE` containing the struct's byte size
- Implement the `Serialize` function

Example:

```csharp
[StructLayout(LayoutKind.Explicit)]
public struct Foo {
  public const int SIZE = 12; // the size in bytes of all members in bytes.
  
  [FieldOffset(0)]
  public int A;
  
  [FieldOffset(4)]
  public int B;
  
  [FieldOffset(8)]
  public int C;
  
  public static unsafe void Serialize(void* ptr, FrameSerializer serializer)
  {
    var foo = (Foo*)ptr;
    serializer.Stream.Serialize(&foo->A);
    serializer.Stream.Serialize(&foo->B);
    serializer.Stream.Serialize(&foo->C);
  }
}
```

When using C# defined structs in the DSL, you must import them:

```qtn
import struct Foo(12);
```

**Note:** The *import* doesn't support constants in the size; you must specify the exact numerical value each time.

### Components vs. Structs

Components and structs differ in important ways:

Components:
- Contain generated meta-data
- Can be attached directly to entities
- Used to filter entities when traversing game state
- Can be accessed as pointers or value types

## Dynamic Collections

Quantum's custom allocator provides blittable collections for the rollback-able game state:
- Only support blittable types (primitives and DSL-defined types)

For collection management, the Frame API offers 3 methods for each collection type:
- `Frame.AllocateXXX`: Allocates space for the collection on the heap
- `Frame.FreeXXX`: Frees/deallocates the collection's memory
- `Frame.ResolveXXX`: Accesses the collection by resolving the pointer

**Important**: After freeing a collection, it **MUST** be nullified by setting it to `default`. This is required for proper serialization of the game state. Alternatively, you can use the `FreeOnComponentRemoved` attribute on the field.

### Important Notes on Collections

- Several components can reference the same collection instance
- Dynamic collections are stored as references inside components and structs
- Collections **must be** allocated when initialized and freed when no longer needed
- For collections in components, you can:
  - Implement reactive callbacks `ISignalOnAdd<T>` and `ISignalOnRemove<T>` and allocate/free the collections there
  - Use the `[AllocateOnComponentAdded]` and `[FreeOnComponentRemoved]` attributes for automatic handling
- Quantum does **NOT** pre-allocate collections from prototypes unless there is at least one value
- Attempting to free a collection more than once will throw an error and invalidate the heap

### Lists

Lists can be defined in the DSL using:

```qtn
component Targets {
  list<EntityRef> Enemies;
}
```

Core list API methods:
- `Frame.AllocateList<T>()`
- `Frame.FreeList(QListPtr<T> ptr)`
- `Frame.ResolveList(QListPtr<T> ptr)`

Once resolved, a list supports expected operations (Add, Remove, Contains, IndexOf, RemoveAt, [], etc.)

Example of using a list:

```csharp
namespace Quantum
{
  public unsafe class HandleTargets : SystemMainThread, ISignalOnComponentAdded<Targets>, ISignalOnComponentRemoved<Targets>
  {
    public override void Update(Frame frame) 
    {
      foreach (var (entity, component) in frame.GetComponentIterator<Targets>()) { 
        // To use a list, you must first resolve its pointer via the frame
        var list = frame.ResolveList(component.Enemies);

        // Do stuff
      }    
    }

    public void OnAdded(Frame frame, EntityRef entity, Targets* component)
    {
      // allocating a new List (returns the blittable reference type - QListPtr)
        component->Enemies = frame.AllocateList<EntityRef>();
    }
    
    public void OnRemoved(Frame frame, EntityRef entity, Targets* component)
    {
      // A component HAS TO de-allocate all collection it owns from the frame data, otherwise it will lead to a memory leak.
      // receives the list QListPtr reference.
      frame.FreeList(component->Enemies);
      
      // All dynamic collections a component points to HAVE TO be nullified in a component's OnRemoved
      // EVEN IF is only referencing an external one!
      // This is to prevent serialization issues that otherwise lead to a desynchronisation.
      component->Enemies = default;
    }
  }
}
```

### Dictionaries

Dictionaries can be declared in the DSL:

```qtn
component Hazard {
  dictionary<EntityRef, Int32> DamageDealt;
}
```

Core dictionary API methods:
- `Frame.AllocateDictionary<K,V>()`
- `Frame.FreeDictionary(QDictionaryPtr<K,V> ptr)`
- `Frame.ResolveDictionary(QDictionaryPtr<K,V> ptr)`

### HashSet

HashSets can be declared in the DSL:

```qtn
component Nodes {
  hash_set<FP> ProcessedNodes;
}
```

Core HashSet API methods:
- `Frame.AllocateHashSet(QHashSetPtr<T> ptr, int capacity = 8)`
- `Frame.FreeHashSet(QHashSetPtr<T> ptr)`
- `Frame.ResolveHashSet(QHashSetPtr<T> ptr)`

## Enums, Unions and Bitsets

### Enums

Enums define a set of named constant values:

```qtn
enum EDamageType {
    None, Physical, Magic
}

struct StatsEffect {
    EDamageType DamageType;
}
```

- Enums are treated as integer constants starting from 0 by default
- Values can be explicitly assigned
- You can specify an underlying type to reduce memory footprint:

```qtn
enum EModifierOperation : Byte
{
  None = 0,
  Add = 1,
  Subtract = 2
}
```

The `flags` keyword is used to indicate bit flags that can be combined:

```qtn
flags ETeamStatus : Byte
{
  None,
  Winning,
  SafelyWinning,
  LowHealth,
  MidHealth,
  HighHealth,
}
```

Using `flags` also generates utility methods like `IsFlagSet()`, which is more performant than `System.Enum.HasFlag()` as it avoids value type boxing.

### Unions

C-like unions overlay the memory of multiple structs:

```qtn
struct DataA
{
  FPVector2 Foo;
}

struct DataB
{
  FP Bar;
}

union Data
{
  DataA A;
  DataB B;
}
```

Unions can be used in components:

```qtn
component ComponentWithUnion {
  Data ComponentData;
}
```

Usage examples:

```csharp
private void UseWarriorAttack(Frame frame)
{
    var character = frame.Unsafe.GetPointer<Character>(entity);
    character->Data.Warrior->ImpulseDirection = FPVector3.Forward;
}

private void ResetSpellcasterMana(Frame frame)
{
    var character = frame.Unsafe.GetPointer<Character>(entity);
    character->Data.Spellcaster->Mana = FP._10;
}
```

You can check the currently active union type:

```csharp
private bool IsWarrior(CharacterData data)
{
    return data.Field == CharacterData.WARRIOR;
}
```

### Bitset

Bitsets declare fixed-size memory blocks for various purposes (fog-of-war, grid structures, etc.):

```qtn
struct FOWData
{
  bitset[256] Map;
}
```

## Input

Runtime input exchanged between clients is also declared in the DSL:

```qtn
input
{
  FPVector2 Movement;
  button Fire;
}
```

The input struct is polled every tick and sent to the server (when playing online).

For more information, see [Input](/quantum/current/manual/input).

## Signals

Signals are function signatures used for decoupled inter-system communication (publisher/subscriber pattern):

```qtn
signal OnDamage(FP damage, entity_ref entity);
```

This generates an interface that can be implemented by any System:

```csharp
public interface ISignalOnDamage
{
  public void OnDamage(Frame frame, FP damage, EntityRef entity);
}
```

Signals are the only concept allowing direct declaration of pointers in the DSL:

```qtn
signal OnBeforeDamage(FP damage, Resources* resources);
```

## Events

Events communicate what happens in the simulation to the rendering engine/view:

```qtn
event MyEvent{
  int Foo;
}
```

Trigger the event from the simulation:

```csharp
f.Events.MyEvent(2022);
```

Subscribe and consume the event in Unity:

```csharp
QuantumEvent.Subscribe(listener: this, handler: (MyEvent e) => Debug.Log($"MyEvent {e.Foo}"));
```

For more details, see [Frame Events Manual](/quantum/current/manual/quantum-ecs/game-events#frame_events).

## Globals

Define globally accessible variables in the DSL:

```qtn
global {
  // Any type that is valid in the DSL can also be used.
  FP MyGlobalValue;
}
```

Globals are part of the state and fully compatible with the predict-rollback system.

Variables in the global scope are accessible through the Frame API from any place with frame access.

**Note:** Singleton Components are an alternative to global variables (see the Components page in the ECS section).

## Special Types

Quantum provides special types to abstract complex concepts or protect against common mistakes with unmanaged code:

* `player_ref`: Runtime player index (can cast to/from Int32). Useful for storing which player controls an entity.
* `entity_ref`: Abstracts an entity's index and version, protecting from accidentally accessing deprecated data.
* `asset_ref<AssetType>`: Rollback-able reference to a data asset instance from the Quantum asset database.
* `list<T>`, `dictionary<K,T>`: Dynamic collection references stored in Quantum's frame heap. Only support blittable types.
* `array<Type>[size]`: Fixed-sized "arrays" for rollback-able data collections.

### Assets

Assets define data-driven containers that become immutable instances in an indexed database:

```qtn
asset CharacterData; // the CharacterData class is partially defined in a normal C# file by the developer
```

Example using special types:

```qtn
struct SpecialData
{
  player_ref Player;
  entity_ref Character;
  entity_ref AnotherEntity;
  asset_ref<CharacterData> CharacterData;
  array<FP>[10] TenNumbers;
}
```

## Available Types

### Default Types

Pre-imported cross-platform deterministic types:

* Boolean / bool (wrapped in QBoolean)
* Byte
* SByte
* UInt16 / Int16
* UInt32 / Int32
* UInt64 / Int64
* FP
* FPVector2
* FPVector3
* FPMatrix
* FPQuaternion
* PlayerRef / player_ref
* EntityRef / entity_ref
* LayerMask
* NullableFP / FP?
* NullableFPVector2 / FPVector2?
* NullableFPVector3 / FPVector3?
* QString (UTF-16)
* QStringUtf8 (UTF-8)
* Hit
* Hit3D
* Shape2D
* Shape3D
* Joint, DistanceJoint, SpringJoint and HingeJoint

**Note on QStrings**: `N` represents the total size in bytes minus 2 bytes for bookkeeping. For example, `QString<64>` uses 64 bytes for a string with max byte length of 62 bytes (up to 31 UTF-16 characters).

### Manual Import

Types not listed above must be manually imported when used in QTN files.

#### Importing specific types

To import types from other namespaces:

```qtn
import MyInterface;
// or
import MyNameSpace.Utils;
```

For enums:

```qtn
import enum MyEnum(underlying_type);

// Example for Quantum specific enums
import enum Shape3DType(byte);
```

#### Including namespaces

Add `using MyNamespace;` to any QTN file to include the namespace in the generated class.

---

# 03-entity-prototypes.md

# Entity Prototypes

## Introduction

Quantum features entity prototypes to facilitate data-driven design.

A Quantum Entity Prototype is a serialized version of an entity that includes:
- **Composition**: which components it is made of
- **Data**: the components' properties and their initial values

This provides a clean separation of data and behavior, allowing designers to tweak data without programmers having to constantly edit code.

## Setting up a Prototype

Entity prototypes can be set up in the Unity Editor.

### Basic Setup

To create an entity prototype:
1. Add the `QuantumEntityPrototype` component to any GameObject

![Entity Prototype Script on an empty GameObjet](/docs/img/quantum/v3/manual/entityprototype-basic.png)

The `QuantumEntityPrototype` script allows setting up parameters for commonly used components for both 2D and 3D:
- Transform (including Transform2DVertical for 2D)
- PhysicsCollider
- PhysicsBody
- NavMeshPathFinder
- NavMeshSteeringAgent
- NavMeshAvoidanceAgent

Dependencies for Physics and NavMesh related agents are respected. Refer to their respective documentation for more details.

### Custom Components

Additional components can be added to entity prototypes in two ways:
- Using the **+** button in the `Entity Components` list
- Using the regular Unity *Add Component* button and searching for the appropriate `QPrototype` component

#### Note on Collections

Dynamic collections in components are only automatically allocated **IF** there is at least one item in the prototype. Otherwise, the collection must be allocated manually. See the [Dynamics Collection entry on the DSL page](/quantum/current/manual/quantum-ecs/dsl#dynamic_collections) for more information.

### Hierarchy

In ECS, the concept of entity/GameObject hierarchy does not exist. Entity prototypes don't support hierarchies or nesting.

Although child prototypes aren't directly supported, you can:
1. Create separate prototypes in the scene and bake them
2. Link them by keeping a reference in a component
3. Update the position of the "child" manually

*Note:* Prototypes that aren't baked in scene must follow a different workflow where entities are created and linked in code.

It's possible to have hierarchies in game objects (View), but hierarchies in entities (Simulation) must be handled manually.

## Creating/Instantiating a Prototype

Once an entity prototype is defined in Unity, there are several ways to include it in the simulation.

### Baked in the Scene/Map

If the entity prototype is created as part of a Unity Scene:
- It will be baked into the corresponding Map Asset
- The baked entity prototype will be loaded when the Map is initialized with its baked values

**Note:** If a Scene's entity prototype is edited or has its values changed, the Map Data must be re-baked (which might happen automatically during some editor actions like saving the project, depending on the project setup).

### In Code

To create a new entity from a `QuantumEntityPrototype`:

1. Create a Unity Prefab of the GameObject with the `QuantumEntityPrototype` component
2. Place the Prefab in any folder included in the `QuantumEditorSettings` asset in `Asset Search Paths` (by default includes all the `Assets` folder)

![Entity Prototype Asset](/docs/img/quantum/v3/manual/entityprototype-asset.png)

This automatically generates an `EntityPrototype` asset associated with the prefab.

3. In the editor, reference these `EntityPrototype` assets via fields of type `AssetRef<EntityPrototype>`. This allows referencing the prototype through the simulation code while using familiar Unity drag-and-drop or asset selection.

Example of referencing an Entity Prototype asset in the editor:

![Entity Prototype Asset GUID & Path](/docs/img/quantum/v3/manual/assetref-entityprototype.png)

4. Use `frame.Create()` to create an entity from the prototype:

```csharp
void CreateExampleEntity(Frame frame) {
    // Using a reference to the entity prototype asset
    var exampleEntity = frame.Create(myPrototypeReference);
}
```

### Important Note

Entity prototypes present in the Scene are baked into the **Map Asset**, while prefab-ed entity prototypes are individual **assets** that are part of the Quantum Asset Database.

## Renaming a Component/Prototype

When renaming a component generated from the DSL, make sure to use Unity's asset database maintenance tooling. Deleting and recreating a component with a new name will break all existing entity prototypes that use the component.

## EntityView

The `EntityView` script is responsible for:
1. Displaying and updating the visual representation of a Quantum entity
2. Providing a way to access Unity transforms from within the Quantum simulation

To set up the connection between a GameObject and a Quantum entity:

1. Add the `EntityView` component to the GameObject
2. Link it to a Quantum entity by either:
   - Setting the `Entity Index` field with the entity ID
   - Having the `EntityView` component on a prefab that is instantiated through a Quantum entity callback

Once linked, the `EntityView` will synchronize the GameObject's position, rotation, and scale with the entity's Transform component in the Quantum simulation.

### EntityView Access

To access `EntityView` from within the Quantum simulation, use the `EntityViewTransform` API:

```csharp
// Make a Quantum entity follow a position in world space
public unsafe class FollowWorldPosition : SystemMainThread
{
    public override void Update(Frame frame)
    {
        // Get all entities with Transform3D and Follow components
        var filter = frame.Filter<Transform3D, Follow>();
        while (filter.Next(out var entity, out var transform, out var follow))
        {
            // Access the target world position through EntityViewTransform
            var worldPos = EntityViewTransform.GetWorldPosition(follow.Target);
            
            // Perform following logic with the world position
            // ...
        }
    }
}
```

### Overriding EntityView Behavior

You can customize how an `EntityView` behaves by inheriting from it and overriding its methods:

```csharp
public class CustomEntityView : EntityView
{
    // Override to customize the initialization
    public override void OnEntityInstantiated()
    {
        base.OnEntityInstantiated();
        // Your custom initialization
    }
    
    // Override to customize how transform is updated
    public override void OnEntityUpdate()
    {
        base.OnEntityUpdate();
        // Your custom update logic
    }
    
    // Override to handle entity destruction
    public override void OnEntityDestroyed()
    {
        // Your custom cleanup
        base.OnEntityDestroyed();
    }
}
```

## Runtime Entity Creation

To instantiate entities at runtime with a visual representation:

1. Create an entity prototype asset as described earlier
2. Create a prefab with the `EntityView` component
3. Link the entity prototype to the prefab through the `EntityPrototypeLinker`
4. When creating the entity in code, it will automatically instantiate the linked prefab:

```csharp
// In a Quantum system
void CreateEntityWithView(Frame frame)
{
    // Create entity from prototype
    var entity = frame.Create(prototypeAssetRef);
    
    // The EntityPrototypeLinker will handle instantiating the corresponding prefab
}
```

### Custom Entity Prototype Views

For more complex scenarios, you can create custom entity prototype views by:

1. Inheriting from `EntityPrototypeViewBase`
2. Implementing custom instantiation logic
3. Registering your view with the `EntityViewSystem`

Example:

```csharp
public class CustomPrototypeView : EntityPrototypeViewBase
{
    public override EntityView InstantiateView(EntityRef entityRef)
    {
        // Custom instantiation logic
        var instance = Instantiate(viewPrefab);
        var view = instance.GetComponent<EntityView>();
        view.EntityRef = entityRef;
        return view;
    }
}
```

## Best Practices

1. **Maintain Determinism**: Ensure that entity creation and modification in the simulation is deterministic. Use commands for player-initiated actions.

2. **Asset Organization**: Keep entity prototype prefabs in dedicated folders to maintain a clean project structure.

3. **Component Separation**: Clearly separate simulation components (Quantum) from view components (Unity).

4. **Memory Management**: Be mindful of dynamic collections in components - allocate and free them properly to avoid memory leaks.

5. **Testing**: Test prototypes in isolation before integrating them into complex gameplay scenarios.

---

# 04-input.md

# Quantum Input System

## Introduction

Input is a crucial component of Quantum's core architecture. In a deterministic networking library:
- The output is fixed and predetermined given a certain input
- When input is the same across all clients in the network, the output will also be the same

## Defining Input in DSL

Input can be defined in any [DSL](/quantum/current/manual/quantum-ecs/dsl) file. For example:

```qtn
input
{
    button Jump;
    FPVector3 Direction;
}
```

The server is responsible for batching and sending input confirmations for full tick-sets (all players' input). Therefore, this struct should be kept as small as possible.

## Commands vs. Input

While regular input is sent every frame, [Deterministic Commands](/quantum/current/manual/commands) provide another input path that:
- Can have arbitrary data and size
- Are ideal for special types of inputs (buy item, teleport, etc.)

## Polling Input in Unity

To send input to the Quantum simulation, you poll for it inside Unity by subscribing to the `PollInput` callback:

```csharp
private void OnEnable() 
{
  QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
}
```

Then, in the callback function, read from the input source and populate the input struct:

```csharp
public void PollInput(CallbackPollInput callback)
{
  Quantum.Input i = new Quantum.Input(); 
  
  var direction = new Vector3();
  direction.x = UnityEngine.Input.GetAxisRaw("Horizontal");
  direction.y = UnityEngine.Input.GetAxisRaw("Vertical");
  
  i.Jump = UnityEngine.Input.GetKey(KeyCode.Space);
  
  // convert to fixed point
  i.Direction = direction.ToFPVector3();
  
  callback.SetInput(i, DeterministicInputFlags.Repeatable);
}
```

**Note**: The float to fixed point conversion is deterministic because it is done before being shared with the simulation.

## Optimization Techniques

Although Quantum 3 uses delta-compression for input, it's still a good practice to make the raw `Input` data as compact as possible for optimal bandwidth.

### Using Buttons

The `button` type is used inside the Input DSL definition instead of booleans:
- Only uses one bit per instance in network transmission
- Locally contains more game state

```qtn
input
{
    button Jump;
}
```

Important notes on buttons:
- When polling from Unity, you should poll the *current button state* (whether it's pressed at the current frame)
- Quantum automatically sets up internal properties that allow checking specific states in simulation code:
  - `WasPressed`
  - `IsDown`
  - `WasReleased`
- Do not use Unity's `GetKeyUp()` or `GetKeyDown()` which would be problematic due to different update rates

Example of correctly polling button state in Unity:

```csharp
// In Unity, when polling a player's input
input.Jump = UnityEngine.Input.GetKey(KeyCode.Space);
```

For updating button state in Quantum simulation code (e.g., for bots):

```csharp
// In Quantum code, must be updated every frame
input.button.Update(frame, value);
```

### Encoded Direction

Movement is often represented using a direction vector:

```qtn
input
{
    FPVector2 Direction;
}
```

However, `FPVector2` comprises two 'FP' values, which takes up 16 bytes of data. For optimization, you can extend the `Input` struct and encode the directional vector into a `Byte` instead of sending the full vector every time.

Implementation example:

1. First, define the input with a `Byte` for encoded direction:

```qtn
input
{
    Byte EncodedDirection;
}
```

2. Then, extend the input struct (similar to extending a component):

```csharp
namespace Quantum
{
    partial struct Input
    {
        public FPVector2 Direction
        {
            get
            {
                if (EncodedDirection == default) 
                    return default;
                
                Int32 angle = ((Int32)EncodedDirection - 1) * 2;
            
                return FPVector2.Rotate(FPVector2.Up, angle * FP.Deg2Rad);
            }
            set
            {
                if (value == default)
                {
                    EncodedDirection = default;
                        return;
                }
               
                var angle = FPVector2.RadiansSigned(FPVector2.Up, value) * FP.Rad2Deg;
                
                angle = (((angle + 360) % 360) / 2) + 1;
            
                EncodedDirection = (Byte) (angle.AsInt);
            }
        }
    }
}
```

This implementation allows for the same usage as before but only takes up a single byte instead of 16 bytes. It works by utilizing a `Direction` property that automatically encodes and decodes the value from `EncodedDirection`.

## Best Practices

1. **Minimize Input Size**: Keep the input struct as small as possible to reduce network traffic.
   
2. **Use Buttons**: Prefer the `button` type over booleans for input actions.
   
3. **Consider Encoding**: For vectors and other large data types, consider encoding into smaller formats.
   
4. **Separate Occasional Inputs**: Use Commands for inputs that don't need to be sent every frame.
   
5. **Consistent Polling**: Make sure input is polled consistently for all players to maintain determinism.
   
6. **Test Network Conditions**: Test your input system under various network conditions to ensure it remains responsive.

---

# 05-commands.md

# Quantum Commands

## Introduction

Quantum Commands provide an alternative to sending data to the Quantum simulation beyond using regular Inputs. Key differences:

- Unlike Inputs, Commands are **not** required to be sent every tick
- Can be triggered in specific situations only when needed
- Fully reliable - the server will always accept and confirm them
- Locally executed immediately in predicted frames
- For remote clients, there's a delay until the Command is received (cannot predict the tick in which the command will be received)

Commands are implemented as C# classes that inherit from `Photon.Deterministic.DeterministicCommand`. They can contain any serializable data.

```csharp
namespace Quantum
{
  using Photon.Deterministic;

  public class CommandSpawnEnemy : DeterministicCommand
  {
    public AssetRefEntityPrototype EnemyPrototype;

    public override void Serialize(BitStream stream)
    {
      stream.Serialize(ref EnemyPrototype);
    }

    public void Execute(Frame frame)
    {
      frame.Create(EnemyPrototype);
    }
  }
}
```

## Commands Setup in the Simulation

After defining Command classes, they need to be registered in the `DeterministicCommandSetup`'s factories:

1. Navigate to `Assets/QuantumUser/Simulation`
2. Open the script `CommandSetup.User.cs`
3. Add desired commands to the factory:

```csharp
// CommandSetup.User.cs

namespace Quantum {
  using System.Collections.Generic;
  using Photon.Deterministic;

  public static partial class DeterministicCommandSetup {
    static partial void AddCommandFactoriesUser(ICollection<IDeterministicCommandFactory> factories, RuntimeConfig gameConfig, SimulationConfig simulationConfig) {
      // user commands go here
      // new instances will be created when a FooCommand is received (de-serialized)
      factories.Add(new FooCommand());

      // BazCommand instances will be acquired from/disposed back to a pool automatically
      factories.Add(new DeterministicCommandPool<BazCommand>());
    }
  }
}
```

## Sending Commands From The View

Commands can be sent from anywhere inside Unity:

```csharp
namespace Quantum
{
  using UnityEngine;

  public class EnemySpawnerUI : MonoBehaviour
  {
    [SerializeField] private AssetRefEntityPrototype _enemyPrototype;

    public void SpawnEnemy()
    {
      CommandSpawnEnemy command = new CommandSpawnEnemy()
      {
        EnemyPrototype = _enemyPrototype,
      };
      QuantumRunner.Default.Game.SendCommand(command);
    }
  }
}
```

### SendCommand Overloads

The `SendCommand()` method has two overloads:

```csharp
void SendCommand(DeterministicCommand command);
void SendCommand(Int32 player, DeterministicCommand command);
```

Specify the player index (PlayerRef) if multiple players are controlled from the same machine. Games with only one local player can ignore the player index field.

## Polling Commands From The Simulation

To receive and handle Commands inside the simulation, poll the frame for a specific player:

```csharp
using Photon.Deterministic;
namespace Quantum
{
    public class PlayerCommandsSystem : SystemMainThread
    {
        public override void Update(Frame frame)
        {
            for (int i = 0; i < f.PlayerCount; i++)
            {
                 var command = frame.GetPlayerCommand(i) as CommandSpawnEnemy;
                 command?.Execute(frame);
            }
        }
    }
}
```

### Implementation Note

The API doesn't enforce or implement a specific callback mechanism or design pattern for Commands. Developers must choose how to consume, interpret, and execute Commands, such as:
- Encoding them into signals
- Using a Chain of Responsibility
- Implementing command execution as a method within the command class

## Examples for Collections

### Serializing Lists

```csharp
namespace Quantum
{
    using System.Collections.Generic;
    using Photon.Deterministic;
    
    public class ExampleCommand : DeterministicCommand
    {
        public List<EntityRef> Entities = new List<EntityRef>();
        
        public override void Serialize(BitStream stream)
        {
            var count = Entities.Count;
            stream.Serialize(ref count);
            if (stream.Writing)
            {
                foreach (var e in Entities)
                {
                    var copy = e;
                    stream.Serialize(ref copy.Index);
                    stream.Serialize(ref copy.Version);
                }
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    EntityRef readEntity = default;
                    stream.Serialize(ref readEntity.Index);
                    stream.Serialize(ref readEntity.Version);
                    Entities.Add(readEntity);
                }   
            }
        }
    }
}
```

### Serializing Arrays

Using manual size tracking:

```csharp
namespace Quantum
{
    using Photon.Deterministic;
    
    public class ExampleCommand : DeterministicCommand
    {
        public EntityRef[] Entities = new EntityRef[10];
        public int EntitiesCount;
        
        public override void Serialize(BitStream stream)
        {
            stream.Serialize(ref EntitiesCount);
            for (int i = 0; i < EntitiesCount; i++)
            {
                stream.Serialize(ref Entities[i].Index);
                stream.Serialize(ref Entities[i].Version);
            }
        }
    }
}
```

Using `SerializeArrayLength` helper:

```csharp
namespace Quantum
{
    using Photon.Deterministic;
    
    public class ExampleCommand : DeterministicCommand
    {
        public EntityRef[] Entities;
        
        public override void Serialize(BitStream stream)
        {
            stream.SerializeArrayLength(ref Entities);
            for (int i = 0; i < Entities.Length; i++)
            {
                EntityRef e = Entities[i];
                stream.Serialize(ref e.Index);
                stream.Serialize(ref e.Version);
                Entities[i] = e;
            }
        }
    }
}
```

## Compound Commands

Only one command can be attached to an input stream per tick. Even if a client sends multiple Deterministic Commands in one tick, they will arrive separately on consecutive ticks. 

To overcome this limitation, you can use `CompoundCommand`, which is provided by the SDK and allows packing multiple Deterministic Commands into a single command:

### Instantiating and Sending Compound Commands

```csharp
var compound = new Quantum.Core.CompoundCommand();
compound.Commands.Add(new FooCommand());
compound.Commands.Add(new BazCommand());

QuantumRunner.Default.Game.SendCommand(compound);
```

### Intercepting and Processing Compound Commands

```csharp
public override void Update(Frame frame) {
  for (var i = 0; i < frame.PlayerCount; i++) {
      var compoundCommand = frame.GetPlayerCommand(i) as CompoundCommand;
      if (compoundCommand != null) {
        foreach (var cmd in compoundCommand.Commands) {
          // execute individual commands logic
        }
      }
  }
}
```

## Best Practices

1. **Use Commands for Occasional Actions**: Reserve commands for actions that don't need to be polled every frame.

2. **Keep Serialization Efficient**: Optimize serialization code to minimize bandwidth usage.

3. **Pool Commands**: For frequently used commands, consider using `DeterministicCommandPool` to reduce memory allocations.

4. **Use Compound Commands**: When multiple related actions need to happen at the same tick, pack them into a compound command.

5. **Consider Local Prediction**: Remember that commands are executed immediately in local predicted frames but have a delay on remote clients.

6. **Verify Validity**: Always verify command data before executing to prevent cheating or exploitation.

7. **Separate Command Logic**: Keep the command execution logic separate from the command definition for better maintainability.

---

# 06-events.md

# Quantum Events

## Introduction

Quantum's architecture separates the simulation (Quantum) and view (Unity), providing modularity for game state and visuals. There are two ways for the view to get information from the game state:

1. **Polling the game state**: Continuously checking the game state for information
2. **Events/Callbacks**: Receiving notifications when specific things happen

General usage pattern:
- **Polling**: Preferred for ongoing visuals (continuous updates)
- **Events**: Better for punctual occurrences where the simulation triggers a reaction in the view

This document focuses on **Frame Events** & **Callbacks**.

## Frame Events

Events are a fire-and-forget mechanism to transfer information from the simulation to the view. Important characteristics:

- Events should **never** be used to modify or update the game state (use `Signals` for that)
- Events do not synchronize between clients - they are fired by each client's own simulation
- The same Frame can be simulated multiple times (prediction, rollback), so events might trigger multiple times
- Quantum identifies duplicate events using a hash code function based on event data, ID, and tick
- Regular (non-`synced`) events will be canceled or confirmed once the predicted frame is verified
- Events are dispatched after all Frames have been simulated, right after the `OnUpdateView` callback
- Events are called in the same order they were invoked (with exceptions for non-`synced` duplicates)

### Basic Example

1. Define an Event using Quantum DSL:

```qtn
event MyEvent {
  int Foo;
}
```

2. Trigger the Event from the simulation:

```csharp
f.Events.MyEvent(2023);
```

3. Subscribe and consume the Event in Unity:

```csharp
QuantumEvent.Subscribe(listener: this, handler: (EventMyEvent e) => Debug.Log($"MyEvent {e.Foo}"));
```

### DSL Structure

Events and their data are defined using the Quantum DSL inside a qtn-file. After compiling, they become available via the `Frame.Events` API in the simulation.

```qtn
event MyEvent {
  FPVector3 Position;
  FPVector3 Direction;
  FP Length
}
```

Class inheritance allows sharing base Event classes and members:

```qtn
event MyBaseEvent {}
event SpecializedEventFoo : MyBaseEvent {}
event SpecializedEventBar : MyBaseEvent {}
```

Notes on inheritance:
- The `synced` keyword cannot be inherited
- Use abstract classes to prevent base-Events from being triggered directly:

```qtn
abstract event MyBaseEvent {}
event MyConcreteEvent : MyBaseEvent {}
```

You can reuse DSL-generated structs inside Events:

```qtn
struct FooEventData {
  FP Bar;
  FP Par;
  FP Rap;
}

event FooEvent {
  FooEventData EventData;
}
```

### Special Keywords

#### synced

To avoid rollback-induced false positive Events, mark them with the `synced` keyword:

```qtn
synced event MyEvent {}
```

This guarantees events will only be dispatched to Unity when the input for the Frame has been confirmed by the server. This introduces a delay between when the event is issued in the simulation and when it appears in the view.

Key points:
- `synced` Events never create false positives or false negatives
- Non-`synced` Events are never called twice on Unity

#### nothashed

Events use hash codes to prevent duplicates from being dispatched multiple times. Sometimes, minimal rollback-induced changes can cause the same conceptual event to be interpreted as two different events.

The `nothashed` keyword controls what data is used in the uniqueness test by ignoring parts of the Event data:

```qtn
abstract event MyEvent {
  nothashed FPVector2 Position;
  Int32 Foo;
}
```

#### local, remote

For events with a `player_ref` member, special keywords are available:

```qtn
event LocalPlayerOnly {
  local player_ref player;
}
```

```qtn
event RemotePlayerOnly {
  remote player_ref player;
}
```

These keywords cause the `player_ref` to be checked before dispatching the event on a client:
- `local`: Only dispatched if the player is a local player
- `remote`: Only dispatched if the player is a remote player

The simulation itself is agnostic to the concept of `remote` and `local`. The keywords only affect whether a particular event is raised in the view of an individual client.

You can combine `local` and `remote` with multiple `player_ref` parameters:

```qtn
event MyEvent {
  local player_ref LocalPlayer;
  remote player_ref RemotePlayer;
  player_ref AnyPlayer;
}
```

This event will only trigger on the client who controls the `LocalPlayer` and when the `RemotePlayer` is assigned to a different player.

If a client controls several players (e.g., split-screen), all their `player_ref` will be considered local.

#### client, server

This is only relevant when running server-side simulation on a custom Quantum plugin.

Events can be qualified using `client` and `server` keywords to scope where they will be executed. By default, all Events will be dispatched on both client and server.

```qtn
server synced event MyServerEvent {}
```

```qtn
client event MyClientEvent {}
```

### Using Events

#### Triggering Events

Event types and signatures are code-generated into the `Frame.FrameEvents` struct, accessible via `Frame.Events`:

```csharp
public override void Update(Frame frame) {
  frame.Events.MyEvent(2023);
}
```

#### Choosing Event Data

Event data should be self-contained and carry all information the subscriber will need to handle it in the view. When an Event is dispatched to the view:

- The Frame when the Event was raised might no longer be available
- Information needed to handle the Event could be lost if it wasn't included in the Event
- QCollections or QLists are passed as pointers to memory on the Frame heap, which might be unavailable
- EntityRefs might point to different data than when the Event was originally invoked

Ways to include collection data in Events:

1. Use fixed arrays for known, reasonable-sized collections:
```qtn
struct FooEventData {
  array<FP>[4] ArrayOfValues;
}
event FooEvent {
  FooEventData EventData;
}
```

2. Extend the Event implementation using partial classes (see "Extend Event Implementation" section)

#### Event Subscriptions In Unity

Quantum provides a flexible Event subscription API via `QuantumEvent`:

```csharp
QuantumEvent.Subscribe(listener: this, handler: (EventPlayerHit e) => Debug.Log($"Player hit in Frame {e.Tick}"));
```

You can also use a delegate function:

```csharp
QuantumEvent.Subscribe<EventPlayerHit>(listener: this, handler: OnEventPlayerHit);

private void OnEventPlayerHit(EventPlayerHit e){
  Debug.Log($"Player hit in Frame {e.Tick}");
}
```

`QuantumEvent.Subscribe` offers several optional parameters to qualify the subscription:

```csharp
// Only invoked once, then removed
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, once: true); 

// Not invoked if the listener is not active and enabled
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, onlyIfActiveAndEnabled: true); 

// Only called for runner with specified id
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, runnerId: "SomeRunnerId"); 

// Only called for a specific runner
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, runner: runnerReference); 

// Custom filter, invoked only if player 4 is local
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, filter: (QuantumGame game) => game.PlayerIsLocal(4)); 

// Only for replays
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, gameMode: DeterministicGameMode.Replay); 

// For all types except replays
QuantumEvent.Subscribe(this, (EventPlayerHit e) => {}, gameMode: DeterministicGameMode.Replay, exclude: true);
```

#### Unsubscribing From Events

Unity manages the lifetime of `MonoBehaviours`, so there's no need to unregister as listeners are cleaned up automatically.

For manual control:

```csharp
var subscription = QuantumEvent.Subscribe(...);

// Cancels this specific subscription
QuantumEvent.Unsubscribe(subscription); 

// Cancels all subscriptions for this listener
QuantumEvent.UnsubscribeListener(this); 

// Cancels all listeners to EventPlayerHit for this listener
QuantumEvent.UnsubscribeListener<EventPlayerHit>(this);
```

#### Event Subscriptions Outside MonoBehaviours

If an Event is subscribed outside of a `MonoBehaviour`, the subscription must be handled manually:

```csharp
var disposable = QuantumEvent.SubscribeManual((EventPlayerHit e) => {}); // subscribes to the event
// ...
disposable.Dispose(); // disposes the event subscription
```

#### Canceled And Confirmed Events

Non-`synced` Events are either canceled or confirmed once the verified Frame has been simulated. Quantum offers callbacks to react to these:

```csharp
QuantumCallback.Subscribe(this, (Quantum.CallbackEventCanceled c) => Debug.Log($"Cancelled event {c.EventKey}"));
QuantumCallback.Subscribe(this, (Quantum.CallbackEventConfirmed c) => Debug.Log($"Confirmed event {c.EventKey}"));
```

Event instances are identified by the `EventKey` struct. The previously received Event can be tracked using this key:

```csharp
public void OnEvent(MyEvent e) {
  EventKey eventKey = (EventKey)e;
  // Store in dictionary, etc.
}
```

### Extending Event Implementation

Although Events support using a `QList`, when resolving the list the corresponding Frame might not be available. Additional data types can be added using `partial` class declarations:

1. Define the event in Quantum DSL:
```qtn
event ListEvent {
  EntityRef Entity;
}
```

2. Extend the `partial FrameEvents` struct to raise the customized Event:

```csharp
namespace Quantum
{
  using System;
  using System.Collections.Generic;

  partial class EventListEvent {
    // Add the C# list field to the event object using partial
    public List<Int32> ListOfFoo;
  }

  partial class Frame {
    partial struct FrameEvents {
      public EventListEvent ListEvent(EntityRef entity, List<Int32> listOfFoo) {
        var ev = ListEvent(entity);
        if (ev == null) {
          // Synced or local events can be null for example during predicted frame
          return null;
        }

        // Reuse the list object of the pooled event
        if (ev.ListOfFoo == null) {
          ev.ListOfFoo = new List<Int32>(listOfFoo.Count);
        }
        ev.ListOfFoo.Clear();

        // Copy the content into the event to be independent from the input list
        ev.ListOfFoo.AddRange(listOfFoo);

        return ev;
      }
    }
  }
}
```

3. Call the event from the simulation code:

```csharp
// The list object can be cached and reused, its content is copied inside the ListEvent() call
f.Events.ListEvent(f, 0, new List<FP> {2, 3, 4});
```

## Callbacks

Callbacks are special events triggered internally by the Quantum Core. Available callbacks include:

| Callback | Description |
| --- | --- |
| CallbackPollInput | Called when the simulation queries local input |
| CallbackInputConfirmed | Called when local input was confirmed |
| CallbackGameStarted | Called when the game has been started |
| CallbackGameResynced | Called when the game has been re-synchronized from a snapshot |
| CallbackGameDestroyed | Called when the game was destroyed |
| CallbackUpdateView | Guaranteed to be called every rendered frame |
| CallbackSimulateFinished | Called when frame simulation has completed |
| CallbackEventCanceled | Called when an event raised in a predicted frame was cancelled |
| CallbackEventConfirmed | Called when an event was confirmed by a verified frame |
| CallbackChecksumError | Called on a checksum error |
| CallbackChecksumErrorFrameDump | Called when a frame is dumped due to a checksum error |
| CallbackChecksumComputed | Called when a checksum has been computed |
| CallbackPluginDisconnect | Called when the plugin disconnects the client with an error |

### Unity-side Callbacks

By configuring `Auto Load Scene From Map` in the `SimulationConfig` asset, you can control if the game scene will be loaded automatically and whether preview scene unloading happens before or after the game scene is loaded.

Scene loading/unloading callbacks:
- `CallbackUnitySceneLoadBegin`
- `CallbackUnitySceneLoadDone`
- `CallbackUnitySceneUnloadBegin`
- `CallbackUnitySceneUnloadDone`

### Subscribing to Callbacks

Callbacks are subscribed to and unsubscribed from in the same way as Events:

```csharp
QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
```

## Best Practices

1. **Choose the Right Mechanism**:
   - Use polling for continuous visual updates
   - Use events for one-time notifications
   - Use signals for inter-system communication within simulation

2. **Self-Contained Events**:
   - Events should carry all data needed to handle them
   - Do not rely on accessing the Frame when handling events

3. **Consider Synchronization**:
   - Use `synced` keyword for events that should never create false positives
   - Be aware of prediction/rollback when designing event systems

4. **Handle Collections Properly**:
   - Use fixed arrays for small collections
   - Extend events with partial classes for more complex data structures
   - Be careful with QCollections in events as the frame might be unavailable

5. **Optimize Subscriptions**:
   - Use subscription filters to limit when events are processed
   - Clean up manually managed subscriptions to prevent memory leaks

6. **Use Event Confirmation**:
   - Monitor event cancellation/confirmation for non-synced events
   - Consider visual feedback that can gracefully handle cancellation

---

# 07-systems.md

# Quantum Systems

## Introduction

Systems are the entry points for all gameplay logic in Quantum. They are implemented as normal C# classes but must adhere to specific restrictions to comply with the predict/rollback model:

1. **Must be stateless**: No mutable fields should be declared in systems. All mutable game data must be declared in `.qtn` files, which becomes part of the rollbackable game state inside the `Frame` class.

2. **Must be deterministic**: Systems must implement and/or use only deterministic libraries and algorithms. Quantum provides libraries for fixed point math, vector math, physics, random number generation, path finding, etc.

## System Types

There are several base system classes you can inherit from:

### SystemMainThread

```csharp
namespace Quantum {
  using Photon.Deterministic;
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class MySystem : SystemMainThread {
    public override void Update(Frame frame) {
      // Your game logic here
    }
  }
}
```

- Has `OnInit` and `Update` callbacks
- Update is executed once per system
- When iterating through entities and their components, you must create your own filters
- Can be used to subscribe and react to Quantum signals

### SystemMainThreadFilter<Filter>

```csharp
namespace Quantum {
  using Photon.Deterministic;
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class MyFilterSystem : SystemMainThreadFilter<MyFilterSystem.Filter> {
    public override void Update(Frame frame, ref Filter filter) {
      // Your game logic for this specific entity
    }

    public struct Filter {
      public EntityRef Entity;
      // Add component pointers here
    }
  }
}
```

- Similar to `SystemMainThread`
- Takes a filter that defines component layout
- `Update` is called once for every entity that has all components defined in the Filter

### SystemSignalsOnly

```csharp
namespace Quantum {
  using Photon.Deterministic;
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class MySignalSystem : SystemSignalsOnly {
    // Signal handlers here
  }
}
```

- Does *not* provide an `Update` callback
- Commonly used only for reacting to Quantum signals
- Has reduced overhead as it doesn't have task scheduling

### SystemBase

- For advanced uses only
- Used for scheduling parallel jobs into the task graph
- Not covered in the basic manual

## Core Systems

Quantum SDK includes all *Core* systems in the default `SystemsConfig`:

| System | Description |
| --- | --- |
| `Core.CullingSystem2D()` | Culls entities with a `Transform2D` component in predicted frames |
| `Core.CullingSystem3D()` | Culls entities with a `Transform3D` component in predicted frames |
| `Core.PhysicsSystem2D()` | Runs physics on entities with a `Transform2D` AND a `PhysicsCollider2D` component |
| `Core.PhysicsSystem3D()` | Runs physics on entities with a `Transform3D` AND a `PhysicsCollider3D` component |
| `Core.NavigationSystem()` | Used for all NavMesh related components |
| `Core.EntityPrototypeSystem()` | Creates, Materializes and Initializes `EntityPrototypes` |
| `Core.PlayerConnectedSystem()` | Triggers `ISignalOnPlayerConnected` and `ISignalOnPlayerDisconnected` signals |
| `Core.DebugCommand.CreateSystem()` | Used by the state inspector to send data to instantiate/remove/modify entities on the fly (Editor only) |

All systems are included by default for convenience. Core systems can be selectively added/removed based on the game's requirements; e.g., only keep the `PhysicsSystem2D` or `PhysicsSystem3D` based on what the game needs.

## Creating Systems in Unity

You can create Quantum systems using script templates in Unity's right-click menu:

![System Templates](/docs/img/quantum/v3/manual/quantum-system-templates.png)

## System API

Main callbacks that can be overridden in a System class:

- `OnInit(Frame frame)`: Executed only once when the game starts. Commonly used to set up initial game data.
- `Update(Frame frame)`: Used to advance the game state.
- `OnDisabled(Frame frame)` and `OnEnabled(Frame frame)`: Called when a system is directly disabled/enabled or when a parent system state is toggled.
- `UseCulling`: Defines if the System should exclude culled entities.

**Important**: It is mandatory for any Quantum system to use the attribute `[UnityEngine.Scripting.Preserve]`.

All callbacks include an instance of `Frame`, which is the container for all mutable and static game state data, including entities, physics, navigation, and immutable asset objects.

## Stateless Requirements

Systems must be stateless to comply with Quantum's predict/rollback model. Quantum only guarantees determinism if all mutable game state data is fully contained in the Frame instance.

Valid patterns:
- Creating read-only constants
- Using private methods (that receive all needed data as parameters)

```csharp
namespace Quantum 
{
  public unsafe class MySystem : SystemMainThread
  {
    // This is ok - read-only constant
    private const int _readOnlyData = 10;
    
    // This is NOT ok - mutable field that won't be rolled back
    // Would lead to instant drifts between clients during rollbacks
    private int _mutableData = 10;

    public override void Update(Frame frame)
    {
        // OK: Using a constant to compute something
        var temporaryData = _readOnlyData + 5;

        // NOT OK: Modifying transient data outside the Frame
        _transientData = 5;
    }
  }
}
```

## SystemsConfig

In Quantum 3, system configuration is handled through an asset named `SystemsConfig`. This config is passed into the `RuntimeConfig`, and Quantum automatically instantiates the requested systems.

To guarantee determinism, systems are executed in the order they're inserted in the SystemsConfig. Control the sequence of updates by arranging your custom systems in the desired order.

### Creating a new SystemsConfig

Create a new SystemsConfig by right-clicking in the project window and selecting Quantum > SystemsConfig. The asset has a serialized list of systems that you can manipulate like any normal Unity list.

![Systems Config](/docs/img/quantum/v3/manual/config-files/systems-config.png)

### Activating and Deactivating Systems

All injected systems are active by default, but you can control their status at runtime using methods available in the Frame object:

```csharp
public override void OnInit(Frame frame)
{
  // Deactivates MySystem - no updates or signals will be called
  frame.SystemDisable<MySystem>();

  // (Re)activates MySystem
  frame.SystemEnable<MySystem>();

  // Query if a System is currently enabled
  var enabled = frame.SystemIsEnabled<MySystem>();
}
```

Any System can deactivate and reactivate another System. A common pattern is to have a main controller system that manages the lifecycle of specialized Systems using a state machine (e.g., in-game lobby with countdown, normal gameplay, score state).

To make a system start disabled by default:

```csharp
public override bool StartEnabled => false;
```

### System Groups

Systems can be grouped to enable and disable them together:

1. Select the `SystemsConfig`
2. Add a new system of type `SystemGroup`
3. Append child systems to it

![System Group](/docs/img/quantum/v3/manual/ecs/system-setup-groups.png)

**Note**: The `Frame.SystemEnable<T>()` and `Frame.SystemDisable<T>()` methods identify systems by type. For multiple independent system groups, each group needs its own implementation:

```csharp
namespace Quantum
{
  public class MySystemGroup : SystemMainThreadGroup
  {
    public MySystemGroup(string update, params SystemMainThread[] children) : base(update, children)
    {
    }
  }
}
```

## Entity Lifecycle API

This section covers direct API methods for entity creation and composition. For a data-driven approach, refer to the chapter on entity prototypes.

### Creating Entities

```csharp
// Creates a new entity instance (returns an EntityRef)
var e = frame.Create();
```

### Adding Components

Entities don't have pre-defined components. Add components as needed:

```csharp
// Add a Transform3D component
var t = Transform3D.Create();
frame.Set(e, t);

// Add a PhysicsCollider3D component
var c = PhysicsCollider3D.Create(f, Shape3D.CreateSphere(1));
frame.Set(e, c);
```

### Entity Management

```csharp
// Destroys the entity, including all its components
frame.Destroy(e);

// Checks if an EntityRef is still valid
if (frame.Exists(e)) {
  // Safe to do stuff, Get/Set components, etc.
}
```

### Component Operations

You can check if an entity has specific components and access them:

```csharp
// Check if entity has a Transform3D component
if (frame.Has<Transform3D>(e)) {
  // Get a pointer to the component data
  var t = frame.Unsafe.GetPointer<Transform3D>(e);
  // Modify component data
  t->Position += FPVector3.Forward;
}
```

Using `ComponentSet` for checking multiple components:

```csharp
var components = ComponentSet.Create<CharacterController3D, PhysicsBody3D>();
if (frame.Has(e, components)) {
  // Entity has both components
}
```

Removing components:

```csharp
frame.Remove<Transform3D>(e);
```

### The EntityRef Type

Due to Quantum's rollback model, several copies of the game state are kept in separate memory locations. This means any direct pointer is only valid within a single Frame.

`EntityRef` provides a safe reference to entities that works across frames, as long as the entity still exists. It contains:
- Entity index: the entity slot
- Entity version number: used to invalidate old references when an entity is destroyed and its slot reused

### Filters

Quantum doesn't use "entity types." In the sparse-set ECS model, entities are indexes to component collections. Filters are used to create a set of components for systems to work with:

```csharp
public unsafe class MySystem : SystemMainThread
{
    public override void Update(Frame frame)
    {
        var filtered = frame.Filter<Transform3D, PhysicsBody3D>();

        while (filtered.Next(out var e, out var t, out var b)) {
          t.Position += FPVector3.Forward * frame.DeltaTime;
          frame.Set(e, t);
        } 
    }
}
```

For more details on filters, see the Components page.

## Pre-Built Assets and Config Classes

Quantum provides pre-built data assets that are accessible through the Frame object:

- **Map and NavMesh**: Playable area, static physics colliders, navigation meshes, etc.
- **SimulationConfig**: General configuration for physics engine, navmesh system, etc.
- **Default materials and agent configs**: Physics materials, character controllers, navmesh agents, etc.

Accessing Map and NavMesh instances:

```csharp
// Map is the container for several static data, such as navmeshes
Map map = f.Map;
var navmesh = map.NavMeshes["MyNavmesh"];
```

## Signals

Signals provide a publisher/subscriber API for inter-system communication. Example from a DSL file:

```qtn
signal OnDamage(FP damage, entity_ref entity);
```

This generates a trigger signal on the Frame class that any "publisher" System can call:

```csharp
// Any System can trigger the signal without coupling to specific implementations
f.Signals.OnDamage(10, entity)
```

A "subscriber" System implements the generated interface:

```csharp
namespace Quantum
{
  class CallbacksSystem : SystemSignalsOnly, ISignalOnDamage
  {
    public void OnDamage(Frame frame, FP damage, EntityRef entity)
    {
      // Called whenever any other system calls the OnDamage signal
    }
  }
}
```

Signals always include the Frame object as the first parameter.

### Built-in and Generated Signals

Besides explicit DSL-defined signals, Quantum includes pre-built signals (like physics collision callbacks) and auto-generated ones based on entity definitions:

- `ISignalOnPlayerDataSet`: Called when a game client sends a RuntimePlayer instance
- `ISignalOnPlayerConnected`/`ISignalOnPlayerDisconnected`: Player connection events
- `ISignalOnMapChanged`: Called when the map changes
- `ISignalOnEntityCreated`/`ISignalOnEntityDestroyed`: Entity lifecycle events

Additionally, component-specific signals are generated for adding/removing components:

- `ISignalOnComponentAdded<T>`
- `ISignalOnComponentRemoved<T>`

## Best Practices

1. **Maintain Statelessness**: Never store mutable state in System classes - all game state should be in the Frame.

2. **System Organization**: Group related functionality in cohesive systems and order them appropriately in SystemsConfig.

3. **Use Signal Pattern**: For inter-system communication, prefer signals over direct system dependencies.

4. **System Lifecycle Management**: Use system enable/disable methods to control game flow rather than complex conditionals.

5. **Optimize Filters**: Be careful when creating complex filters in performance-critical systems.

6. **Follow Entity Lifecycle**: Always check entity existence before accessing its components, especially with stored EntityRefs.

7. **Minimize Cache Misses**: Group related data accesses together to improve performance.

8. **Deterministic Operations**: Always use Quantum's deterministic libraries for calculations to ensure consistent behavior across clients.

---

# 08-components.md

# Quantum Components

## Introduction

Components are special structs that can be attached to entities and used for filtering them (iterating only a subset of active entities based on attached components).

Quantum provides several pre-built components:
- **Transform2D/Transform3D**: Position and rotation using Fixed Point (FP) values
- **PhysicsCollider, PhysicsBody, PhysicsCallbacks, PhysicsJoints (2D/3D)**: Used by Quantum's stateless physics engines
- **PathFinderAgent, SteeringAgent, AvoidanceAgent, AvoidanceObstacle**: NavMesh-based path finding and movement

## Defining Components

Components are defined in the Quantum DSL:

```qtn
component Action
{
    FP Cooldown;
    FP Power;
}
```

Labeling them as components (rather than simple structs) generates the appropriate code structure (marker interface, ID property, etc.). Once compiled, components become available in the Unity Editor for use with Entity Prototypes. In the editor, custom components are named *Entity Component ComponentName*.

## Working with Components

The API for working with components is accessed through the `Frame` class. There are two approaches:
1. Work with copies of components
2. Work with components via pointers

For clarity, the API distinguishes between these approaches:
- Direct access via `Frame` for working with copies
- Access via `Frame.Unsafe` for working with pointers (as this modifies memory directly)

## Component API

### Adding Components

`Add<T>` adds a component to an entity. Each entity can only have one instance of a particular component type. The method returns an `AddResult` enum for debugging:

```csharp
public enum AddResult {
    EntityDoesNotExist     = 0, // The EntityRef passed in is invalid
    ComponentAlreadyExists = 1, // The Entity already has this component attached
    ComponentAdded         = 2  // The component was successfully added to the entity
}
```

### Getting and Setting Components

Once an entity has a component, you can retrieve it with `Get<T>`, which returns a copy of the component value. Since you're working with a copy, you must save modified values using `Set<T>`, which returns a `SetResult`:

```csharp
public enum SetResult {
    EntityDoesNotExist = 0, // The EntityRef passed in is invalid
    ComponentUpdated   = 1, // The component values were successfully updated
    ComponentAdded     = 2  // The Entity did not have this component type yet, so it was added with the new values
}
```

Example of setting a health component value:

```csharp
private void SetHealth(Frame frame, EntityRef entity, FP value){    
    var health = frame.Get<Health>(entity);
    health.Value = value;
    frame.Set(entity, health);
}
```

### Component API Methods Summary

| Method | Return | Additional Info |
| --- | --- | --- |
| Add<T>(EntityRef entityRef) | `AddResult` enum | Allows an invalid `EntityRef` |
| Get<T>(EntityRef entityRef) | A copy of `T` with current values | Does **not** allow an invalid `EntityRef`. Throws an exception if component `T` is not present |
| Set<T>(EntityRef entityRef) | `SetResult` enum | Allows an invalid `EntityRef` |
| Has<T>(EntityRef entityRef) | `true` if entity exists and component is attached | Allows invalid `EntityRef` and component to not exist |
| TryGet<T>(EntityRef entityRef, out T value) | `true` if successful | Allows an invalid `EntityRef` |
| TryGetComponentSet(EntityRef entityRef, out ComponentSet componentSet) | `true` if entity exists and all components in set are attached | Allows an invalid `EntityRef` |
| Remove<T>(EntityRef entityRef) | No return value | Allows an invalid `EntityRef` |

### Unsafe API (Direct Memory Access)

To avoid the overhead of Get/Set operations, `Frame.Unsafe` offers versions that work directly with component memory:

| Method | Return | Additional Info |
| --- | --- | --- |
| GetPointer<T>(EntityRef entityRef) | `T*` | Does NOT allow invalid entity ref. Throws an exception if component `T` is not present |
| TryGetPointer<T>(EntityRef entityRef, out T* value) | `true` if successful | Allows an invalid `EntityRef` |
| AddOrGet<T>(EntityRef entityRef, out <T>* result) | `true` if the entity exists and component is attached/has been attached | Allows an invalid `EntityRef` |

**Note**: Monolithic structs should be avoided and split into multiple structs to prevent `bracket nesting level exceeded maximum` errors when compiling IL2CPP.

## Singleton Components

A *Singleton Component* is a special component type that can only have one instance in the entire game state. This is strictly enforced by Quantum.

Custom *Singleton Components* are defined in the DSL using `singleton component`:

```qtn
singleton component MySingleton {
    FP Foo;
}
```

Singletons inherit from `IComponentSingleton` which inherits from `IComponent`. They can:
- Be attached to any entity
- Be managed with all regular safe & unsafe methods (Get, Set, TryGetPointer, etc.)
- Be added to entity prototypes via the Unity Editor or in code

### Singleton API Methods

In addition to regular component methods, there are special methods for singletons:

| Method | Return | Additional Info |
| --- | --- | --- |
| **Frame API** | | |
| SetSingleton<T>(T component, EntityRef optionalAddTarget = default) | void | Sets a singleton if it doesn't exist. Optional EntityRef specifies which entity to add it to. If none provided, a new entity is created |
| GetSingleton<T>() | T | Throws exception if singleton doesn't exist. No EntityRef needed |
| TryGetSingleton<T>(out T component) | bool | Returns true if singleton exists. No EntityRef needed |
| GetOrAddSingleton<T>(EntityRef optionalAddTarget = default) | T | Gets singleton or creates it if it doesn't exist. Optional EntityRef specifies target entity |
| GetSingletonEntityRef<T>() | EntityRef | Returns entity holding the singleton. Throws if singleton doesn't exist |
| TryGetSingletonEntityRef<T>(out EntityRef entityRef) | bool | Gets entity holding the singleton. Returns false if singleton doesn't exist |
| **Frame.Unsafe API** | | |
| Unsafe.GetPointerSingleton<T>() | T* | Gets singleton pointer. Throws exception if it doesn't exist |
| TryGetPointerSingleton<T>(out T* component) | bool | Gets singleton pointer if it exists |
| GetOrAddSingletonPointer<T>(EntityRef optionalAddTarget = default) | T* | Gets or adds singleton and returns pointer |

## ComponentTypeRef

The `ComponentTypeRef` struct lets you reference a component by its type at runtime, useful for dynamically adding components via polymorphism:

```csharp
// Set in an asset or prototype
ComponentTypeRef componentTypeRef;

var componentIndex = ComponentTypeId.GetComponentIndex(componentTypeRef);

frame.Add(entityRef, componentIndex);
```

## Adding Functionality (Extending Components)

Since components are structs, you can extend them with custom methods by writing a *partial* struct definition in a C# file:

```csharp
namespace Quantum
{
    public partial struct Action
    {
        public void UpdateCooldown(FP deltaTime){
            Cooldown -= deltaTime;
        }
    }
}
```

## Reactive Callbacks

There are two component-specific reactive callbacks:

- `ISignalOnComponentAdd<T>`: Called when a component type T is added to an entity
- `ISignalOnComponentRemove<T>`: Called when a component type T is removed from an entity

These are particularly useful for initializing resources when a component is added and cleaning up when it's removed (e.g., allocating and deallocating a list).

To receive these signals, implement them in a system:

```csharp
public class ResourceManagerSystem : SystemSignalsOnly, 
    ISignalOnComponentAdd<ResourceList>, 
    ISignalOnComponentRemove<ResourceList>
{
    public void OnAdded(Frame frame, EntityRef entity, ResourceList* component)
    {
        // Initialize resources, e.g. allocate a list
        component->Items = frame.AllocateList<ResourceRef>();
    }
    
    public void OnRemoved(Frame frame, EntityRef entity, ResourceList* component)
    {
        // Clean up resources, e.g. free a list
        frame.FreeList(component->Items);
        component->Items = default;
    }
}
```

## Component Iterators

### Single Component Iterators

For iterating through entities with a single component type, `ComponentIterator` (safe) and `ComponentBlockIterator` (unsafe) are best suited:

```csharp
// Safe iterator (working with copies)
foreach (var pair in frame.GetComponentIterator<Transform3D>())
{
    var component = pair.Component;
    component.Position += FPVector3.Forward * frame.DeltaTime;
    frame.Set(pair.Entity, component);
}

// Unsafe iterator (working with pointers)
foreach (var pair in frame.Unsafe.GetComponentBlockIterator<Transform3D>())
{
    pair.Component->Position += FPVector3.Forward * frame.DeltaTime;
}

// Alternative syntax for deconstruction
foreach (var (entityRef, transform) in frame.Unsafe.GetComponentBlockIterator<Transform3D>())
{
    transform->Position += FPVector3.Forward * frame.DeltaTime;
}
```

## Filters

Filters provide a convenient way to get entities based on a set of components. They can be used with both safe (Get/Set) and unsafe (pointer) code.

### Generic Filters

Create a filter using the `Filter()` API:

```csharp
var filtered = frame.Filter<Transform3D, PhysicsBody3D>();
```

Generic filters can include up to 8 components. You can further refine filters using `without` and `any` ComponentSets:

```csharp
var without = ComponentSet.Create<CharacterController3D>();
var any = ComponentSet.Create<NavMeshPathFinder, NavMeshSteeringAgent>();
var filtered = frame.Filter<Transform3D, PhysicsBody3D>(without, any);
```

A `ComponentSet` can hold up to 8 components. The `without` parameter excludes entities that have any of the specified components, while the `any` parameter ensures entities have at least one of the specified components.

Iterating through a filter using `Next()` provides copies of the components:

```csharp
while (filtered.Next(out var e, out var t, out var b)) {
  t.Position += FPVector3.Forward * frame.DeltaTime;
  frame.Set(e, t);
}
```

**Note**: You must use `Set` to update the entity with the modified component copy.

For direct memory access, use `UnsafeNext()`:

```csharp
while (filtered.UnsafeNext(out var e, out var t, out var b)) {
  t->Position += FPVector3.Forward * frame.DeltaTime;
}
```

### FilterStruct

For more complex filters, define a struct with public fields for each component type:

```csharp
struct PlayerFilter
{
    public EntityRef Entity;           // Required
    public CharacterController3D* KCC; // Component pointer
    public Health* Health;             // Component pointer
    public FP AccumulatedDamage;       // Custom field (ignored by filter)
}
```

A `FilterStruct` can include up to 8 different component pointers. The struct **must** have an `EntityRef` field, and component fields **must** be pointers. Custom fields are ignored by the filter.

Using a `FilterStruct`:

```csharp
var players = f.Unsafe.FilterStruct<PlayerFilter>();
var playerStruct = default(PlayerFilter);

while (players.Next(&playerStruct))
{
    // Do stuff with playerStruct.KCC, playerStruct.Health, etc.
}
```

`FilterStruct` also supports the optional `any` and `without` ComponentSets.

### Note on Count

Filters don't know in advance how many entities they'll iterate over. This is due to how filters work in Sparse-Set ECS:
1. The filter finds which component has the fewest entities associated with it
2. It traverses that set and discards entities that don't have the other queried components

Getting an exact count would require traversing the filter once, which would be inefficient (O(n) operation).

## Component Getter

For getting a specific set of components from a known entity, use `Frame.Unsafe.ComponentGetter` with a filter struct:

```csharp
public unsafe class MySpecificEntitySystem : SystemMainThread
{
    struct MyFilter {
        public EntityRef Entity;     // Required
        public Transform2D* Transform;
        public PhysicsBody2D* Body;
    }

    public override void Update(Frame frame)
    {
        var entity = /* known entity ref */;
        
        var getter = frame.Unsafe.ComponentGetter<MyFilter>();
        var filter = default(MyFilter);
        
        // Fills the filter struct with component pointers
        if (getter.TryGet(entity, ref filter))
        {
            // Do something with filter.Transform, filter.Body
        }
    }
}
```

## Best Practices

1. **Choose the Right Access Pattern**: Use copy-based methods (`Get`/`Set`) for simplicity, and pointer-based methods for performance-critical code.

2. **Handle Dynamic Collections**: When a component contains dynamic collections, implement `ISignalOnComponentAdd<T>` and `ISignalOnComponentRemove<T>` to properly allocate and free memory.

3. **Avoid Monolithic Components**: Split large components into smaller, focused ones to prevent compilation issues and improve ECS efficiency.

4. **Use Singleton Wisely**: Use singleton components for global game state, but be mindful of their limitations (only one instance system-wide).

5. **Optimize Filtering**: Structure your component queries to start with the rarest component type for best performance.

6. **Extend with Methods**: Add behavior to components through partial struct definitions, but keep components primarily data-focused.

7. **Validate EntityRefs**: Always check if an entity exists before trying to access its components, especially when storing EntityRefs between frames.

8. **Component Composition**: Design components to be composable rather than creating specialized components for every case.

---

# 00-project-overview.md

# Quantum Arena Brawler Project Overview

This document provides a comprehensive overview of the Quantum Sports Arena Brawler sample project for Photon Quantum 3.0.3. The notes in this directory are structured to help you understand how Quantum works in practice through this sample game.

## Game Description

Quantum Sports Arena Brawler is a top-down 3v3 sports arena brawler where players:
- Pass the ball between teammates
- Punch opponents off the arena
- Score goals against the enemy team

The game is designed for fast-paced multiplayer action supporting up to 6 players, with up to 4 local players via split screen. It implements various gameplay techniques to ensure smooth multiplayer experience even at higher pings.

## Technical Information
- Built with Unity 2021.3.18f1
- Platforms: PC (Windows/Mac)
- Quantum version: 3.0.3 (Build 642)

## Project Structure

The game is organized into these key directories:

### Simulation Code (Quantum)
- **Assets/QuantumUser/Simulation/Quantum Sports Arena Brawler**: Contains the deterministic simulation code
  - **DSL**: QTN files defining game state (Ability, Ball, Player, etc.)
  - **Systems**: Implement game logic (Abilities, Ball handling, Player movement, etc.)
  - **Assets**: Define configuration for game objects and abilities

### Unity View Code
- **Assets/SportsArenaBrawler/Scripts**: Contains Unity-side view code
  - **Ball**: Ball visualization
  - **Player**: Player visualization and controllers
  - **Local Player**: Multi-local player management
  - **UI**: Game interface
  - **Effects**: Visual effects system

## Key Features Demonstrated

1. **Multiple Local Players**
   - Split-screen support for up to 4 local players
   - Automatic input device assignment
   - Custom lobby filtering based on local player count

2. **Data-Driven Ability System**
   - Input buffering for smoother gameplay
   - Activation delay to prevent mispredictions in multiplayer
   - Different ability sets based on ball possession

3. **Advanced Ball Physics**
   - Custom interpolation for fast-moving ball
   - Adaptive gravity scaling for varied throw styles
   - Lateral friction for controlled ball movement

4. **Character Controller**
   - Dynamic KCC configuration changes based on player state
   - "Coyote time" mechanic for better platforming feel
   - Momentum preservation during abilities

5. **Status Effects System**
   - Stun and knockback implementation
   - Recovery mechanics

6. **Game State Management**
   - Complete game loop (starting, running, scoring, game over)
   - Score tracking
   - Team mechanics

## Documentation Structure

The following documents provide detailed breakdowns of the different systems in the Quantum Arena Brawler sample:

1. [Game State Definition](01-game-state-definition.md): Core QTN state definitions
2. [Ability System](02-ability-system.md): Data-driven ability implementation
3. [Ball Handling System](03-ball-handling-system.md): Ball physics and interactions
4. [Player System](04-player-system.md): Player controllers and status
5. [Game Flow Management](05-game-flow-management.md): Game states and scoring
6. [Local Multiplayer](06-local-multiplayer.md): Split-screen implementation
7. [View Integration](07-view-integration.md): Quantum-Unity integration

Each document contains code examples that demonstrate Quantum patterns and how they're applied in this game.

---

# 01-game-state-definition.md

# Game State Definition

This document details the core data structures defined in the Quantum Arena Brawler's QTN files, which form the foundation of the game's deterministic simulation.

## Core Game State

The overall game state is managed through global variables that track the current game phase, timers, and score:

```csharp
// From Game.qtn
enum GameState
{
    None, Initializing, Starting, Running, GoalScored, GameOver
}

global
{
    GameState GameState;
    CountdownTimer GameStateTimer;
    CountdownTimer MainGameTimer;
    array<int>[2] TeamScore;
}

struct CountdownTimer
{
    FP TimeLeft;
    FP StartTime;
}
```

The game uses several signals and events to notify changes in game state:

```csharp
signal OnGoalScored(entity_ref playerEntityRef, PlayerTeam playerTeam);

synced event OnGameInitializing { }
synced event OnGameStarting { bool IsFirst; }
synced event OnGameRunning { }
synced event OnGoalScored { entity_ref PlayerEntityRef; PlayerTeam PlayerTeam; }
synced event OnGameOver { }
synced event OnGameRestarted { }
```

## Player Components and State

Players are represented with several components that track their status, abilities, and team association:

```csharp
// From Player.qtn
enum PlayerTeam
{
    Blue, Red
}

component PlayerStatus
{
    [ExcludeFromPrototype] player_ref PlayerRef;
    [ExcludeFromPrototype] entity_ref SpawnerEntityRef;
    [ExcludeFromPrototype] PlayerTeam PlayerTeam;

    [ExcludeFromPrototype] bool HasAirJump;
    [ExcludeFromPrototype] CountdownTimer JumpCoyoteTimer;
    [ExcludeFromPrototype] CountdownTimer RespawnTimer;
    [ExcludeFromPrototype] entity_ref HoldingBallEntityRef;

    asset_ref<PlayerMovementData> PlayerMovementData;
    
    [Space]
    StatusEffect StunStatusEffect;
    KnockbackStatusEffect KnockbackStatusEffect;
}

component PlayerSpawner
{
    player_ref PlayerRef;
    PlayerTeam PlayerTeam;
}
```

## Ability System Components

The ability system is defined through a set of components and structures that enable a data-driven approach:

```csharp
// From Ability.qtn
enum AbilityType
{
    Block, Dash, Attack, ThrowShort, ThrowLong, Jump
}

enum AbilityAvailabilityType
{
    Always, WithBall, WithoutBall
}

component AbilityInventory
{
    [ExcludeFromPrototype] ActiveAbilityInfo ActiveAbilityInfo;
    
    // Same order as AbilityType enum
    [Header("Ability Order: Block, Dash, Attack, ThrowShort, ThrowLong, Jump")]
    array<Ability>[6] Abilities;
}

struct ActiveAbilityInfo
{
    [ExcludeFromPrototype] int ActiveAbilityIndex;
    [ExcludeFromPrototype] FPVector3 CastDirection;
    [ExcludeFromPrototype] FPQuaternion CastRotation;
    [ExcludeFromPrototype] FPVector3 CastVelocity;
}

struct Ability
{
    [ExcludeFromPrototype] AbilityType AbilityType;
    [ExcludeFromPrototype] CountdownTimer InputBufferTimer;
    [ExcludeFromPrototype] CountdownTimer DelayTimer;
    [ExcludeFromPrototype] CountdownTimer DurationTimer;
    [ExcludeFromPrototype] CountdownTimer CooldownTimer;
    asset_ref<AbilityData> AbilityData;
}
```

## Ball Components

The ball has its own dedicated component to track its state:

```csharp
// From Ball.qtn
component BallStatus
{
    [ExcludeFromPrototype] entity_ref HoldingPlayerEntityRef;
    [ExcludeFromPrototype] CountdownTimer GravityChangeTimer;
    [ExcludeFromPrototype] CountdownTimer CatchTimeoutTimer;
    [ExcludeFromPrototype] player_ref CatchTimeoutPlayerRef;
    [ExcludeFromPrototype] bool HasCollisionEnter;
    [ExcludeFromPrototype] bool HasCollision;
    asset_ref<BallHandlingData> BallHandlingData;
}

component BallSpawner
{
}
```

## Status Effects System

The game implements a status effects system for stuns and knockbacks:

```csharp
// From StatusEffect.qtn
enum StatusEffectType
{
    Stun, Knockback
}

struct StatusEffect
{
    [ExcludeFromPrototype] CountdownTimer DurationTimer;
}

struct KnockbackStatusEffect : StatusEffect
{
    [ExcludeFromPrototype] FPVector3 KnockbackDirection;
    [ExcludeFromPrototype] FPVector3 KnockbackVelocity;
    asset_ref<KnockbackStatusEffectData> StatusEffectData;
}

[Serializable]
struct StatusEffectConfig
{
    StatusEffectType Type;
    FP Duration;
}
```

## Static Collider Linking

The game uses tagged static colliders to manage the arena environment:

```csharp
component StaticColliderLink
{
    Int32 StaticColliderIndex;
}

component TeamBaseWallStaticColliderTag { }
```

## Key Design Patterns

Several important design patterns are used in the game state definition:

1. **ExcludeFromPrototype Attributes**: Runtime values not serialized in entity prototypes
2. **Asset References**: Components reference external asset configurations for data-driven design
3. **Signals and Events**: Clear distinction between immediate causal triggers (signals) and notifications (events)
4. **Countdown Timers**: Consistent use of a CountdownTimer struct for time-based mechanics
5. **Component Composition**: Entities built from composable components rather than inheritance

## Extension Methods

The project uses extension methods for common operations, such as checking ability state:

```csharp
// Extension methods for the Ability struct
public static bool IsOnCooldown(this Ability ability)
{
    return ability.CooldownTimer.IsRunning;
}

public static bool IsDelayedOrActive(this Ability ability)
{
    return ability.DelayTimer.IsRunning || ability.DurationTimer.IsRunning;
}

public static bool HasBufferedInput(this Ability ability)
{
    return ability.InputBufferTimer.IsRunning;
}
```

## Input Structure

The game uses the `QuantumDemoInputTopDown` input structure:

```csharp
[ExcludeFromPrototype]
struct QuantumDemoInputTopDown {
    FPVector2 MoveDirection;
    FPVector2 AimDirection;
    button Left;
    button Right;
    button Up;
    button Down;
    button Jump;
    button Dash;
    button Fire;
    button AltFire;
    button Use;
}
```

This input structure is extended to support the specific ability inputs required by the game.

---

# 02-ability-system.md

# Ability System

This document details the Arena Brawler's data-driven ability system, focusing on how abilities are defined, activated, and managed.

## Ability System Overview

The ability system in Quantum Arena Brawler is built with several key features:

1. **Data-Driven Design**: All abilities are configured through asset files
2. **Input Buffering**: Smoother gameplay through queued ability activations
3. **Activation Delay**: Helps prevent mispredictions in the network simulation
4. **Contextual Abilities**: Different abilities available when holding/not holding the ball
5. **Priority System**: Clear activation order when multiple abilities are triggered

## Core Components

### AbilityInventory Component

Each player has an `AbilityInventory` component that stores all ability data:

```csharp
component AbilityInventory
{
    [ExcludeFromPrototype] ActiveAbilityInfo ActiveAbilityInfo;
        
    // Same order as AbilityType enum also used for activation priority
    [Header("Ability Order: Block, Dash, Attack, ThrowShort, ThrowLong, Jump")]
    array<Ability>[6] Abilities;
}
```

### Ability Struct

Each ability is represented by a struct containing all necessary state:

```csharp
struct Ability
{
    [ExcludeFromPrototype] AbilityType AbilityType;

    [ExcludeFromPrototype] CountdownTimer InputBufferTimer;
    [ExcludeFromPrototype] CountdownTimer DelayTimer;
    [ExcludeFromPrototype] CountdownTimer DurationTimer;
    [ExcludeFromPrototype] CountdownTimer CooldownTimer;

    asset_ref<AbilityData> AbilityData;
}
```

### ActiveAbilityInfo Struct

When an ability is active, its properties are stored in an `ActiveAbilityInfo` struct:

```csharp
struct ActiveAbilityInfo
{
    [ExcludeFromPrototype] int ActiveAbilityIndex;

    [ExcludeFromPrototype] FPVector3 CastDirection;
    [ExcludeFromPrototype] FPQuaternion CastRotation;
    [ExcludeFromPrototype] FPVector3 CastVelocity;
}
```

## Ability System Implementation

The `AbilitySystem` class is responsible for updating all player abilities:

```csharp
public unsafe class AbilitySystem : SystemMainThreadFilter<AbilitySystem.Filter>, 
    ISignalOnActiveAbilityStopped, 
    ISignalOnCooldownsReset, 
    ISignalOnComponentAdded<AbilityInventory>
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public PlayerStatus* PlayerStatus;
        public AbilityInventory* AbilityInventory;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        QuantumDemoInputTopDown input = *frame.GetPlayerInput(filter.PlayerStatus->PlayerRef);
            
        for (int i = 0; i < filter.AbilityInventory->Abilities.Length; i++)
        {
            AbilityType abilityType = (AbilityType)i;
            ref Ability ability = ref filter.AbilityInventory->Abilities[i];
            AbilityData abilityData = frame.FindAsset<AbilityData>(ability.AbilityData.Id);

            abilityData.UpdateAbility(frame, filter.EntityRef, ref ability);
            abilityData.UpdateInput(frame, ref ability, input.GetAbilityInputWasPressed(abilityType));
            abilityData.TryActivateAbility(frame, filter.EntityRef, filter.PlayerStatus, ref ability);
        }
    }
    
    // Signal handlers for stopping abilities and resetting cooldowns
    public void OnActiveAbilityStopped(Frame frame, EntityRef playerEntityRef)
    {
        AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(playerEntityRef);

        if (!abilityInventory->HasActiveAbility)
        {
            return;
        }

        for (int i = 0; i < abilityInventory->Abilities.Length; i++)
        {
            Ability ability = abilityInventory->Abilities[i];

            if (ability.IsDelayedOrActive)
            {
                ability.StopAbility(frame, playerEntityRef);
                break;
            }
        }
    }

    public void OnCooldownsReset(Frame frame, EntityRef playerEntityRef)
    {
        AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(playerEntityRef);

        for (int i = 0; i < abilityInventory->Abilities.Length; i++)
        {
            Ability ability = abilityInventory->Abilities[i];
            ability.ResetCooldown();
        }
    }
}
```

## Ability Data Base Class

The `AbilityData` class is the base class for all abilities:

```csharp
public unsafe partial class AbilityData : AssetObject
{
    public FP InputBuffer = FP._0_10 + FP._0_05;
    public FP Delay = FP._0_10 + FP._0_05;
    public FP Duration = FP._0_25;
    public FP Cooldown = 5;

    public AbilityAvailabilityType AvailabilityType;
    public AbilityCastDirectionType CastDirectionType = AbilityCastDirectionType.Aim;
    public bool FaceCastDirection = true;
    public bool KeepVelocity = false;
    public bool StartCooldownAfterDelay = false;
    
    [Header("Unity")] [SerializeField] private GameObject _uiAbilityPrefab;

    public virtual Ability.AbilityState UpdateAbility(Frame frame, EntityRef entityRef, ref Ability ability)
    {
        return ability.Update(frame, entityRef);
    }

    public virtual void UpdateInput(Frame frame, ref Ability ability, bool inputWasPressed)
    {
        if (inputWasPressed)
        {
            ability.BufferInput(frame);
        }
    }

    public virtual bool TryActivateAbility(Frame frame, EntityRef entityRef, PlayerStatus* playerStatus, ref Ability ability)
    {
        if ((AvailabilityType == AbilityAvailabilityType.WithBall && !playerStatus->IsHoldingBall) ||
            (AvailabilityType == AbilityAvailabilityType.WithoutBall && playerStatus->IsHoldingBall))
        {
            return false;
        }

        if (ability.HasBufferedInput)
        {
            if (ability.TryActivateAbility(frame, entityRef, playerStatus->PlayerRef))
            {
                return true;
            }
        }

        return false;
    }
}
```

## Ability Lifecycle

Each ability goes through a specific lifecycle:

1. **Input Detection**: Player presses input associated with ability
2. **Input Buffering**: Start a timer to remember input for a short period
3. **Activation Check**: Verify ability can be activated (not on cooldown, player state allows it)
4. **Activation Delay**: Short delay to synchronize with network
5. **Active Duration**: Ability effects active for the configured duration
6. **Cooldown**: Ability cannot be used again until cooldown expires

## Ability Extensions

These extension methods simplify working with abilities:

```csharp
public static class AbilityExtensions
{
    // Get an ability's state based on its timers
    public static Ability.AbilityState GetState(this Ability ability)
    {
        if (ability.DelayTimer.IsRunning)
        {
            return Ability.AbilityState.Delayed;
        }
        
        if (ability.DurationTimer.IsRunning)
        {
            return Ability.AbilityState.Active;
        }
        
        if (ability.CooldownTimer.IsRunning)
        {
            return Ability.AbilityState.Cooldown;
        }

        return Ability.AbilityState.Ready;
    }
    
    // Input buffering logic
    public static void BufferInput(this ref Ability ability, Frame frame)
    {
        AbilityData abilityData = frame.FindAsset<AbilityData>(ability.AbilityData.Id);
        ability.InputBufferTimer.Start(abilityData.InputBuffer);
    }
    
    // Ability activation logic
    public static bool TryActivateAbility(this ref Ability ability, Frame frame, EntityRef entityRef, PlayerRef playerRef)
    {
        AbilityData abilityData = frame.FindAsset<AbilityData>(ability.AbilityData.Id);
        AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(entityRef);
        
        if (ability.IsDelayedOrActive || ability.IsOnCooldown)
        {
            return false;
        }

        // Check for other active abilities
        for (int i = 0; i < abilityInventory->Abilities.Length; i++)
        {
            Ability otherAbility = abilityInventory->Abilities[i];
            if (otherAbility.IsDelayedOrActive)
            {
                return false;
            }
        }

        // Start timers
        ability.InputBufferTimer.Reset();
        ability.DelayTimer.Start(abilityData.Delay);
        ability.DurationTimer.Start(abilityData.Duration);
        
        if (!abilityData.StartCooldownAfterDelay)
        {
            ability.CooldownTimer.Start(abilityData.Cooldown);
        }

        // Store casting info
        SetAbilityCastingInfo(frame, abilityInventory, entityRef, playerRef, ref ability);
        
        return true;
    }
    
    // Helper to set casting info
    private static void SetAbilityCastingInfo(Frame frame, AbilityInventory* abilityInventory, EntityRef entityRef, 
                                              PlayerRef playerRef, ref Ability ability)
    {
        AbilityData abilityData = frame.FindAsset<AbilityData>(ability.AbilityData.Id);
        
        // Store active ability index
        abilityInventory->ActiveAbilityInfo.ActiveAbilityIndex = (int)ability.AbilityType;
        
        // Determine cast direction based on configuration
        abilityInventory->ActiveAbilityInfo.CastDirection = abilityData.GetCastDirection(frame, entityRef, playerRef);
        
        // Store rotation based on direction
        abilityInventory->ActiveAbilityInfo.CastRotation = FPQuaternion.LookRotation(
            abilityInventory->ActiveAbilityInfo.CastDirection);
            
        // Store current velocity if needed
        if (frame.Unsafe.TryGetPointer<CharacterController3D>(entityRef, out var kcc))
        {
            abilityInventory->ActiveAbilityInfo.CastVelocity = kcc->Velocity;
        }
    }
}
```

## Specific Ability Implementations

The game includes several ability types that inherit from the base `AbilityData` class:

### Attack Ability

```csharp
public unsafe class AttackAbilityData : AbilityData
{
    [Header("Attack")]
    public FP PunchRadius = 1;
    public FP PunchDistance = 2;
    public int PunchSegments = 3;
    public FP PunchDamage = 1;
    public FP StunDuration = 1;
    
    public override bool TryActivateAbility(Frame frame, EntityRef entityRef, PlayerStatus* playerStatus, ref Ability ability)
    {
        if (base.TryActivateAbility(frame, entityRef, playerStatus, ref ability))
        {
            frame.Events.OnPlayerAttacked(entityRef);
            
            // Perform punch hit detection using a compound shape of growing spheres
            AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(entityRef);
            Transform3D* transform = frame.Unsafe.GetPointer<Transform3D>(entityRef);
            
            for (int i = 0; i < PunchSegments; i++)
            {
                FP segmentDistance = PunchDistance * ((i + 1) / (FP)PunchSegments);
                FP segmentRadius = PunchRadius * (1 + i * FP._0_25);
                
                FPVector3 segmentCenter = transform->Position + 
                    abilityInventory->ActiveAbilityInfo.CastDirection * segmentDistance;
                
                PerformHitDetection(frame, entityRef, segmentCenter, segmentRadius);
            }
            
            return true;
        }
        
        return false;
    }
    
    private void PerformHitDetection(Frame frame, EntityRef attackerEntityRef, FPVector3 center, FP radius)
    {
        // Create sphere for hit detection
        Shape3D sphereShape = Shape3D.CreateSphere(radius);
        
        // Check for hits against players
        GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);
        HitCollection3D hitCollection = frame.Physics3D.OverlapShape(center, FPQuaternion.Identity, 
                                                                   sphereShape, gameSettingsData.PlayerLayerMask);
        
        for (int i = 0; i < hitCollection.Count; i++)
        {
            EntityRef hitEntityRef = hitCollection[i].Entity;
            
            // Skip self-hits
            if (hitEntityRef == attackerEntityRef)
            {
                continue;
            }
            
            if (frame.Unsafe.TryGetPointer<PlayerStatus>(hitEntityRef, out var hitPlayerStatus))
            {
                Transform3D* attackerTransform = frame.Unsafe.GetPointer<Transform3D>(attackerEntityRef);
                Transform3D* hitTransform = frame.Unsafe.GetPointer<Transform3D>(hitEntityRef);
                
                FPVector3 hitDirection = (hitTransform->Position - attackerTransform->Position).Normalized;
                
                // Apply knockback in hit direction
                frame.Signals.OnKnockbackApplied(hitEntityRef, StunDuration, hitDirection);
                
                // Apply stun
                frame.Signals.OnStunApplied(hitEntityRef, StunDuration);
                
                // Trigger hit event
                frame.Events.OnPlayerHit(hitEntityRef);
            }
        }
    }
}
```

### Block Ability

```csharp
public unsafe class BlockAbilityData : AbilityData
{
    // Simple block ability provides immunity to attacks while active
    public override bool TryActivateAbility(Frame frame, EntityRef entityRef, PlayerStatus* playerStatus, ref Ability ability)
    {
        if (base.TryActivateAbility(frame, entityRef, playerStatus, ref ability))
        {
            frame.Events.OnPlayerBlocked(entityRef);
            return true;
        }
        
        return false;
    }
}
```

### Dash Ability

```csharp
public unsafe class DashAbilityData : AbilityData
{
    [Header("Dash")]
    public FP DashDistance = 5;
    public FPAnimationCurve DashMovementCurve;
    
    private FP _lastNormalizedTime;
    
    public override Ability.AbilityState UpdateAbility(Frame frame, EntityRef entityRef, ref Ability ability)
    {
        Ability.AbilityState abilityState = base.UpdateAbility(frame, entityRef, ref ability);
        
        if (abilityState.IsActive)
        {
            AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(entityRef);
            Transform3D* transform = frame.Unsafe.GetPointer<Transform3D>(entityRef);
            CharacterController3D* kcc = frame.Unsafe.GetPointer<CharacterController3D>(entityRef);

            FP lastNormalizedPosition = DashMovementCurve.Evaluate(_lastNormalizedTime);
            FPVector3 lastRelativePosition = abilityInventory->ActiveAbilityInfo.CastDirection * 
                                           DashDistance * lastNormalizedPosition;

            FP newNormalizedTime = ability.DurationTimer.NormalizedTime;
            FP newNormalizedPosition = DashMovementCurve.Evaluate(newNormalizedTime);
            FPVector3 newRelativePosition = abilityInventory->ActiveAbilityInfo.CastDirection * 
                                          DashDistance * newNormalizedPosition;

            // Move by the delta between new and last position to avoid issues with KCC penetration correction
            transform->Position += newRelativePosition - lastRelativePosition;
            
            _lastNormalizedTime = newNormalizedTime;
        }
        else if (abilityState.IsDelayed && ability.DelayTimer.WasJustStarted)
        {
            // Reset last normalized time when ability activates
            _lastNormalizedTime = FP._0;
            
            frame.Events.OnPlayerDashed(entityRef);
        }
        
        return abilityState;
    }
}
```

### Jump Ability

```csharp
public unsafe class JumpAbilityData : AbilityData
{
    [Header("Jump")]
    public FP JumpVelocity = 10;
    public FP AirJumpVelocityMultiplier = FP._0_75;
    
    public override bool TryActivateAbility(Frame frame, EntityRef entityRef, PlayerStatus* playerStatus, ref Ability ability)
    {
        // Can only jump if grounded or has air jump
        CharacterController3D* kcc = frame.Unsafe.GetPointer<CharacterController3D>(entityRef);
        
        if (!kcc->Grounded && !playerStatus->JumpCoyoteTimer.IsRunning && !playerStatus->HasAirJump)
        {
            return false;
        }
        
        if (base.TryActivateAbility(frame, entityRef, playerStatus, ref ability))
        {
            bool isAirJump = !kcc->Grounded && !playerStatus->JumpCoyoteTimer.IsRunning;
            
            // Apply jump velocity
            FP jumpVelocity = JumpVelocity;
            if (isAirJump)
            {
                jumpVelocity *= AirJumpVelocityMultiplier;
                playerStatus->HasAirJump = false;
                
                frame.Events.OnPlayerAirJumped(entityRef);
            }
            else
            {
                playerStatus->JumpCoyoteTimer.Reset();
                
                frame.Events.OnPlayerJumped(entityRef);
            }
            
            // Apply velocity
            kcc->Velocity.Y = jumpVelocity;
            
            return true;
        }
        
        return false;
    }
}
```

### Throw Ball Ability

```csharp
public unsafe class ThrowBallAbilityData : AbilityData
{
    [Header("Throw")]
    public FP ThrowForce = 20;
    public FP ThrowUpwardAngle = 15;
    public FP GravityChangeTime = 1;
    public bool IsLongThrow = false;
    
    public override bool TryActivateAbility(Frame frame, EntityRef entityRef, PlayerStatus* playerStatus, ref Ability ability)
    {
        // Can only throw if holding the ball
        if (!playerStatus->IsHoldingBall)
        {
            return false;
        }
        
        if (base.TryActivateAbility(frame, entityRef, playerStatus, ref ability))
        {
            // Get the ball
            EntityRef ballEntityRef = playerStatus->HoldingBallEntityRef;
            BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
            PhysicsBody3D* ballPhysicsBody = frame.Unsafe.GetPointer<PhysicsBody3D>(ballEntityRef);
            
            // Release the ball
            frame.Signals.OnBallReleased(ballEntityRef);
            
            // Get throw direction
            AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(entityRef);
            FPVector3 throwDirection = abilityInventory->ActiveAbilityInfo.CastDirection;
            
            // Adjust direction for upward angle
            FPQuaternion upwardRotation = FPQuaternion.AngleAxis(ThrowUpwardAngle, FPVector3.Cross(throwDirection, FPVector3.Up).Normalized);
            throwDirection = upwardRotation * throwDirection;
            
            // Apply impulse to the ball
            ballPhysicsBody->AddLinearImpulse(throwDirection * ThrowForce);
            
            // Start with zero gravity, gradually increase
            ballPhysicsBody->GravityScale = FP._0;
            ballStatus->GravityChangeTimer.Start(GravityChangeTime);
            
            // Trigger event
            frame.Events.OnPlayerThrewBall(entityRef, IsLongThrow);
            
            return true;
        }
        
        return false;
    }
}
```

## Input Buffering

A key feature of the ability system is input buffering, which allows ability inputs to be stored for a short time:

1. When a player presses an ability button, even if the ability can't be activated immediately, the input is remembered 
2. As soon as conditions allow (e.g., after current ability ends), the buffered ability activates
3. This creates a more responsive feel and is especially important for chaining abilities

Input buffering makes the game more responsive in multiplayer situations by compensating for network latency.

## Ability Availability

The game changes available abilities based on the player's state:

- **Without ball**: Block, Dash, Attack, Jump
- **With ball**: Block, Dash, ThrowShort, ThrowLong, Jump

This context-sensitive ability system creates more strategic gameplay as player abilities change with ball possession.

---

# 03-ball-handling-system.md

# Ball Handling System

This document details the ball handling mechanics in the Quantum Arena Brawler, covering ball physics, catching/throwing mechanics, and view interpolation.

## Ball State Structure

The ball is managed through a `BallStatus` component that tracks its state:

```csharp
component BallStatus
{
    [ExcludeFromPrototype] entity_ref HoldingPlayerEntityRef;
    [ExcludeFromPrototype] CountdownTimer GravityChangeTimer;
    [ExcludeFromPrototype] CountdownTimer CatchTimeoutTimer;
    [ExcludeFromPrototype] player_ref CatchTimeoutPlayerRef;
    [ExcludeFromPrototype] bool HasCollisionEnter;
    [ExcludeFromPrototype] bool HasCollision;
    asset_ref<BallHandlingData> BallHandlingData;
}
```

This component tracks:
- Which player is holding the ball (if any)
- A timer for gravity scale changes after throwing
- A timeout to prevent immediate recatching by the same player
- Collision state for physics handling
- Configuration data reference

## Ball Handling System

The system that manages all ball interactions is implemented in the `BallHandlingSystem` class:

```csharp
public unsafe class BallHandlingSystem : SystemMainThreadFilter<BallHandlingSystem.Filter>, 
    ISignalOnBallReleased, 
    ISignalOnBallDropped, 
    ISignalOnBallPhysicsReset, 
    ISignalOnCollisionEnter3D, 
    ISignalOnCollision3D
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public BallStatus* BallStatus;
        public Transform3D* Transform;
        public PhysicsBody3D* PhysicsBody;
        public PhysicsCollider3D* Collider;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        BallHandlingData ballHandlingData = frame.FindAsset<BallHandlingData>(filter.BallStatus->BallHandlingData.Id);

        if (filter.BallStatus->IsHeldByPlayer)
        {
            CarryBall(frame, ref filter, ballHandlingData);
        }
        else
        {
            AttemptCatchBall(frame, ref filter, ballHandlingData);
        }

        UpdateBallGravityScale(frame, ref filter, ballHandlingData);
        HandleBallCollisions(frame, ref filter, ballHandlingData);

        filter.BallStatus->CatchTimeoutTimer.Tick(frame.DeltaTime);
    }
    
    // Additional methods for ball handling...
}
```

## Ball Catching Mechanics

The system checks for potential catches when the ball is not being held:

```csharp
private void AttemptCatchBall(Frame frame, ref Filter filter, BallHandlingData ballHandlingData)
{
    GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);

    Shape3D sphereShape = Shape3D.CreateSphere(ballHandlingData.CatchRadius);
    HitCollection3D hitCollection = frame.Physics3D.OverlapShape(
        filter.Transform->Position, 
        FPQuaternion.Identity, 
        sphereShape, 
        gameSettingsData.PlayerLayerMask);

    hitCollection.SortCastDistance();
    for (int i = 0; i < hitCollection.Count; i++)
    {
        Hit3D hit = hitCollection[i];

        if (!CanCatchBall(frame, ref filter, hit.Entity))
        {
            continue;
        }

        CatchBall(frame, ref filter, hit.Entity, ballHandlingData);
        break;
    }
}

private bool CanCatchBall(Frame frame, ref Filter filter, EntityRef playerEntityRef)
{
    PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);

    if (playerStatus->IsIncapacitated)
    {
        return false;
    }

    if (playerStatus->IsHoldingBall)
    {
        return false;
    }

    if (filter.BallStatus->CatchTimeoutTimer.IsRunning)
    {
        // Allow different players to catch immediately, but prevent same player from catching
        return filter.BallStatus->CatchTimeoutPlayerRef != playerStatus->PlayerRef;
    }

    return true;
}
```

When a catch happens, the ball is attached to the player:

```csharp
private void CatchBall(Frame frame, ref Filter filter, EntityRef playerEntityRef, BallHandlingData ballHandlingData)
{
    PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
    PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(playerStatus->PlayerMovementData.Id);

    // Link ball and player
    playerStatus->HoldingBallEntityRef = filter.EntityRef;
    filter.BallStatus->HoldingPlayerEntityRef = playerEntityRef;

    // Disable physics on the ball
    filter.Collider->Enabled = false;
    filter.PhysicsBody->IsKinematic = true;
    frame.Signals.OnBallPhysicsReset(filter.EntityRef);

    // Update player KCC settings to reflect holding the ball
    playerMovementData.UpdateKCCSettings(frame, playerEntityRef);

    // Position the ball on the player
    CarryBall(frame, ref filter, ballHandlingData);

    // Trigger event
    frame.Events.OnPlayerCaughtBall(playerEntityRef, filter.EntityRef);
}

private void CarryBall(Frame frame, ref Filter filter, BallHandlingData ballHandlingData)
{
    Transform3D* playerTransform = frame.Unsafe.GetPointer<Transform3D>(filter.BallStatus->HoldingPlayerEntityRef);

    // Position the ball relative to the player
    filter.Transform->Position = playerTransform->Position + 
                               (playerTransform->Rotation * ballHandlingData.DropLocalPosition);
}
```

## Ball Throwing

When a player throws the ball, the `ThrowBallAbilityData` (shown in the ability system document) performs the core logic, but the BallHandlingSystem handles the ball release:

```csharp
public void OnBallReleased(Frame frame, EntityRef ballEntityRef)
{
    BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
    BallHandlingData ballHandlingData = frame.FindAsset<BallHandlingData>(ballStatus->BallHandlingData.Id);
    PhysicsBody3D* ballPhysicsBody = frame.Unsafe.GetPointer<PhysicsBody3D>(ballEntityRef);
    PhysicsCollider3D* ballCollider = frame.Unsafe.GetPointer<PhysicsCollider3D>(ballEntityRef);

    EntityRef playerEntityRef = ballStatus->HoldingPlayerEntityRef;
    PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
    PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(playerStatus->PlayerMovementData.Id);

    // Unlink ball and player
    ballStatus->HoldingPlayerEntityRef = default;
    ballStatus->CatchTimeoutTimer.Start(ballHandlingData.CatchTimeout);
    ballStatus->CatchTimeoutPlayerRef = playerStatus->PlayerRef;

    // Re-enable physics
    ballCollider->Enabled = true;
    ballPhysicsBody->IsKinematic = false;

    // Update player
    playerStatus->HoldingBallEntityRef = default;
    playerMovementData.UpdateKCCSettings(frame, playerEntityRef);
}
```

## Customized Ball Physics

### Variable Gravity Scale

One key feature is the customized gravity scale that changes over time after a throw:

```csharp
private void UpdateBallGravityScale(Frame frame, ref Filter filter, BallHandlingData ballHandlingData)
{
    if (filter.BallStatus->GravityChangeTimer.IsRunning)
    {
        // Use a curve to gradually change gravity from 0 to 1
        FP gravityScale = ballHandlingData.ThrowGravityChangeCurve.Evaluate(
            filter.BallStatus->GravityChangeTimer.NormalizedTime);
        
        filter.PhysicsBody->GravityScale = gravityScale;

        filter.BallStatus->GravityChangeTimer.Tick(frame.DeltaTime);
        if (filter.BallStatus->GravityChangeTimer.IsDone)
        {
            ResetBallGravity(frame, filter.EntityRef);
        }
    }
}

private void ResetBallGravity(Frame frame, EntityRef ballEntityRef)
{
    BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
    PhysicsBody3D* physicsBody = frame.Unsafe.GetPointer<PhysicsBody3D>(ballEntityRef);

    ballStatus->GravityChangeTimer.Reset();
    physicsBody->GravityScale = FP._1;
}
```

This variable gravity allows for:
- Initial flat trajectories for short passes (zero gravity)
- Gradually increasing gravity to create natural arcs
- Better control over the throw distance and height

### Custom Friction

The system adds lateral friction to the ball when it collides with surfaces, creating more consistent and controllable physics:

```csharp
public void OnCollisionEnter3D(Frame frame, CollisionInfo3D info)
{
    if (frame.Unsafe.TryGetPointer(info.Entity, out BallStatus* ballStatus))
    {
        ballStatus->HasCollisionEnter = true;
    }
}

public void OnCollision3D(Frame frame, CollisionInfo3D info)
{
    if (frame.Unsafe.TryGetPointer(info.Entity, out BallStatus* ballStatus))
    {
        ballStatus->HasCollision = true;
    }
}

private void HandleBallCollisions(Frame frame, ref Filter filter, BallHandlingData ballHandlingData)
{
    if (!filter.PhysicsBody->IsKinematic)
    {
        if (filter.BallStatus->HasCollisionEnter)
        {
            // Apply bounce friction to reduce lateral velocity on collision
            filter.PhysicsBody->Velocity.X *= ballHandlingData.LateralBounceFriction;
            filter.PhysicsBody->Velocity.Z *= ballHandlingData.LateralBounceFriction;

            frame.Events.OnBallBounced(filter.EntityRef);
        }

        if (filter.BallStatus->HasCollision)
        {
            // Apply ground friction to slow the ball when rolling
            filter.PhysicsBody->Velocity.X *= ballHandlingData.LateralGroundFriction;
            filter.PhysicsBody->Velocity.Z *= ballHandlingData.LateralGroundFriction;
        }
    }

    filter.BallStatus->HasCollisionEnter = false;
    filter.BallStatus->HasCollision = false;
}
```

This dual friction system provides:
- Initial impact friction on bounces
- Continuous friction when the ball is in contact with the ground
- More natural ball behavior without having to manually tune the physics materials

## Ball Dropping

The ball can be dropped (as opposed to thrown) when a player is knocked off the arena or stunned:

```csharp
public void OnBallDropped(Frame frame, EntityRef ballEntityRef)
{
    BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
    BallHandlingData ballHandlingData = frame.FindAsset<BallHandlingData>(ballStatus->BallHandlingData.Id);
    Transform3D* ballTransform = frame.Unsafe.GetPointer<Transform3D>(ballEntityRef);
    PhysicsBody3D* ballPhysicsBody = frame.Unsafe.GetPointer<PhysicsBody3D>(ballEntityRef);

    Transform3D* playerTransform = frame.Unsafe.GetPointer<Transform3D>(ballStatus->HoldingPlayerEntityRef);

    // Release the ball
    frame.Signals.OnBallReleased(ballEntityRef);

    // Position it at drop location
    ballTransform->Position = playerTransform->Position + 
                            (playerTransform->Rotation * ballHandlingData.DropLocalPosition);

    // Apply a small random impulse when dropping
    FPVector3 dropImpulse = new FPVector3(
        frame.RNG->NextInclusive(ballHandlingData.DropMinImpulse.X, ballHandlingData.DropMaxImpulse.X),
        frame.RNG->NextInclusive(ballHandlingData.DropMinImpulse.Y, ballHandlingData.DropMaxImpulse.Y),
        frame.RNG->NextInclusive(ballHandlingData.DropMinImpulse.Z, ballHandlingData.DropMaxImpulse.Z));

    FPVector3 impulseRelativePoint = ballPhysicsBody->CenterOfMass;
    impulseRelativePoint.Y += ballHandlingData.DropImpulseOffsetY;

    ballPhysicsBody->AddLinearImpulse(playerTransform->Rotation * dropImpulse, impulseRelativePoint);
}
```

## Ball Respawning

The ball can be respawned when it falls off the arena or when a goal is scored:

```csharp
public unsafe class BallSpawnSystem : SystemMainThreadFilter<BallSpawnSystem.Filter>, 
    ISignalOnBallSpawned, 
    ISignalOnBallRespawned, 
    ISignalOnBallDespawned
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public BallSpawner* BallSpawner;
        public Transform3D* Transform;
    }

    private EntityRef _spawnedBallEntityRef;

    public override void Update(Frame frame, ref Filter filter)
    {
        // Check if ball fell out of bounds
        if (_spawnedBallEntityRef != default)
        {
            BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(_spawnedBallEntityRef);
            Transform3D* ballTransform = frame.Unsafe.GetPointer<Transform3D>(_spawnedBallEntityRef);
            
            if (ballTransform->Position.Y < -10)  // Out of bounds check
            {
                frame.Signals.OnBallRespawned(_spawnedBallEntityRef);
            }
        }
    }

    public void OnBallSpawned(Frame frame)
    {
        var filtered = frame.Filter<BallSpawner, Transform3D>();
        if (!filtered.Next(out EntityRef spawnerEntityRef, out _, out _))
        {
            return;
        }

        Transform3D* spawnerTransform = frame.Unsafe.GetPointer<Transform3D>(spawnerEntityRef);
        
        // Create the ball entity
        EntityPrototype ballPrototype = frame.FindAsset<EntityPrototype>("Ball");
        _spawnedBallEntityRef = frame.Create(ballPrototype, spawnerTransform->Position, spawnerTransform->Rotation);
    }

    public void OnBallRespawned(Frame frame, EntityRef ballEntityRef)
    {
        var filtered = frame.Filter<BallSpawner, Transform3D>();
        if (!filtered.Next(out EntityRef spawnerEntityRef, out _, out _))
        {
            return;
        }

        Transform3D* spawnerTransform = frame.Unsafe.GetPointer<Transform3D>(spawnerEntityRef);
        
        // Reset the ball position
        Transform3D* ballTransform = frame.Unsafe.GetPointer<Transform3D>(ballEntityRef);
        ballTransform->Position = spawnerTransform->Position;
        
        // Reset physics
        frame.Signals.OnBallPhysicsReset(ballEntityRef);
        
        // Make sure the ball isn't held by any player
        BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
        if (ballStatus->IsHeldByPlayer)
        {
            EntityRef playerEntityRef = ballStatus->HoldingPlayerEntityRef;
            PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
            
            playerStatus->HoldingBallEntityRef = default;
            ballStatus->HoldingPlayerEntityRef = default;
            
            // Update player KCC settings
            PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(playerStatus->PlayerMovementData.Id);
            playerMovementData.UpdateKCCSettings(frame, playerEntityRef);
        }
    }

    public void OnBallDespawned(Frame frame, EntityRef ballEntityRef)
    {
        // Release ball if held by player
        BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
        if (ballStatus->IsHeldByPlayer)
        {
            EntityRef playerEntityRef = ballStatus->HoldingPlayerEntityRef;
            PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
            
            playerStatus->HoldingBallEntityRef = default;
            ballStatus->HoldingPlayerEntityRef = default;
            
            // Update player KCC settings
            PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(playerStatus->PlayerMovementData.Id);
            playerMovementData.UpdateKCCSettings(frame, playerEntityRef);
        }
        
        // Destroy the ball entity
        frame.Destroy(ballEntityRef);
        _spawnedBallEntityRef = default;
    }
}
```

## Ball View Interpolation

On the Unity side, the BallEntityView handles interpolation between simulation position and animated position:

```csharp
public unsafe class BallEntityView : QuantumEntityView
{
    [SerializeField] private float _spaceTransitionSpeed = 4f;

    private EntityRef _holdingPlayerEntityRef;
    private float _interpolationSpaceAlpha;

    private Vector3 _lastBallRealPosition;
    private Quaternion _lastBallRealRotation;

    private Vector3 _lastBallAnimationPosition;
    private Quaternion _lastBallAnimationRotation;

    protected override void ApplyTransform(ref UpdatePositionParameter param)
    {
        base.ApplyTransform(ref param);

        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(EntityRef);

        _holdingPlayerEntityRef = ballStatus->HoldingPlayerEntityRef;
    }

    public void UpdateSpaceInterpolation()
    {
        bool isBallHeldByPlayer = _holdingPlayerEntityRef != default;
        UpdateInterpolationSpaceAlpha(isBallHeldByPlayer);

        if (isBallHeldByPlayer)
        {
            // Get animation position from the player's ball mount point
            PlayerViewController player = PlayersManager.Instance.GetPlayer(_holdingPlayerEntityRef);

            _lastBallAnimationPosition = player.BallFollowTransform.position;
            _lastBallAnimationRotation = player.BallFollowTransform.rotation;
        }
        else
        {
            // Track the real position from simulation
            _lastBallRealPosition = transform.position;
            _lastBallRealRotation = transform.rotation;
        }

        if (_interpolationSpaceAlpha > 0f)
        {
            // Blend between real simulation position and animated position
            Vector3 interpolatedPosition = Vector3.Lerp(_lastBallRealPosition, _lastBallAnimationPosition, _interpolationSpaceAlpha);
            Quaternion interpolatedRotation = Quaternion.Slerp(_lastBallRealRotation, _lastBallAnimationRotation, _interpolationSpaceAlpha);

            transform.SetPositionAndRotation(interpolatedPosition, interpolatedRotation);
        }
    }

    private void UpdateInterpolationSpaceAlpha(bool isBallHeldByPlayer)
    {
        float deltaChange = _spaceTransitionSpeed * Time.deltaTime;
        if (isBallHeldByPlayer)
        {
            _interpolationSpaceAlpha += deltaChange;
        }
        else
        {
            _interpolationSpaceAlpha -= deltaChange;
        }

        _interpolationSpaceAlpha = Mathf.Clamp(_interpolationSpaceAlpha, 0f, 1f);
    }
}
```

This interpolation system handles the transition between:
1. **Simulation Space**: When the ball is free-moving, the Quantum physics system controls it
2. **Animation Space**: When held by a player, the Unity animation system can take over

The gradual transition between these spaces makes for smooth visuals even when quickly changing states.

## Ball Data Configuration

The `BallHandlingData` asset defines all configurable aspects of the ball:

```csharp
[CreateAssetMenu(menuName = "Quantum/Arena Brawler/Ball Handling Data")]
public class BallHandlingData : AssetObject
{
    [Header("Catching")]
    public FP CatchRadius = 1;
    public FP CatchTimeout = 1;
    
    [Header("Carrying")]
    public FPVector3 DropLocalPosition = new FPVector3(0, 1, 0);
    
    [Header("Dropping")]
    public FPVector3 DropMinImpulse = new FPVector3(-1, 2, -1);
    public FPVector3 DropMaxImpulse = new FPVector3(1, 3, 1);
    public FP DropImpulseOffsetY = FP._0_25;
    
    [Header("Physics")]
    public FP LateralBounceFriction = FP._0_80;
    public FP LateralGroundFriction = FP._0_98;
    
    [Header("Gravity")]
    public FPAnimationCurve ThrowGravityChangeCurve;
}
```

This data-driven approach allows for easy tuning and experimentation with ball physics without code changes.

---

# 04-player-system.md

# Player System

This document describes the player-related systems in the Quantum Arena Brawler, including movement, status effects, and respawning.

## Player Components

### PlayerStatus Component

The core component that tracks player state:

```csharp
component PlayerStatus
{
    [ExcludeFromPrototype] player_ref PlayerRef;
    [ExcludeFromPrototype] entity_ref SpawnerEntityRef;
    [ExcludeFromPrototype] PlayerTeam PlayerTeam;

    [ExcludeFromPrototype] bool HasAirJump;
    [ExcludeFromPrototype] CountdownTimer JumpCoyoteTimer;
    [ExcludeFromPrototype] CountdownTimer RespawnTimer;
    [ExcludeFromPrototype] entity_ref HoldingBallEntityRef;

    asset_ref<PlayerMovementData> PlayerMovementData;
    
    [Space]
    StatusEffect StunStatusEffect;
    KnockbackStatusEffect KnockbackStatusEffect;
}
```

### PlayerSpawner Component

Manages player spawning and respawning:

```csharp
component PlayerSpawner
{
    player_ref PlayerRef;
    PlayerTeam PlayerTeam;
}
```

## Player Movement System

The MovementSystem handles player movement, rotation, and jumping mechanics:

```csharp
public unsafe class MovementSystem : SystemMainThreadFilter<MovementSystem.Filter>
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public PlayerStatus* PlayerStatus;
        public Transform3D* Transform;
        public CharacterController3D* KCC;
        public AbilityInventory* AbilityInventory;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        QuantumDemoInputTopDown input = *frame.GetPlayerInput(filter.PlayerStatus->PlayerRef);

        bool wasGrounded = filter.KCC->Grounded;
        bool hasActiveAbility = filter.AbilityInventory->TryGetActiveAbility(out Ability activeAbility);

        AbilityData activeAbilityData = null;

        if (hasActiveAbility)
        {
            activeAbilityData = frame.FindAsset<AbilityData>(activeAbility.AbilityData.Id);
        }

        // Move
        PlayerMovementData movementData = frame.FindAsset<PlayerMovementData>(filter.PlayerStatus->PlayerMovementData.Id);

        if ((hasActiveAbility && !activeAbilityData.KeepVelocity) ||
            filter.PlayerStatus->IsKnockbacked)
        {
            // Apply additional velocity braking
            filter.KCC->Velocity = FPVector3.Lerp(filter.KCC->Velocity, FPVector3.Zero, movementData.NoMovementBraking * frame.DeltaTime);
        }

        FPVector3 movementDirection;
        if (hasActiveAbility || filter.PlayerStatus->IsIncapacitated)
        {
            movementDirection = FPVector3.Zero;
        }
        else
        {
            movementDirection = input.MoveDirection.XOY;
            if (movementDirection.SqrMagnitude > FP._1)
            {
                movementDirection = movementDirection.Normalized;
            }
        }

        if (!filter.PlayerStatus->IsRespawning)
        {
            filter.KCC->Move(frame, filter.EntityRef, movementDirection);
        }

        // Rotation handling
        HandleRotation(frame, ref filter, input, movementDirection, movementData, hasActiveAbility, activeAbilityData);

        // Update grounded state and jump coyote time
        UpdateGroundedState(frame, ref filter, wasGrounded, movementData, hasActiveAbility);
    }

    private void HandleRotation(Frame frame, ref Filter filter, QuantumDemoInputTopDown input, 
                                FPVector3 movementDirection, PlayerMovementData movementData, 
                                bool hasActiveAbility, AbilityData activeAbilityData)
    {
        FP rotationSpeed;
        FPQuaternion currentRotation = filter.Transform->Rotation;
        FPQuaternion targetRotation = currentRotation;

        if (filter.PlayerStatus->IsKnockbacked)
        {
            // Face opposite to knockback direction
            rotationSpeed = movementData.QuickRotationSpeed;
            targetRotation = FPQuaternion.LookRotation(-filter.PlayerStatus->KnockbackStatusEffect.KnockbackDirection);
        }
        else if (hasActiveAbility && activeAbilityData.FaceCastDirection)
        {
            // Face ability cast direction
            rotationSpeed = movementData.QuickRotationSpeed;
            targetRotation = FPQuaternion.LookRotation(filter.AbilityInventory->ActiveAbilityInfo.CastDirection);
        }
        else
        {
            rotationSpeed = movementData.DefaultRotationSpeed;

            if (movementData.FaceAimDirection && input.AimDirection != default)
            {
                // Face aim direction
                targetRotation = FPQuaternion.LookRotation(input.AimDirection.XOY);
            }
            else if (movementDirection != default)
            {
                // Face movement direction
                targetRotation = FPQuaternion.LookRotation(movementDirection);
            }
        }

        // Smooth rotation
        filter.Transform->Rotation = FPQuaternion.Slerp(currentRotation, targetRotation, rotationSpeed * frame.DeltaTime);
    }

    private void UpdateGroundedState(Frame frame, ref Filter filter, bool wasGrounded, 
                                    PlayerMovementData movementData, bool hasActiveAbility)
    {
        if (filter.KCC->Grounded)
        {
            if (!hasActiveAbility && !filter.AbilityInventory->GetAbility(AbilityType.Jump).IsOnCooldown)
            {
                // Refresh air jump when grounded
                filter.PlayerStatus->HasAirJump = true;
                
                // Start coyote time timer
                filter.PlayerStatus->JumpCoyoteTimer.Start(movementData.JumpCoyoteTime);

                if (!wasGrounded)
                {
                    frame.Events.OnPlayerLanded(filter.EntityRef);
                }
            }
        }
        else
        {
            // Tick down coyote timer when in air
            filter.PlayerStatus->JumpCoyoteTimer.Tick(frame.DeltaTime);
        }
    }
}
```

## Dynamic Character Controller Configuration

The `PlayerMovementData` asset implements a method to change the KCC configuration based on player state:

```csharp
public unsafe void UpdateKCCSettings(Frame frame, EntityRef playerEntityRef)
{
    PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
    AbilityInventory* abilityInventory = frame.Unsafe.GetPointer<AbilityInventory>(playerEntityRef);
    CharacterController3D* kcc = frame.Unsafe.GetPointer<CharacterController3D>(playerEntityRef);

    CharacterController3DConfig config;

    if (playerStatus->IsKnockbacked || abilityInventory->HasActiveAbility)
    {
        // Use a special config for when player has no control
        config = frame.FindAsset<CharacterController3DConfig>(NoMovementKCCSettings.Id);
    }
    else if (playerStatus->IsHoldingBall)
    {
        // Use a slowed config when holding the ball
        config = frame.FindAsset<CharacterController3DConfig>(CarryingBallKCCSettings.Id);
    }
    else
    {
        // Use default movement config
        config = frame.FindAsset<CharacterController3DConfig>(DefaultKCCSettings.Id);
    }

    kcc->SetConfig(frame, config);
}
```

This allows for three distinct movement states:
1. **Default Movement**: Full speed and control
2. **Carrying Ball**: Reduced speed to encourage passing
3. **No Movement Control**: During abilities or knockback

## Player Spawn System

The PlayerSpawnSystem handles creating player entities and respawning after death:

```csharp
public unsafe class PlayerSpawnSystem : SystemMainThreadFilter<PlayerSpawnSystem.Filter>, 
    ISignalOnPlayerAdded, 
    ISignalOnPlayerRespawned, 
    ISignalOnPlayerRespawnTimerReset
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public PlayerSpawner* PlayerSpawner;
        public Transform3D* Transform;
    }
    
    private Dictionary<PlayerRef, EntityRef> _playerEntityRefs = new Dictionary<PlayerRef, EntityRef>();
    private Dictionary<PlayerRef, EntityRef> _spawnerEntityRefs = new Dictionary<PlayerRef, EntityRef>();

    public override void Update(Frame frame, ref Filter filter)
    {
        // Store player spawner reference
        _spawnerEntityRefs[filter.PlayerSpawner->PlayerRef] = filter.EntityRef;
    }

    public void OnPlayerAdded(Frame frame, PlayerRef playerRef)
    {
        if (!_spawnerEntityRefs.TryGetValue(playerRef, out var spawnerEntityRef))
        {
            return;
        }
        
        // Create player entity when player joins
        SpawnPlayer(frame, playerRef, spawnerEntityRef);
    }

    public void OnPlayerRespawned(Frame frame, EntityRef playerEntityRef, bool fullReset)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        
        if (playerStatus->SpawnerEntityRef == default)
        {
            return;
        }
        
        // Get spawner
        Transform3D* spawnerTransform = frame.Unsafe.GetPointer<Transform3D>(playerStatus->SpawnerEntityRef);
        Transform3D* playerTransform = frame.Unsafe.GetPointer<Transform3D>(playerEntityRef);
        
        // Teleport to spawn position
        playerTransform->Teleport(frame, spawnerTransform->Position);
        playerTransform->Rotation = spawnerTransform->Rotation;
        
        // Reset physics
        if (frame.Unsafe.TryGetPointer<CharacterController3D>(playerEntityRef, out var kcc))
        {
            kcc->Velocity = FPVector3.Zero;
        }
        
        // Drop ball if holding
        if (playerStatus->IsHoldingBall)
        {
            frame.Signals.OnBallDropped(playerStatus->HoldingBallEntityRef);
        }
        
        // Reset abilities
        frame.Signals.OnActiveAbilityStopped(playerEntityRef);
        frame.Signals.OnCooldownsReset(playerEntityRef);
        
        // Reset status effects
        frame.Signals.OnStatusEffectsReset(playerEntityRef);
        
        // Reset respawn timer
        playerStatus->RespawnTimer.Reset();
    }

    public void OnPlayerRespawnTimerReset(Frame frame, EntityRef playerEntityRef)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        playerStatus->RespawnTimer.Reset();
    }
    
    private void SpawnPlayer(Frame frame, PlayerRef playerRef, EntityRef spawnerEntityRef)
    {
        // Only spawn if not already spawned
        if (_playerEntityRefs.ContainsKey(playerRef))
        {
            return;
        }
        
        PlayerSpawner* spawner = frame.Unsafe.GetPointer<PlayerSpawner>(spawnerEntityRef);
        Transform3D* spawnerTransform = frame.Unsafe.GetPointer<Transform3D>(spawnerEntityRef);
        
        // Create player entity from prototype
        EntityPrototype playerPrototype = frame.FindAsset<EntityPrototype>("Player");
        EntityRef playerEntityRef = frame.Create(playerPrototype, spawnerTransform->Position, spawnerTransform->Rotation);
        
        // Initialize player status
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        playerStatus->PlayerRef = playerRef;
        playerStatus->SpawnerEntityRef = spawnerEntityRef;
        playerStatus->PlayerTeam = spawner->PlayerTeam;
        
        // Track player entity
        _playerEntityRefs[playerRef] = playerEntityRef;
        
        // Initialize air jump
        playerStatus->HasAirJump = true;
    }
}
```

## Status Effect Systems

The game implements two types of status effects: stun and knockback.

### Stun System

```csharp
public unsafe class StunStatusEffectSystem : SystemMainThreadFilter<StunStatusEffectSystem.Filter>, 
    ISignalOnStunApplied, 
    ISignalOnStatusEffectsReset
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public PlayerStatus* PlayerStatus;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Tick down stun timer if active
        if (filter.PlayerStatus->StunStatusEffect.DurationTimer.IsRunning)
        {
            filter.PlayerStatus->StunStatusEffect.DurationTimer.Tick(frame.DeltaTime);
            
            // If just ended, trigger end effects
            if (filter.PlayerStatus->StunStatusEffect.DurationTimer.IsDone)
            {
                filter.PlayerStatus->StunStatusEffect.DurationTimer.Reset();
            }
        }
    }

    public void OnStunApplied(Frame frame, EntityRef playerEntityRef, FP duration)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        
        // Only apply if not already stunned or with longer duration
        if (!playerStatus->StunStatusEffect.DurationTimer.IsRunning || 
            playerStatus->StunStatusEffect.DurationTimer.TimeLeft < duration)
        {
            playerStatus->StunStatusEffect.DurationTimer.Start(duration);
            
            // Drop ball if holding
            if (playerStatus->IsHoldingBall)
            {
                frame.Signals.OnBallDropped(playerStatus->HoldingBallEntityRef);
            }
            
            // Cancel any active ability
            frame.Signals.OnActiveAbilityStopped(playerEntityRef);
            
            // Trigger stun event
            frame.Events.OnPlayerStunned(playerEntityRef);
        }
    }

    public void OnStatusEffectsReset(Frame frame, EntityRef playerEntityRef)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        playerStatus->StunStatusEffect.DurationTimer.Reset();
    }
}
```

### Knockback System

```csharp
public unsafe class KnockbackStatusEffectSystem : SystemMainThreadFilter<KnockbackStatusEffectSystem.Filter>, 
    ISignalOnKnockbackApplied, 
    ISignalOnStatusEffectsReset
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public PlayerStatus* PlayerStatus;
        public Transform3D* Transform;
        public CharacterController3D* KCC;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        if (filter.PlayerStatus->KnockbackStatusEffect.DurationTimer.IsRunning)
        {
            // Get configuration
            KnockbackStatusEffectData knockbackData = frame.FindAsset<KnockbackStatusEffectData>(
                filter.PlayerStatus->KnockbackStatusEffect.StatusEffectData.Id);
            
            // Apply knockback movement
            ApplyKnockbackMovement(frame, ref filter, knockbackData);
            
            // Check for out of bounds
            if (filter.Transform->Position.Y < -10)  // Out of bounds check
            {
                frame.Events.OnPlayerEnteredVoid(filter.EntityRef);
                StartRespawnTimer(frame, filter.EntityRef);
            }
            
            // Tick timer
            filter.PlayerStatus->KnockbackStatusEffect.DurationTimer.Tick(frame.DeltaTime);
            
            // Reset when done
            if (filter.PlayerStatus->KnockbackStatusEffect.DurationTimer.IsDone)
            {
                filter.PlayerStatus->KnockbackStatusEffect.DurationTimer.Reset();
                
                // Reset KCC settings
                PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(
                    filter.PlayerStatus->PlayerMovementData.Id);
                playerMovementData.UpdateKCCSettings(frame, filter.EntityRef);
            }
        }
    }

    public void OnKnockbackApplied(Frame frame, EntityRef playerEntityRef, FP duration, FPVector3 direction)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        CharacterController3D* kcc = frame.Unsafe.GetPointer<CharacterController3D>(playerEntityRef);
        
        // Only apply if not already knockbacked or with longer duration
        if (!playerStatus->KnockbackStatusEffect.DurationTimer.IsRunning || 
            playerStatus->KnockbackStatusEffect.DurationTimer.TimeLeft < duration)
        {
            // Get knockback data
            KnockbackStatusEffectData knockbackData = frame.FindAsset<KnockbackStatusEffectData>(
                playerStatus->KnockbackStatusEffect.StatusEffectData.Id);
            
            // Set up knockback state
            playerStatus->KnockbackStatusEffect.DurationTimer.Start(duration);
            playerStatus->KnockbackStatusEffect.KnockbackDirection = direction.Normalized;
            
            // Calculate knockback velocity
            FPVector3 knockbackVelocity = direction.Normalized * knockbackData.KnockbackForce;
            
            // Add upward component
            knockbackVelocity.Y = knockbackData.KnockbackUpwardForce;
            
            // Store calculated velocity
            playerStatus->KnockbackStatusEffect.KnockbackVelocity = knockbackVelocity;
            
            // Update KCC settings
            PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(
                playerStatus->PlayerMovementData.Id);
            playerMovementData.UpdateKCCSettings(frame, playerEntityRef);
            
            // Drop ball if holding
            if (playerStatus->IsHoldingBall)
            {
                frame.Signals.OnBallDropped(playerStatus->HoldingBallEntityRef);
            }
            
            // Cancel any active ability
            frame.Signals.OnActiveAbilityStopped(playerEntityRef);
        }
    }

    public void OnStatusEffectsReset(Frame frame, EntityRef playerEntityRef)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        playerStatus->KnockbackStatusEffect.DurationTimer.Reset();
        
        // Update KCC settings
        PlayerMovementData playerMovementData = frame.FindAsset<PlayerMovementData>(
            playerStatus->PlayerMovementData.Id);
        playerMovementData.UpdateKCCSettings(frame, playerEntityRef);
    }
    
    private void ApplyKnockbackMovement(Frame frame, ref Filter filter, KnockbackStatusEffectData knockbackData)
    {
        // Calculate current knockback velocity with decay
        FP normalizedTime = filter.PlayerStatus->KnockbackStatusEffect.DurationTimer.NormalizedTime;
        FP velocityMultiplier = knockbackData.KnockbackCurve.Evaluate(normalizedTime);
        
        FPVector3 currentVelocity = filter.PlayerStatus->KnockbackStatusEffect.KnockbackVelocity * velocityMultiplier;
        
        // Apply gravity if in air
        if (!filter.KCC->Grounded)
        {
            currentVelocity.Y -= knockbackData.KnockbackGravity * frame.DeltaTime;
        }
        else
        {
            // Bounce on ground impact
            if (currentVelocity.Y < FP._0)
            {
                currentVelocity.Y = -currentVelocity.Y * knockbackData.GroundBounceMultiplier;
                
                // Apply additional lateral friction
                currentVelocity.X *= knockbackData.GroundFriction;
                currentVelocity.Z *= knockbackData.GroundFriction;
            }
        }
        
        // Store updated velocity
        filter.PlayerStatus->KnockbackStatusEffect.KnockbackVelocity = currentVelocity;
        
        // Apply movement
        FPVector3 movementDelta = currentVelocity * frame.DeltaTime;
        filter.KCC->AddDisplacement(movementDelta);
    }
    
    private void StartRespawnTimer(Frame frame, EntityRef playerEntityRef)
    {
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerEntityRef);
        GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);
        
        // Start respawn timer
        playerStatus->RespawnTimer.Start(gameSettingsData.RespawnDuration);
        
        // Reset status effects
        frame.Signals.OnStatusEffectsReset(playerEntityRef);
    }
}
```

## Player Input Extensions

The game extends the default Quantum input structure to support the ability system:

```csharp
public static class QuantumDemoInputTopDownExtensions
{
    public static bool GetAbilityInputWasPressed(this QuantumDemoInputTopDown input, AbilityType abilityType)
    {
        switch (abilityType)
        {
            case AbilityType.Jump:
                return input.Jump.WasPressed;
                
            case AbilityType.Dash:
                return input.Dash.WasPressed;
                
            case AbilityType.Attack:
                return input.Fire.WasPressed;
                
            case AbilityType.Block:
                return input.AltFire.WasPressed;
                
            case AbilityType.ThrowShort:
                return input.Fire.WasPressed;
                
            case AbilityType.ThrowLong:
                return input.AltFire.WasPressed;
                
            default:
                return false;
        }
    }
}
```

## Player Extension Methods

Extension methods provide convenient access to commonly used player state checks:

```csharp
public static class PlayerStatusExtensions
{
    public static bool IsHoldingBall(this PlayerStatus playerStatus)
    {
        return playerStatus.HoldingBallEntityRef != default;
    }
    
    public static bool IsStunned(this PlayerStatus playerStatus)
    {
        return playerStatus.StunStatusEffect.DurationTimer.IsRunning;
    }
    
    public static bool IsKnockbacked(this PlayerStatus playerStatus)
    {
        return playerStatus.KnockbackStatusEffect.DurationTimer.IsRunning;
    }
    
    public static bool IsRespawning(this PlayerStatus playerStatus)
    {
        return playerStatus.RespawnTimer.IsRunning;
    }
    
    public static bool IsIncapacitated(this PlayerStatus playerStatus)
    {
        return playerStatus.IsStunned() || playerStatus.IsRespawning();
    }
}
```

## Player View Layer

On the Unity side, the `PlayerViewController` handles the visual representation of players:

```csharp
public class PlayerViewController : QuantumEntityView
{
    [SerializeField] private Transform _ballFollowTransform;
    [SerializeField] private Animator _animator;
    
    // Animation parameters
    private static readonly int IsRunning = Animator.StringToHash("IsRunning");
    private static readonly int IsHoldingBall = Animator.StringToHash("IsHoldingBall");
    private static readonly int IsStunned = Animator.StringToHash("IsStunned");
    private static readonly int IsKnockbacked = Animator.StringToHash("IsKnockbacked");
    private static readonly int JumpTrigger = Animator.StringToHash("Jump");
    private static readonly int LandTrigger = Animator.StringToHash("Land");
    private static readonly int AttackTrigger = Animator.StringToHash("Attack");
    private static readonly int BlockTrigger = Animator.StringToHash("Block");
    private static readonly int ThrowTrigger = Animator.StringToHash("Throw");
    private static readonly int DashTrigger = Animator.StringToHash("Dash");
    private static readonly int StunTrigger = Animator.StringToHash("Stun");
    private static readonly int HitTrigger = Animator.StringToHash("Hit");
    
    public Transform BallFollowTransform => _ballFollowTransform;
    public PlayerRef PlayerRef { get; private set; }
    
    private LocalPlayerAccess _localPlayerAccess;
    
    protected override void ApplyTransform(ref UpdatePositionParameter param)
    {
        base.ApplyTransform(ref param);
        
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        
        if (frame.Unsafe.TryGetPointer<PlayerStatus>(EntityRef, out var playerStatus))
        {
            PlayerRef = playerStatus->PlayerRef;
            
            // Initialize local player access if this is a local player
            if (frame.IsPlayerLocal(PlayerRef) && _localPlayerAccess == null)
            {
                _localPlayerAccess = LocalPlayersManager.Instance.InitializeLocalPlayer(this);
            }
            
            // Update animator
            UpdateAnimator(frame, playerStatus);
        }
    }
    
    private void UpdateAnimator(Frame frame, PlayerStatus* playerStatus)
    {
        CharacterController3D* kcc = frame.Unsafe.GetPointer<CharacterController3D>(EntityRef);
        
        // Basic state parameters
        _animator.SetBool(IsRunning, kcc->Velocity.XZ.SqrMagnitude > FP._0_10 && kcc->Grounded);
        _animator.SetBool(IsHoldingBall, playerStatus->IsHoldingBall());
        _animator.SetBool(IsStunned, playerStatus->IsStunned());
        _animator.SetBool(IsKnockbacked, playerStatus->IsKnockbacked());
    }
    
    // Event handlers for animation triggers
    public void OnPlayerJumped()
    {
        _animator.SetTrigger(JumpTrigger);
    }
    
    public void OnPlayerLanded()
    {
        _animator.SetTrigger(LandTrigger);
    }
    
    public void OnPlayerAttacked()
    {
        _animator.SetTrigger(AttackTrigger);
    }
    
    public void OnPlayerBlocked()
    {
        _animator.SetTrigger(BlockTrigger);
    }
    
    public void OnPlayerThrewBall()
    {
        _animator.SetTrigger(ThrowTrigger);
    }
    
    public void OnPlayerDashed()
    {
        _animator.SetTrigger(DashTrigger);
    }
    
    public void OnPlayerStunned()
    {
        _animator.SetTrigger(StunTrigger);
    }
    
    public void OnPlayerHit()
    {
        _animator.SetTrigger(HitTrigger);
    }
}
```

## Player Movement Data

The configuration for player movement is defined in a scriptable object:

```csharp
[CreateAssetMenu(menuName = "Quantum/Arena Brawler/Player Movement Data")]
public class PlayerMovementData : AssetObject
{
    [Header("Character Controller")]
    public AssetRef<CharacterController3DConfig> DefaultKCCSettings;
    public AssetRef<CharacterController3DConfig> CarryingBallKCCSettings;
    public AssetRef<CharacterController3DConfig> NoMovementKCCSettings;
    
    [Header("Movement")]
    public FP NoMovementBraking = 5;
    
    [Header("Rotation")]
    public bool FaceAimDirection = true;
    public FP DefaultRotationSpeed = 8;
    public FP QuickRotationSpeed = 16;
    
    [Header("Jump")]
    public FP JumpCoyoteTime = FP._0_10;
    
    // Method for updating KCC settings shown earlier
}
```

This data-driven approach allows for tweaking player movement characteristics without changing code.

---

# 05-game-flow-management.md

# Game Flow Management

This document explains how the Arena Brawler manages game states, scoring, and match flow.

## Game State Definition

The overall game state is managed through global variables and a state enum:

```csharp
enum GameState
{
    None, Initializing, Starting, Running, GoalScored, GameOver
}

global
{
    GameState GameState;
    CountdownTimer GameStateTimer;
    CountdownTimer MainGameTimer;
    array<int>[2] TeamScore;
}
```

The game uses several events to notify clients about state changes:

```csharp
synced event OnGameInitializing { }
synced event OnGameStarting { bool IsFirst; }
synced event OnGameRunning { }
synced event OnGoalScored { entity_ref PlayerEntityRef; PlayerTeam PlayerTeam; }
synced event OnGameOver { }
synced event OnGameRestarted { }
```

## Game System

The `GameSystem` class manages the state machine for the entire game flow:

```csharp
public unsafe class GameSystem : SystemMainThread, ISignalOnGoalScored
{
    public override void Update(Frame frame)
    {
        switch (frame.Global->GameState)
        {
            case GameState.None:
                UpdateGameState_None(frame);
                break;

            case GameState.Initializing:
                UpdateGameState_Initializing(frame);
                break;

            case GameState.Starting:
                UpdateGameState_Starting(frame);
                break;

            case GameState.Running:
                UpdateGameState_Running(frame);
                break;

            case GameState.GoalScored:
                UpdateGameState_GoalScored(frame);
                break;

            case GameState.GameOver:
                UpdateGameState_GameOver(frame);
                break;
        }
    }
    
    // State update methods...
}
```

## Game State Life Cycle

### 1. Initialization State

When the game first starts, it enters the Initialization state:

```csharp
private void UpdateGameState_None(Frame frame)
{
    ChangeGameState_Initializing(frame);
}

private void ChangeGameState_Initializing(Frame frame)
{
    GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);

    frame.Global->GameStateTimer.Start(gameSettingsData.InitializationDuration);
    frame.Global->GameState = GameState.Initializing;

    frame.Events.OnGameInitializing();
}

private void UpdateGameState_Initializing(Frame frame)
{
    frame.Global->GameStateTimer.Tick(frame.DeltaTime);
    if (frame.Global->GameStateTimer.IsDone)
    {
        ChangeGameState_Starting(frame, true);
    }
}
```

### 2. Starting State

After initialization, the game transitions to the Starting state with a countdown:

```csharp
private void ChangeGameState_Starting(Frame frame, bool isFirst)
{
    GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);

    frame.Global->GameStateTimer.Start(gameSettingsData.GameStartDuration);
    frame.Global->GameState = GameState.Starting;

    frame.Events.OnGameStarting(isFirst);
}

private void UpdateGameState_Starting(Frame frame)
{
    frame.Global->GameStateTimer.Tick(frame.DeltaTime);
    if (frame.Global->GameStateTimer.IsDone)
    {
        // Lower the team base walls
        ToggleTeamBaseStaticColliders(frame, false);
        
        // Spawn the ball
        frame.Signals.OnBallSpawned();

        // Start the match
        ChangeGameState_Running(frame);
    }
}
```

### 3. Running State

During the Running state, the game timer counts down and the main gameplay happens:

```csharp
private void ChangeGameState_Running(Frame frame)
{
    GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);

    if (frame.Global->MainGameTimer.IsDone)
    {
        frame.Global->MainGameTimer.Start(gameSettingsData.GameDuration);
    }

    frame.Global->GameState = GameState.Running;

    frame.Events.OnGameRunning();
}

private void UpdateGameState_Running(Frame frame)
{
    frame.Global->MainGameTimer.Tick(frame.DeltaTime);
    if (frame.Global->MainGameTimer.IsDone)
    {
        ChangeGameState_GameOver(frame);
    }
}
```

### 4. Goal Scored State

When a player scores a goal, the game transitions to the Goal Scored state:

```csharp
public void OnGoalScored(Frame frame, EntityRef playerEntityRef, PlayerTeam playerTeam)
{
    // Remove the ball
    DespawnBalls(frame);

    // Increment team score
    frame.Global->TeamScore[(int)playerTeam]++;

    // Change state
    ChangeGameState_GoalScored(frame, playerEntityRef, playerTeam);
}

private void ChangeGameState_GoalScored(Frame frame, EntityRef playerEntityRef, PlayerTeam playerTeam)
{
    GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);

    frame.Global->GameStateTimer.Start(gameSettingsData.GoalDuration);
    frame.Global->GameState = GameState.GoalScored;

    frame.Events.OnGoalScored(playerEntityRef, playerTeam);
}

private void UpdateGameState_GoalScored(Frame frame)
{
    frame.Global->GameStateTimer.Tick(frame.DeltaTime);
    if (frame.Global->GameStateTimer.IsDone)
    {
        // Reset players to starting positions
        RespawnPlayers(frame);
        
        // Raise team base walls
        ToggleTeamBaseStaticColliders(frame, true);

        // Reset for next point
        ChangeGameState_Starting(frame, false);
    }
}
```

### 5. Game Over State

When the game timer expires, the game transitions to the Game Over state:

```csharp
private void ChangeGameState_GameOver(Frame frame)
{
    GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);

    frame.Global->GameStateTimer.Start(gameSettingsData.GameOverDuration);
    frame.Global->GameState = GameState.GameOver;

    frame.Events.OnGameOver();
}

private void UpdateGameState_GameOver(Frame frame)
{
    frame.Global->GameStateTimer.Tick(frame.DeltaTime);
    if (frame.Global->GameStateTimer.IsDone)
    {
        // Clean up
        DespawnBalls(frame);
        RespawnPlayers(frame);
        ToggleTeamBaseStaticColliders(frame, true);

        // Reset scores
        frame.Global->TeamScore[0] = 0;
        frame.Global->TeamScore[1] = 0;

        frame.Events.OnGameRestarted();

        // Start a new game
        ChangeGameState_Starting(frame, true);
    }
}
```

## Helper Methods

The `GameSystem` includes several helper methods for common operations:

```csharp
private void DespawnBalls(Frame frame)
{
    foreach (var (ballEntityRef, _) in frame.Unsafe.GetComponentBlockIterator<BallStatus>())
    {
        frame.Signals.OnBallDespawned(ballEntityRef);
    }
}

private void RespawnPlayers(Frame frame)
{
    foreach (var (playerEntityRef, _) in frame.Unsafe.GetComponentBlockIterator<PlayerStatus>())
    {
        frame.Signals.OnPlayerRespawned(playerEntityRef, true);
    }
}

private void ToggleTeamBaseStaticColliders(Frame frame, bool enabled)
{
    var filtered = frame.Filter<TeamBaseWallStaticColliderTag, StaticColliderLink>();
    while (filtered.Next(out _, out _, out var wallColliderLink))
    {
        frame.Physics3D.SetStaticColliderEnabled(wallColliderLink.StaticColliderIndex, enabled);
    }
}
```

## Goal Detection

The game uses a separate `GoalSystem` to detect when a ball enters a goal:

```csharp
public unsafe class GoalSystem : SystemMainThreadFilter<GoalSystem.Filter>
{
    public struct Filter
    {
        public EntityRef EntityRef;
        public GoalAreaCollider* GoalAreaCollider;
        public Transform3D* Transform;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Early out if not in running state
        if (frame.Global->GameState != GameState.Running)
        {
            return;
        }

        // Create goal detection shape
        Shape3D goalShape = Shape3D.CreateBox(filter.GoalAreaCollider->GoalAreaSize);
        
        // Get game settings
        GameSettingsData gameSettingsData = frame.FindAsset<GameSettingsData>(frame.RuntimeConfig.GameSettingsData.Id);
        
        // Check for ball overlaps
        HitCollection3D hitCollection = frame.Physics3D.OverlapShape(
            filter.Transform->Position, 
            filter.Transform->Rotation, 
            goalShape, 
            gameSettingsData.BallLayerMask);

        // Process hits
        for (int i = 0; i < hitCollection.Count; i++)
        {
            EntityRef ballEntityRef = hitCollection[i].Entity;
            
            // Get the last player to touch the ball
            EntityRef scoringPlayerEntityRef = GetLastTouchingPlayer(frame, ballEntityRef);
            
            if (scoringPlayerEntityRef != default)
            {
                PlayerStatus* scorerStatus = frame.Unsafe.GetPointer<PlayerStatus>(scoringPlayerEntityRef);
                PlayerTeam scoringTeam = scorerStatus->PlayerTeam;
                
                // Check if this is the opposing team's goal
                if (scoringTeam != filter.GoalAreaCollider->TeamOwner)
                {
                    // Score a goal for the scoring team
                    frame.Signals.OnGoalScored(scoringPlayerEntityRef, scoringTeam);
                    break;
                }
            }
        }
    }
    
    private EntityRef GetLastTouchingPlayer(Frame frame, EntityRef ballEntityRef)
    {
        BallStatus* ballStatus = frame.Unsafe.GetPointer<BallStatus>(ballEntityRef);
        
        // If ball is currently held, use that player
        if (ballStatus->IsHeldByPlayer)
        {
            return ballStatus->HoldingPlayerEntityRef;
        }
        
        // If ball has a catch timeout, use that player
        if (ballStatus->CatchTimeoutTimer.IsRunning)
        {
            // Find the actual entity for this player
            var filtered = frame.Filter<PlayerStatus>();
            while (filtered.Next(out var playerEntityRef, out var playerStatus))
            {
                if (playerStatus->PlayerRef == ballStatus->CatchTimeoutPlayerRef)
                {
                    return playerEntityRef;
                }
            }
        }
        
        // No last touching player found
        return default;
    }
}
```

## Goal Area Collider

Goal areas are defined with a `GoalAreaCollider` component:

```csharp
component GoalAreaCollider
{
    FPVector3 GoalAreaSize;
    PlayerTeam TeamOwner;
}
```

And configured via a data asset:

```csharp
[CreateAssetMenu(menuName = "Quantum/Arena Brawler/Goal Area Collider Data")]
public class GoalAreaColliderData : AssetObject
{
    public FPVector3 GoalAreaSize = new FPVector3(3, 2, 1);
    public PlayerTeam TeamOwner;
}
```

## Game Settings Configuration

All timing and duration parameters are defined in the `GameSettingsData` asset:

```csharp
[CreateAssetMenu(menuName = "Quantum/Arena Brawler/Game Settings Data")]
public class GameSettingsData : AssetObject
{
    [Header("Game State Durations")]
    public FP InitializationDuration = 1;
    public FP GameStartDuration = 3;
    public FP GameDuration = 180;     // 3 minutes
    public FP GoalDuration = 5;
    public FP GameOverDuration = 10;
    
    [Header("Player Settings")]
    public FP RespawnDuration = 3;
    
    [Header("Physics Layers")]
    public PhysicsLayers PlayerLayerMask;
    public PhysicsLayers BallLayerMask;
    public PhysicsLayers ArenaLayerMask;
}
```

## Unity-Side Event Handling

On the Unity side, the game state events are handled to update UI and visual elements:

```csharp
public class GameStateManager : MonoBehaviour, IQuantumEventListener
{
    [SerializeField] private GameObject _initializingUI;
    [SerializeField] private GameObject _startingUI;
    [SerializeField] private GameObject _runningUI;
    [SerializeField] private GameObject _goalScoredUI;
    [SerializeField] private GameObject _gameOverUI;
    
    [SerializeField] private Text _countdownText;
    [SerializeField] private Text _gameTimerText;
    [SerializeField] private Text _blueTeamScoreText;
    [SerializeField] private Text _redTeamScoreText;
    
    public void OnInit(QuantumGame game)
    {
        // Register for Quantum events
        game.EventDispatcher.Subscribe(this);
    }
    
    public void OnDestroy()
    {
        if (QuantumRunner.Default?.Game != null)
        {
            QuantumRunner.Default.Game.EventDispatcher.Unsubscribe(this);
        }
    }
    
    public void Update()
    {
        if (QuantumRunner.Default?.Game?.Frames?.Predicted == null)
        {
            return;
        }
        
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        
        // Update timer display based on current state
        switch (frame.Global->GameState)
        {
            case GameState.Starting:
                _countdownText.text = Mathf.CeilToInt((float)frame.Global->GameStateTimer.TimeLeft).ToString();
                break;
                
            case GameState.Running:
                UpdateGameTimer(frame);
                UpdateScores(frame);
                break;
        }
    }
    
    private void UpdateGameTimer(Frame frame)
    {
        int minutes = Mathf.FloorToInt((float)frame.Global->MainGameTimer.TimeLeft / 60f);
        int seconds = Mathf.FloorToInt((float)frame.Global->MainGameTimer.TimeLeft) % 60;
        
        _gameTimerText.text = $"{minutes:00}:{seconds:00}";
    }
    
    private void UpdateScores(Frame frame)
    {
        _blueTeamScoreText.text = frame.Global->TeamScore[0].ToString();
        _redTeamScoreText.text = frame.Global->TeamScore[1].ToString();
    }
    
    // Event handlers for game state changes
    public void OnEvent(OnGameInitializing e)
    {
        ShowStateUI(GameState.Initializing);
    }
    
    public void OnEvent(OnGameStarting e)
    {
        ShowStateUI(GameState.Starting);
        
        if (e.IsFirst)
        {
            // Play game start animation/sound
            AudioManager.Instance.PlaySound("GameStart");
        }
    }
    
    public void OnEvent(OnGameRunning e)
    {
        ShowStateUI(GameState.Running);
        
        // Play match start sound
        AudioManager.Instance.PlaySound("MatchStart");
    }
    
    public void OnEvent(OnGoalScored e)
    {
        ShowStateUI(GameState.GoalScored);
        
        // Show goal scoring animation
        GoalEffectsManager.Instance.PlayGoalEffect(e.PlayerTeam);
        
        // Play goal sound
        AudioManager.Instance.PlaySound("GoalScored");
    }
    
    public void OnEvent(OnGameOver e)
    {
        ShowStateUI(GameState.GameOver);
        
        // Determine winner and show appropriate UI
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        int blueScore = frame.Global->TeamScore[0];
        int redScore = frame.Global->TeamScore[1];
        
        if (blueScore > redScore)
        {
            GameOverUIManager.Instance.ShowWinner(PlayerTeam.Blue);
        }
        else if (redScore > blueScore)
        {
            GameOverUIManager.Instance.ShowWinner(PlayerTeam.Red);
        }
        else
        {
            GameOverUIManager.Instance.ShowDraw();
        }
        
        // Play game over sound
        AudioManager.Instance.PlaySound("GameOver");
    }
    
    private void ShowStateUI(GameState state)
    {
        _initializingUI.SetActive(state == GameState.Initializing);
        _startingUI.SetActive(state == GameState.Starting);
        _runningUI.SetActive(state == GameState.Running);
        _goalScoredUI.SetActive(state == GameState.GoalScored);
        _gameOverUI.SetActive(state == GameState.GameOver);
    }
}
```

## Static Collider Management

Team base walls are managed via static colliders that are toggled on/off during different game states:

```csharp
public class StaticColliderLinkBaker : MonoBehaviour
{
    [SerializeField] private bool _isTeamBaseWall;
    [SerializeField] private PlayerTeam _teamOwner;
    
    private int _staticColliderIndex = -1;
    
    // Called by the Quantum Map3D baking process
    public void OnBakeStaticCollider(int staticColliderIndex)
    {
        _staticColliderIndex = staticColliderIndex;
    }
    
    // Called by the Quantum EntityPrototypeBuilder during entity creation
    public void OnEntityCreated(EntityRef entityRef)
    {
        if (_staticColliderIndex < 0)
        {
            return;
        }
        
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        
        // Add static collider link component
        frame.Add<StaticColliderLink>(entityRef);
        frame.Unsafe.GetPointer<StaticColliderLink>(entityRef)->StaticColliderIndex = _staticColliderIndex;
        
        // Add team base wall tag if needed
        if (_isTeamBaseWall)
        {
            frame.Add<TeamBaseWallStaticColliderTag>(entityRef);
        }
    }
}
```

This system allows the walls around team bases to be raised during the Starting state (preventing players from moving) and lowered during the Running state (allowing free movement).

---

# 06-local-multiplayer.md

# Local Multiplayer

This document explains how the Quantum Arena Brawler implements local multiplayer with split-screen support.

## Local Players Support Overview

The Arena Brawler supports up to 4 local players on a single device. Key features include:

1. Dynamic UI and camera layout based on local player count
2. Automatic input device assignment
3. SQL lobby filtering to account for local players
4. Efficient player configuration management

## Local Player Count Management

The game tracks local player count through a custom lobby property:

```csharp
public class LocalPlayerCountManager : MonoBehaviour
{
    public const string LOCAL_PLAYERS_PROP_KEY = "LP";
    public const string TOTAL_PLAYERS_PROP_KEY = "C0";

    public static readonly TypedLobby SQL_LOBBY = new TypedLobby("customSqlLobby", LobbyType.SqlLobby);
    
    [SerializeField] private Dropdown _localPlayersCountSelector;
    private QuantumRunner _connection;
    
    public void SetConnection(QuantumRunner connection)
    {
        _connection = connection;
        
        // Set initial property
        if (_connection != null && _connection.Client.InRoom)
        {
            UpdateLocalPlayersCount();
        }
    }
    
    public void OnLocalPlayersCountChanged()
    {
        if (_connection != null && _connection.Client.InRoom)
        {
            UpdateLocalPlayersCount();
        }
    }
    
    private void UpdateLocalPlayersCount()
    {
        int localPlayersCount = _localPlayersCountSelector.GetLastSelectedLocalPlayersCount();
        
        _connection.Client.LocalPlayer.SetCustomProperties(new PhotonHashtable
        {
            { LOCAL_PLAYERS_PROP_KEY, localPlayersCount }
        });
        
        UpdateRoomTotalPlayers();
    }
    
    private void UpdateRoomTotalPlayers()
    {
        if (_connection != null && _connection.Client.InRoom && _connection.Client.LocalPlayer.IsMasterClient)
        {
            int totalPlayers = 0;
            foreach (var player in _connection.Client.CurrentRoom.Players.Values)
            {
                if (player.CustomProperties.TryGetValue(LOCAL_PLAYERS_PROP_KEY, out var localPlayersCount))
                {
                    totalPlayers += (int)localPlayersCount;
                }
            }

            _connection.Client.CurrentRoom.SetCustomProperties(new PhotonHashtable
            {
                { TOTAL_PLAYERS_PROP_KEY, totalPlayers }
            });
        }
    }
}
```

## Matchmaking With Local Players

The game uses SQL filtering to limit the total number of players in a room, accounting for local players:

```csharp
protected override void OnConnect(QuantumMenuConnectArgs connectArgs, ref MatchmakingArguments args)
{
    args.RandomMatchingType = MatchmakingMode.FillRoom;
    args.Lobby = LocalPlayerCountManager.SQL_LOBBY;
    args.CustomLobbyProperties = new string[] { LocalPlayerCountManager.TOTAL_PLAYERS_PROP_KEY };
    
    int localPlayersCount = _localPlayersCountSelector.GetLastSelectedLocalPlayersCount();
    int maxPlayerCount = Input.MAX_COUNT; // 6 players maximum
    
    // Ensure we don't join rooms that would exceed the player limit
    args.SqlLobbyFilter = $"{LocalPlayerCountManager.TOTAL_PLAYERS_PROP_KEY} <= {maxPlayerCount - localPlayersCount}";
}
```

## Local Players Configuration

When the gameplay starts, a configuration prefab is instantiated based on the number of local players:

```csharp
public class LocalPlayersManager : MonoBehaviour
{
    public static LocalPlayersManager Instance { get; private set; }

    [SerializeField] private LocalPlayersConfig[] _localPlayersConfigPrefabs;
    [SerializeField] private Camera _temporaryCamera;

    private Dictionary<int, LocalPlayerAccess> _localPlayerAccessByPlayerIndices = new Dictionary<int, LocalPlayerAccess>();

    public Dictionary<int, LocalPlayerAccess>.ValueCollection LocalPlayerAccessCollection
    {
        get
        {
            if (_localPlayerAccessByPlayerIndices.Count == 0)
            {
                Initialize();
            }

            return _localPlayerAccessByPlayerIndices.Values;
        }
    }

    private void Awake()
    {
        Instance = this;
    }

    public LocalPlayerAccess InitializeLocalPlayer(PlayerViewController playerViewController)
    {
        LocalPlayerAccess localPlayerAccess = GetLocalPlayerAccess(playerViewController.PlayerRef);
        localPlayerAccess.InitializeLocalPlayer(playerViewController);

        return localPlayerAccess;
    }

    public LocalPlayerAccess GetLocalPlayerAccess(int playerIndex)
    {
        if (_localPlayerAccessByPlayerIndices.Count == 0)
        {
            Initialize();
        }

        _localPlayerAccessByPlayerIndices.TryGetValue(playerIndex, out LocalPlayerAccess localPlayerAccess);
        return localPlayerAccess;
    }

    private void Initialize()
    {
        var localPlayerIndices = QuantumRunner.Default.Game.GetLocalPlayers();
        if(localPlayerIndices.Count == 0) return;
        
        // Select the appropriate config prefab based on local player count
        LocalPlayersConfig localPlayersConfig = Instantiate(_localPlayersConfigPrefabs[localPlayerIndices.Count - 1], transform);
        
        for (int i = 0; i < localPlayerIndices.Count; i++)
        {
            LocalPlayerAccess localPlayerAccess = localPlayersConfig.GetLocalPlayerAccess(i);
            localPlayerAccess.IsMainLocalPlayer = i == 0;

            _localPlayerAccessByPlayerIndices.Add(localPlayerIndices[i], localPlayerAccess);
        }

        // Remove the temporary camera once players are set up
        Destroy(_temporaryCamera.gameObject);
    }
}
```

## Local Players Config

Each local player count has a specific configuration prefab:

```csharp
public class LocalPlayersConfig : MonoBehaviour
{
    [SerializeField] private LocalPlayerAccess[] _localPlayerAccesses;

    public LocalPlayerAccess GetLocalPlayerAccess(int localIndex)
    {
        if (localIndex < 0 || localIndex >= _localPlayerAccesses.Length)
        {
            Debug.LogError($"Invalid local player index: {localIndex}");
            return null;
        }

        return _localPlayerAccesses[localIndex];
    }
}
```

## Local Player Access

Each local player has a dedicated access component providing camera, UI, and input:

```csharp
public class LocalPlayerAccess : MonoBehaviour
{
    [SerializeField] private int _localIndex;
    [SerializeField] private Camera _camera;
    [SerializeField] private Canvas _uiCanvas;
    [SerializeField] private PlayerInput _playerInput;
    [SerializeField] private LocalPlayerUI _playerUI;
    
    public bool IsMainLocalPlayer { get; set; }
    
    private PlayerViewController _playerViewController;
    
    public void InitializeLocalPlayer(PlayerViewController playerViewController)
    {
        _playerViewController = playerViewController;
        
        // Set up Cinemachine targets to follow this player
        CinemachineTargetGroup targetGroup = GetComponentInChildren<CinemachineTargetGroup>();
        if (targetGroup != null)
        {
            // Add player to target group with high weight
            targetGroup.AddMember(playerViewController.transform, 1.0f, 2.0f);
            
            // Find ball and add with lower weight but larger radius
            BallEntityView ballView = FindObjectOfType<BallEntityView>();
            if (ballView != null)
            {
                targetGroup.AddMember(ballView.transform, 0.5f, 4.0f);
            }
            
            // Find all other players and add with low weight
            PlayerViewController[] allPlayers = FindObjectsOfType<PlayerViewController>();
            foreach (var player in allPlayers)
            {
                if (player != playerViewController)
                {
                    targetGroup.AddMember(player.transform, 0.25f, 2.0f);
                }
            }
        }
        
        // Initialize UI
        _playerUI.Initialize(playerViewController);
    }
    
    public Camera Camera => _camera;
    public Canvas UICanvas => _uiCanvas;
    public PlayerInput PlayerInput => _playerInput;
}
```

## Local Player UI

Each local player has their own UI elements:

```csharp
public class LocalPlayerUI : MonoBehaviour
{
    [SerializeField] private Image _playerIndicator;
    [SerializeField] private AbilityCooldownsUI _abilityCooldowns;
    [SerializeField] private Image _stunIndicator;
    [SerializeField] private RectTransform _scorePanel;
    
    private PlayerViewController _playerViewController;
    
    public void Initialize(PlayerViewController playerViewController)
    {
        _playerViewController = playerViewController;
        
        // Set player indicator color based on team
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(playerViewController.EntityRef);
        
        _playerIndicator.color = playerStatus->PlayerTeam == PlayerTeam.Blue ? 
            new Color(0.2f, 0.4f, 1.0f) : new Color(1.0f, 0.3f, 0.3f);
            
        // Initialize ability cooldowns UI
        _abilityCooldowns.Initialize(playerViewController.EntityRef);
    }
    
    public void Update()
    {
        if (_playerViewController == null)
        {
            return;
        }
        
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        PlayerStatus* playerStatus = frame.Unsafe.GetPointer<PlayerStatus>(_playerViewController.EntityRef);
        
        // Update stun indicator
        _stunIndicator.gameObject.SetActive(playerStatus->IsStunned());
    }
}
```

## Input Device Management

The Unity Input System package is used to automatically assign input devices to local players:

```csharp
public class InputDeviceManager : MonoBehaviour
{
    [SerializeField] private PlayerInputManager _playerInputManager;
    
    private void Start()
    {
        // Set up input device joining
        PlayerInputManager.instance.joinBehavior = PlayerJoinBehavior.JoinPlayersManually;
        
        // Get required local player count
        int localPlayerCount = QuantumRunner.Default.Game.GetLocalPlayers().Count;
        
        // Join first player with keyboard+mouse
        PlayerInput mainPlayerInput = PlayerInputManager.instance.JoinPlayer(controlScheme: "KeyboardMouse");
        
        // Join additional players with gamepads
        for (int i = 1; i < localPlayerCount; i++)
        {
            PlayerInput additionalInput = PlayerInputManager.instance.JoinPlayer(controlScheme: "Gamepad");
        }
    }
}
```

## Viewport Management

For split-screen play, the camera viewports are automatically adjusted:

```csharp
public class SplitScreenManager : MonoBehaviour
{
    [SerializeField] private GameObject _singleViewportLayout;
    [SerializeField] private GameObject _dualViewportLayout;
    [SerializeField] private GameObject _tripleViewportLayout;
    [SerializeField] private GameObject _quadViewportLayout;
    
    private void Start()
    {
        // Determine viewport layout based on local player count
        int localPlayerCount = QuantumRunner.Default.Game.GetLocalPlayers().Count;
        
        _singleViewportLayout.SetActive(localPlayerCount == 1);
        _dualViewportLayout.SetActive(localPlayerCount == 2);
        _tripleViewportLayout.SetActive(localPlayerCount == 3);
        _quadViewportLayout.SetActive(localPlayerCount == 4);
        
        // Assign cameras to viewports
        var localPlayers = LocalPlayersManager.Instance.LocalPlayerAccessCollection;
        
        if (localPlayerCount == 1)
        {
            // Full screen for one player
            SetupSinglePlayer(localPlayers);
        }
        else if (localPlayerCount == 2)
        {
            // Split screen for two players (horizontal)
            SetupTwoPlayers(localPlayers);
        }
        else if (localPlayerCount == 3)
        {
            // Custom layout for three players
            SetupThreePlayers(localPlayers);
        }
        else if (localPlayerCount == 4)
        {
            // Grid layout for four players
            SetupFourPlayers(localPlayers);
        }
    }
    
    private void SetupSinglePlayer(IEnumerable<LocalPlayerAccess> localPlayers)
    {
        foreach (var playerAccess in localPlayers)
        {
            // Full screen viewport
            playerAccess.Camera.rect = new Rect(0, 0, 1, 1);
        }
    }
    
    private void SetupTwoPlayers(IEnumerable<LocalPlayerAccess> localPlayers)
    {
        int index = 0;
        foreach (var playerAccess in localPlayers)
        {
            if (index == 0)
            {
                // Top half of screen
                playerAccess.Camera.rect = new Rect(0, 0.5f, 1, 0.5f);
            }
            else
            {
                // Bottom half of screen
                playerAccess.Camera.rect = new Rect(0, 0, 1, 0.5f);
            }
            index++;
        }
    }
    
    private void SetupThreePlayers(IEnumerable<LocalPlayerAccess> localPlayers)
    {
        int index = 0;
        foreach (var playerAccess in localPlayers)
        {
            if (index == 0)
            {
                // Top left
                playerAccess.Camera.rect = new Rect(0, 0.5f, 0.5f, 0.5f);
            }
            else if (index == 1)
            {
                // Top right
                playerAccess.Camera.rect = new Rect(0.5f, 0.5f, 0.5f, 0.5f);
            }
            else
            {
                // Bottom (full width)
                playerAccess.Camera.rect = new Rect(0, 0, 1, 0.5f);
            }
            index++;
        }
    }
    
    private void SetupFourPlayers(IEnumerable<LocalPlayerAccess> localPlayers)
    {
        int index = 0;
        foreach (var playerAccess in localPlayers)
        {
            if (index == 0)
            {
                // Top left
                playerAccess.Camera.rect = new Rect(0, 0.5f, 0.5f, 0.5f);
            }
            else if (index == 1)
            {
                // Top right
                playerAccess.Camera.rect = new Rect(0.5f, 0.5f, 0.5f, 0.5f);
            }
            else if (index == 2)
            {
                // Bottom left
                playerAccess.Camera.rect = new Rect(0, 0, 0.5f, 0.5f);
            }
            else
            {
                // Bottom right
                playerAccess.Camera.rect = new Rect(0.5f, 0, 0.5f, 0.5f);
            }
            index++;
        }
    }
}
```

## Input Action Mapping

Each local player has their own input action asset to handle controls:

```csharp
// Example of the player input asset configuration
{
    "name": "PlayerControls",
    "maps": [
        {
            "name": "Gameplay",
            "id": "33b2bbd9-a108-4a8e-a00d-a6aa6c9a82c4",
            "actions": [
                {
                    "name": "Move",
                    "type": "Value",
                    "id": "26d64aad-8a1c-4b94-afe9-c0a88f1fb9b0",
                    "expectedControlType": "Vector2",
                    "processors": "",
                    "interactions": ""
                },
                {
                    "name": "Aim",
                    "type": "Value",
                    "id": "fe10e3c5-2b17-4d2f-a62a-7fa2a1e47a98",
                    "expectedControlType": "Vector2",
                    "processors": "",
                    "interactions": ""
                },
                {
                    "name": "Jump",
                    "type": "Button",
                    "id": "54b0e3f3-2f9a-4c9a-ac2d-94307a0f0098",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": ""
                },
                {
                    "name": "Dash",
                    "type": "Button",
                    "id": "d70aec3e-1e41-4dda-8b85-9a8ef7b43ab3",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": ""
                },
                {
                    "name": "Fire",
                    "type": "Button",
                    "id": "9d7bb5e2-5227-4e2a-b1c1-11de61ea2d9f",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": ""
                },
                {
                    "name": "AltFire",
                    "type": "Button",
                    "id": "0aa1e8cf-6a7c-4b96-87a9-e85af973e3a0",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": ""
                }
            ],
            "bindings": [
                // Input bindings for keyboard/mouse
                {
                    "name": "WASD",
                    "id": "ad85ff4c-1927-4e81-8872-a54e1d9c8024",
                    "path": "2DVector",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Move",
                    "isComposite": true,
                    "isPartOfComposite": false
                },
                {
                    "name": "up",
                    "id": "e6d73d72-ee3c-40e0-8e91-b89c11f1a15a",
                    "path": "<Keyboard>/w",
                    "interactions": "",
                    "processors": "",
                    "groups": "KeyboardMouse",
                    "action": "Move",
                    "isComposite": false,
                    "isPartOfComposite": true
                },
                // Additional keyboard bindings...
                
                // Input bindings for gamepad
                {
                    "name": "Left Stick",
                    "id": "e55e7a9a-9b5e-4af6-82e7-98f7d0b3bc81",
                    "path": "2DVector(mode=2)",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Move",
                    "isComposite": true,
                    "isPartOfComposite": false
                },
                {
                    "name": "up",
                    "id": "6a12da3e-d9e3-4c41-8f39-fbf8f4e9a7ce",
                    "path": "<Gamepad>/leftStick/up",
                    "interactions": "",
                    "processors": "",
                    "groups": "Gamepad",
                    "action": "Move",
                    "isComposite": false,
                    "isPartOfComposite": true
                },
                // Additional gamepad bindings...
            ]
        }
    ],
    "controlSchemes": [
        {
            "name": "KeyboardMouse",
            "bindingGroup": "KeyboardMouse",
            "devices": [
                {
                    "devicePath": "<Keyboard>",
                    "isOptional": false,
                    "isOR": false
                },
                {
                    "devicePath": "<Mouse>",
                    "isOptional": false,
                    "isOR": false
                }
            ]
        },
        {
            "name": "Gamepad",
            "bindingGroup": "Gamepad",
            "devices": [
                {
                    "devicePath": "<Gamepad>",
                    "isOptional": false,
                    "isOR": false
                }
            ]
        }
    ]
}
```

## Local Input Provider

The game bridges Unity's Input System to Quantum's input structure:

```csharp
public class LocalInputProvider : MonoBehaviour
{
    [SerializeField] private PlayerInput _playerInput;
    private InputActionMap _gameplayActions;
    
    private Vector2 _moveDirection;
    private Vector2 _aimDirection;
    private bool _jumpPressed;
    private bool _dashPressed;
    private bool _firePressed;
    private bool _altFirePressed;
    
    private void Awake()
    {
        _gameplayActions = _playerInput.actions.FindActionMap("Gameplay");
        
        // Set up input callbacks
        _gameplayActions["Move"].performed += ctx => _moveDirection = ctx.ReadValue<Vector2>();
        _gameplayActions["Move"].canceled += ctx => _moveDirection = Vector2.zero;
        
        _gameplayActions["Aim"].performed += ctx => _aimDirection = ctx.ReadValue<Vector2>();
        _gameplayActions["Aim"].canceled += ctx => _aimDirection = Vector2.zero;
        
        _gameplayActions["Jump"].performed += ctx => _jumpPressed = true;
        _gameplayActions["Jump"].canceled += ctx => _jumpPressed = false;
        
        _gameplayActions["Dash"].performed += ctx => _dashPressed = true;
        _gameplayActions["Dash"].canceled += ctx => _dashPressed = false;
        
        _gameplayActions["Fire"].performed += ctx => _firePressed = true;
        _gameplayActions["Fire"].canceled += ctx => _firePressed = false;
        
        _gameplayActions["AltFire"].performed += ctx => _altFirePressed = true;
        _gameplayActions["AltFire"].canceled += ctx => _altFirePressed = false;
    }
    
    private void OnEnable()
    {
        _gameplayActions.Enable();
    }
    
    private void OnDisable()
    {
        _gameplayActions.Disable();
    }
    
    // Called by Quantum to get the current input state
    public void OnInput(QuantumGame game, QuantumDemoInputTopDown* data)
    {
        // Convert from Unity input to Quantum input
        data->MoveDirection = new FPVector2(_moveDirection.x, _moveDirection.y);
        data->AimDirection = new FPVector2(_aimDirection.x, _aimDirection.y);
        
        // Handle aim direction on keyboard/mouse
        if (_playerInput.currentControlScheme == "KeyboardMouse")
        {
            // Use mouse position for aiming
            Vector3 mousePos = Input.mousePosition;
            Vector3 worldPos = _playerInput.GetComponent<LocalPlayerAccess>().Camera.ScreenToWorldPoint(new Vector3(mousePos.x, mousePos.y, 10f));
            
            Vector3 playerPos = transform.position;
            Vector3 aimDir = (worldPos - playerPos).normalized;
            
            data->AimDirection = new FPVector2(aimDir.x, aimDir.z);
        }
        
        // Set button states
        SetButton(game, ref data->Jump, _jumpPressed);
        SetButton(game, ref data->Dash, _dashPressed);
        SetButton(game, ref data->Fire, _firePressed);
        SetButton(game, ref data->AltFire, _altFirePressed);
    }
    
    private void SetButton(QuantumGame game, ref Photon.Deterministic.BitSet button, bool pressed)
    {
        if (pressed)
        {
            button.Push(game.Frames.Predicted);
        }
        else
        {
            button.Clear(game.Frames.Predicted);
        }
    }
}
```

## Input Registration

The game registers input providers for each local player:

```csharp
public class LocalInputRegistration : MonoBehaviour
{
    private void Start()
    {
        if (QuantumRunner.Default == null)
        {
            return;
        }
        
        // Get local player indices
        var localPlayerIndices = QuantumRunner.Default.Game.GetLocalPlayers();
        
        // Get input providers
        LocalInputProvider[] inputProviders = FindObjectsOfType<LocalInputProvider>();
        
        // Register each input provider
        for (int i = 0; i < Mathf.Min(localPlayerIndices.Count, inputProviders.Length); i++)
        {
            int playerIndex = localPlayerIndices[i];
            LocalInputProvider inputProvider = inputProviders[i];
            
            // Register with Quantum
            QuantumRunner.Default.Game.SetInput(playerIndex, inputProvider.OnInput);
        }
    }
}
```

## Shared UI Elements

While each player has their own UI, some elements are shared across all local players:

```csharp
public class SharedUIManager : MonoBehaviour
{
    [SerializeField] private GameObject _pauseMenu;
    [SerializeField] private Text _gameTimerText;
    [SerializeField] private Text _blueTeamScoreText;
    [SerializeField] private Text _redTeamScoreText;
    
    private void Update()
    {
        if (QuantumRunner.Default?.Game?.Frames?.Predicted == null)
        {
            return;
        }
        
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        
        // Update shared score display
        _blueTeamScoreText.text = frame.Global->TeamScore[0].ToString();
        _redTeamScoreText.text = frame.Global->TeamScore[1].ToString();
        
        // Update shared timer
        if (frame.Global->GameState == GameState.Running)
        {
            int minutes = Mathf.FloorToInt((float)frame.Global->MainGameTimer.TimeLeft / 60f);
            int seconds = Mathf.FloorToInt((float)frame.Global->MainGameTimer.TimeLeft) % 60;
            
            _gameTimerText.text = $"{minutes:00}:{seconds:00}";
        }
    }
    
    public void OnPauseButtonPressed()
    {
        _pauseMenu.SetActive(true);
        Time.timeScale = 0f;
    }
    
    public void OnResumeButtonPressed()
    {
        _pauseMenu.SetActive(false);
        Time.timeScale = 1f;
    }
}
```

## Camera Target Group

Each player's camera uses Cinemachine's TargetGroup to dynamically frame the action:

```csharp
public class CameraTargetManager : MonoBehaviour
{
    [SerializeField] private float _playerWeight = 1.0f;
    [SerializeField] private float _playerRadius = 2.0f;
    [SerializeField] private float _ballWeight = 0.5f;
    [SerializeField] private float _ballRadius = 4.0f;
    [SerializeField] private float _otherPlayerWeight = 0.25f;
    [SerializeField] private float _otherPlayerRadius = 2.0f;
    
    private CinemachineTargetGroup _targetGroup;
    private PlayerViewController _player;
    private BallEntityView _ball;
    
    public void Initialize(PlayerViewController player)
    {
        _targetGroup = GetComponent<CinemachineTargetGroup>();
        _player = player;
        
        // Add player as primary target
        _targetGroup.AddMember(player.transform, _playerWeight, _playerRadius);
        
        // Find and add ball
        _ball = FindObjectOfType<BallEntityView>();
        if (_ball != null)
        {
            _targetGroup.AddMember(_ball.transform, _ballWeight, _ballRadius);
        }
        
        // Find and add other players with less weight
        PlayerViewController[] allPlayers = FindObjectsOfType<PlayerViewController>();
        foreach (var otherPlayer in allPlayers)
        {
            if (otherPlayer != player)
            {
                _targetGroup.AddMember(otherPlayer.transform, _otherPlayerWeight, _otherPlayerRadius);
            }
        }
    }
    
    private void Update()
    {
        // Dynamically adjust ball weight based on proximity to player
        if (_ball != null && _player != null)
        {
            float distance = Vector3.Distance(_ball.transform.position, _player.transform.position);
            float normalizedDistance = Mathf.Clamp01(distance / 20f); // 20 units max distance for scaling
            
            // Increase weight as ball gets farther from player
            float dynamicWeight = Mathf.Lerp(_ballWeight, _ballWeight * 2f, normalizedDistance);
            
            // Update the target group member (assumes ball is member index 1)
            _targetGroup.m_Targets[1].weight = dynamicWeight;
        }
    }
}
```

This dynamic camera system keeps the action framed appropriately even with multiple players, creating a compelling split-screen experience.

---

# 07-view-integration.md

# View Integration

This document explains how the Quantum Arena Brawler integrates the Unity view layer with the Quantum simulation.

## View-Simulation Separation

The Quantum framework is designed with a clear separation between:
- **Simulation**: The deterministic game state and logic in Quantum
- **View**: The visual representation in Unity

This separation is crucial for deterministic multiplayer, as it allows the simulation to run identically on all clients while the view can be tailored to each client's display needs.

## Core Integration Components

### Entity Views

Entity views are the primary bridge between Quantum entities and Unity GameObjects:

```csharp
public class PlayerViewController : QuantumEntityView
{
    [SerializeField] private Transform _ballFollowTransform;
    [SerializeField] private Animator _animator;
    
    // Animation parameters
    private static readonly int IsRunning = Animator.StringToHash("IsRunning");
    private static readonly int IsHoldingBall = Animator.StringToHash("IsHoldingBall");
    
    public Transform BallFollowTransform => _ballFollowTransform;
    
    // Called by the Quantum engine when the entity's transform updates
    protected override void ApplyTransform(ref UpdatePositionParameter param)
    {
        // Apply base transform update from Quantum
        base.ApplyTransform(ref param);
        
        // Get additional data from the simulation
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        
        if (frame.Unsafe.TryGetPointer<PlayerStatus>(EntityRef, out var playerStatus))
        {
            // Update animator based on simulation state
            UpdateAnimator(frame, playerStatus);
        }
    }
    
    private void UpdateAnimator(Frame frame, PlayerStatus* playerStatus)
    {
        CharacterController3D* kcc = frame.Unsafe.GetPointer<CharacterController3D>(EntityRef);
        
        // Update animation parameters based on simulation state
        _animator.SetBool(IsRunning, kcc->Velocity.XZ.SqrMagnitude > FP._0_10 && kcc->Grounded);
        _animator.SetBool(IsHoldingBall, playerStatus->IsHoldingBall());
    }
}
```

### Event Handling

Events are used for one-way communication from simulation to view:

```csharp
public class PlayerViewEventHandler : MonoBehaviour, IQuantumEventListener
{
    private Dictionary<EntityRef, PlayerViewController> _playerViews = new Dictionary<EntityRef, PlayerViewController>();
    
    public void OnInit(QuantumGame game)
    {
        // Register for Quantum events
        game.EventDispatcher.Subscribe(this);
    }
    
    // Called when a player view is created
    public void RegisterPlayerView(EntityRef entityRef, PlayerViewController playerView)
    {
        _playerViews[entityRef] = playerView;
    }
    
    // Event handlers for various player events
    public void OnEvent(OnPlayerJumped e)
    {
        if (_playerViews.TryGetValue(e.PlayerEntityRef, out var playerView))
        {
            playerView.OnPlayerJumped();
        }
    }
    
    public void OnEvent(OnPlayerThrewBall e)
    {
        if (_playerViews.TryGetValue(e.PlayerEntityRef, out var playerView))
        {
            playerView.OnPlayerThrewBall();
        }
    }
}
```

### Entity View Factory

The `EntityViewFactory` creates and destroys view objects for Quantum entities:

```csharp
public class ArenaEntityViewFactory : EntityViewFactory
{
    [SerializeField] private PlayerViewController _playerViewPrefab;
    [SerializeField] private BallEntityView _ballViewPrefab;
    
    public override EntityView CreateEntityView(EntityRef entityRef)
    {
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        
        // Player view
        if (frame.Has<PlayerStatus>(entityRef))
        {
            PlayerViewController playerView = Instantiate(_playerViewPrefab);
            playerView.Setup(entityRef);
            return playerView;
        }
        
        // Ball view
        if (frame.Has<BallStatus>(entityRef))
        {
            BallEntityView ballView = Instantiate(_ballViewPrefab);
            ballView.Setup(entityRef);
            return ballView;
        }
        
        return null;
    }
}
```

## Special View Features

### Ball Space Interpolation

The ball uses special interpolation for smooth transitions when held by players:

```csharp
public class BallEntityView : QuantumEntityView
{
    [SerializeField] private float _spaceTransitionSpeed = 4f;
    
    private EntityRef _holdingPlayerEntityRef;
    private float _interpolationSpaceAlpha;
    private Vector3 _lastRealPosition;
    private Vector3 _lastAnimationPosition;
    
    public void UpdateSpaceInterpolation()
    {
        bool isBallHeldByPlayer = _holdingPlayerEntityRef != default;
        
        // Update interpolation alpha
        float deltaChange = _spaceTransitionSpeed * Time.deltaTime;
        _interpolationSpaceAlpha = Mathf.Clamp01(
            isBallHeldByPlayer ? 
            _interpolationSpaceAlpha + deltaChange : 
            _interpolationSpaceAlpha - deltaChange);
        
        if (isBallHeldByPlayer)
        {
            // Get animation position from player
            PlayerViewController player = PlayersManager.Instance.GetPlayer(_holdingPlayerEntityRef);
            _lastAnimationPosition = player.BallFollowTransform.position;
        }
        else
        {
            // Track real position from simulation
            _lastRealPosition = transform.position;
        }
        
        // Interpolate position
        if (_interpolationSpaceAlpha > 0f)
        {
            transform.position = Vector3.Lerp(_lastRealPosition, _lastAnimationPosition, _interpolationSpaceAlpha);
        }
    }
}
```

### Input Integration

The game bridges Unity's Input System to Quantum's input structure:

```csharp
public class LocalInputProvider : MonoBehaviour
{
    [SerializeField] private PlayerInput _playerInput;
    private InputActionMap _gameplayActions;
    
    private Vector2 _moveDirection;
    private Vector2 _aimDirection;
    private bool _jumpPressed;
    private bool _firePressed;
    
    // Called by Quantum to get the current input state
    public void OnInput(QuantumGame game, QuantumDemoInputTopDown* data)
    {
        // Convert from Unity input to Quantum input
        data->MoveDirection = new FPVector2(_moveDirection.x, _moveDirection.y);
        data->AimDirection = new FPVector2(_aimDirection.x, _aimDirection.y);
        
        // Set button states
        SetButton(game, ref data->Jump, _jumpPressed);
        SetButton(game, ref data->Fire, _firePressed);
    }
    
    private void SetButton(QuantumGame game, ref Photon.Deterministic.BitSet button, bool pressed)
    {
        if (pressed)
        {
            button.Push(game.Frames.Predicted);
        }
        else
        {
            button.Clear(game.Frames.Predicted);
        }
    }
}
```

### Game State Events

The game state changes are synchronized through events:

```csharp
public class GameStateViewController : MonoBehaviour, IQuantumEventListener
{
    [SerializeField] private GameObject _startingUI;
    [SerializeField] private GameObject _runningUI;
    [SerializeField] private GameObject _goalScoredUI;
    
    public void OnEvent(OnGameStarting e)
    {
        _startingUI.SetActive(true);
        _runningUI.SetActive(false);
        _goalScoredUI.SetActive(false);
    }
    
    public void OnEvent(OnGameRunning e)
    {
        _startingUI.SetActive(false);
        _runningUI.SetActive(true);
        _goalScoredUI.SetActive(false);
    }
    
    public void OnEvent(OnGoalScored e)
    {
        _startingUI.SetActive(false);
        _runningUI.SetActive(false);
        _goalScoredUI.SetActive(true);
    }
}
```

## Visual Effects System

The game uses a separate system to manage visual effects triggered by simulation events:

```csharp
public class VisualEffectsManager : MonoBehaviour, IQuantumEventListener
{
    [SerializeField] private ParticleSystem _dashEffectPrefab;
    [SerializeField] private ParticleSystem _throwEffectPrefab;
    
    public void OnEvent(OnPlayerDashed e)
    {
        // Create visual effect at player position
        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        if (frame.TryGet<Transform3D>(e.PlayerEntityRef, out var transform))
        {
            Vector3 position = transform.Position.ToUnityVector3();
            ParticleSystem effect = Instantiate(_dashEffectPrefab, position, Quaternion.identity);
            
            // Destroy after duration
            Destroy(effect.gameObject, effect.main.duration);
        }
    }
    
    public void OnEvent(OnPlayerThrewBall e)
    {
        // Similar effect creation for throw events
    }
}
```

## Conclusion

The view integration layer in the Quantum Arena Brawler carefully separates deterministic simulation from visual presentation. Key aspects include:

1. **Entity Views**: Direct mapping between Quantum entities and Unity GameObjects
2. **Event System**: One-way communication from simulation to view
3. **Input Provider**: Translating Unity input into Quantum format
4. **Visual Effects**: Non-gameplay visuals triggered by simulation events
5. **Ball Interpolation**: Smooth transitions between physics and animation states

This separation ensures that the simulation remains deterministic across all clients while still allowing for rich visual presentation unique to each player's view.

---

# 00-summary.md

# Quantum Karts Documentation Summary

This collection of notes provides a comprehensive reference for Quantum Karts, a multiplayer kart racing game built with Photon Quantum 3.0.2. These documents focus on code accuracy and practical implementation of a racing game using the Quantum ECS framework.

## Core Concepts

1. [**Project Overview**](01-project-overview.md)
   - Overview of Quantum Karts architecture
   - Project structure and organization
   - Game flow and systems

2. [**Input System**](02-input-system.md)
   - Input structure and handling
   - Controls mapping
   - Input encoding and optimization

3. [**Kart Driving System**](03-kart-driving-system.md)
   - Kart physics and movement
   - Core driving mechanics
   - Collision handling
   - Surface interactions

## Race Mechanics

4. [**Drifting System**](04-drifting-system.md)
   - Drift initiation and termination
   - Drift physics and handling
   - Boost integration

5. [**Boost System**](05-boost-system.md)
   - Boost types and configuration
   - Speed and acceleration modifications
   - Visual effects integration

6. [**Race System**](06-race-system.md)
   - Track definition and checkpoints
   - Race state management
   - Lap and position tracking
   - Race progress calculation

## Game Features

7. [**Weapon System**](07-weapon-system.md)
   - Weapon pickup and usage
   - Different weapon types
   - Implementation of weapon effects
   - Weapon system integration

8. [**AI System**](08-ai-system.md)
   - AI driver implementation
   - Path finding and racing line
   - Difficulty settings
   - AI decision making

9. [**Unity Integration**](09-unity-integration.md)
   - Visual representation in Unity
   - Kart model and effects
   - Camera and UI integration
   - Synchronization with Quantum simulation

## How to Use These Notes

- Start with the [Project Overview](01-project-overview.md) for a high-level understanding
- Review the [Input System](02-input-system.md) to understand player input flow
- Explore the [Kart Driving System](03-kart-driving-system.md) for core mechanics
- Study the race mechanics and game features for specific implementations

Each document contains detailed code examples that can be directly used in your Quantum kart racing projects. The focus is on providing clear, accurate code snippets that demonstrate best practices for working with the Quantum framework in a racing game context.

---

# 01-project-overview.md

# Quantum Karts Project Overview

This document provides a comprehensive overview of the Quantum Karts project, a multiplayer kart racing game built with Photon Quantum 3.0.2. These notes explain the project structure, core systems, and implementation details to help you understand how to create a kart racing game with Quantum's deterministic networking framework.

## Project Structure

Quantum Karts demonstrates a multiplayer kart racing game with the following organization:

### Core Simulation Code (Quantum)
- **Assets/QuantumUser/Simulation/Karts**: Contains all the deterministic simulation code
  - **Kart**: Core kart mechanics (driving, drifting, weapons, etc.)
  - **Gameplay**: Race system, tracks, and game state management
  - **AI**: AI driver implementation
  - **Util**: Utility functions and helpers

### Unity View Code
- **Assets/Scripts**: Contains Unity-side view code
  - **Controllers**: View representations of simulation elements
  - **Managers**: Game state management on the Unity side
  - **Menu**: UI and menu systems
  - **Util**: Unity-specific utility functions

## Key Features Demonstrated

1. **Kart Physics**: Deterministic kart movement system with drifting
2. **Race System**: Track layout, checkpoints, and race progression
3. **Weapons System**: Pickup and use of various game-altering powerups
4. **AI Drivers**: Computer-controlled racers with configurable difficulty
5. **Boost System**: Speed boosts from drifting and pickups
6. **Surface Effects**: Different surface types affecting kart handling

## Architecture Overview

Quantum Karts follows Quantum's core architecture principles:

### Simulation-View Separation

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

- **Simulation**: Deterministic game logic running in Quantum
- **View**: Visual representation in Unity
- **Events**: One-way communication from simulation to view
- **Input**: Player commands sent from view to simulation

### ECS Implementation

The game uses Quantum's Entity Component System:
- **Entities**: Dynamic game objects (karts, pickups, weapons)
- **Components**: Data containers attached to entities
- **Systems**: Logic that processes entities with specific components

### Networking Model

The predict/rollback networking model:
- **Prediction**: Each client predicts game state based on local input
- **Rollback**: When actual input arrives, state is corrected if necessary
- **Determinism**: Same input always produces the same output

## Core Systems Overview

### Kart System
```csharp
public unsafe class KartSystem : SystemMainThreadFilter<KartSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform3D* Transform3D;
        public Kart* Kart;
        public Wheels* Wheels;
        public KartInput* KartInput;
        public Drifting* Drifting;
        public RaceProgress* RaceProgress;
        public KartHitReceiver* KartHitReceiver;
    }
    
    public override void Update(Frame frame, ref Filter filter)
    {
        // Core kart update logic
        // ...
        
        filter.RaceProgress->Update(frame, filter);
        filter.KartInput->Update(frame, input);
        filter.Wheels->Update(frame);
        filter.Drifting->Update(frame, filter);
        filter.Kart->Update(frame, filter);
    }
    
    // Player management logic...
}
```

### Race System
```csharp
public unsafe class RaceSystem : SystemMainThread, ISignalOnTriggerEnter3D
{
    public override void Update(Frame frame)
    {
        UpdatePositions(frame);
        frame.Unsafe.GetPointerSingleton<Race>()->Update(frame);
    }
    
    public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
    {
        // Checkpoint and lap completion logic
        // ...
    }
    
    private void UpdatePositions(Frame f)
    {
        // Calculate race positions for all karts
        // ...
    }
}
```

### Input System

The input structure defines the player controls:

```qtn
input
{
    button Drift;
    button Powerup;
    button Respawn;
    byte Encoded;
}
```

This is mapped to Unity input in `LocalInput.cs`:

```csharp
public void PollInput(CallbackPollInput callback)
{
    Quantum.Input input = new Quantum.Input();

    input.Drift = UnityEngine.Input.GetButton("Jump");
    input.Powerup = UnityEngine.Input.GetButton("Fire1");
    input.Respawn = UnityEngine.Input.GetKey(KeyCode.R);

    var x = UnityEngine.Input.GetAxis("Horizontal");
    var y = UnityEngine.Input.GetAxis("Vertical");

    input.Direction = new Vector2(x, y).ToFPVector2();

    callback.SetInput(input, DeterministicInputFlags.Repeatable);
}
```

### AI System

Computer-controlled karts use an AIDriver component:

```csharp
public unsafe partial struct AIDriver
{
    public void Update(Frame frame, KartSystem.Filter filter, ref Input input)
    {
        // Get target checkpoint position
        // Calculate steering direction
        // Handle weapon usage
        // Apply inputs based on race situation
        
        FP steeringStrength = settings.SteeringCurve.Evaluate(FPMath.Abs(signedAngle));
        input.Direction = new FPVector2(FPMath.Clamp(-desiredDirection * steeringStrength, -1, 1), 1);
    }
}
```

## Quantum-Unity Integration

The integration between Quantum and Unity is handled through:
- **VisualKartSpawner**: Creates the visual representation of karts
- **EntityViews**: Connect Unity GameObjects to Quantum entities
- **Event Handlers**: Receive Quantum events for visual effects
- **Input Polling**: Capture Unity input for Quantum simulation

## Key Components

The kart entity consists of several interacting components:

- **Kart**: Handles physics, movement, and surface interactions
- **KartInput**: Processes and applies player input
- **Wheels**: Manages wheel physics and ground detection
- **Drifting**: Controls drift mechanics and related boosts
- **KartWeapons**: Manages weapon pickup and usage
- **RaceProgress**: Tracks race position, laps, and checkpoints

## Race Flow

The race goes through several states managed by the `Race` component:

1. **Waiting**: Players are joining and selecting karts
2. **Countdown**: Race is about to begin
3. **InProgress**: Race is active
4. **Finishing**: First player has finished, giving others time to complete
5. **Finished**: Race is over, showing results

## How To Use These Notes

- Start with the Project Overview to understand the game's architecture
- Explore the Kart Driving System to understand the core mechanics
- Follow other documents based on specific features you're interested in
- Use the code examples as reference when implementing your own kart racing game

The focus is on presenting accurate code examples that can be used as templates for your own Quantum projects.

---

# 02-input-system.md

# Quantum Karts Input System

This document details the input system used in the Quantum Karts project, covering how player input is defined, processed, and applied to kart entities within the deterministic simulation.

## Input Definition

The Quantum Karts input structure is defined in `Input.qtn` as follows:

```qtn
input
{
    button Drift;
    button Powerup;
    button Respawn;
    byte Encoded;
}
```

This structure contains:
- **Drift**: Button for initiating/ending drifts
- **Powerup**: Button for using collected weapons
- **Respawn**: Button for manual respawn or ready toggle
- **Encoded**: Compact representation of steering and acceleration (discussed below)

## Unity Input Collection

The Unity-side input is captured in the `LocalInput` class, which subscribes to Quantum's input polling callback:

```csharp
public class LocalInput : MonoBehaviour
{
    private void Start()
    {
        QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
    }

    public void PollInput(CallbackPollInput callback)
    {
        Quantum.Input input = new Quantum.Input();

        // Buttons
        input.Drift = UnityEngine.Input.GetButton("Jump");
        input.Powerup = UnityEngine.Input.GetButton("Fire1");
        input.Respawn = UnityEngine.Input.GetKey(KeyCode.R);

        // Direction (steering and acceleration)
        var x = UnityEngine.Input.GetAxis("Horizontal");
        var y = UnityEngine.Input.GetAxis("Vertical");

        // Convert to Quantum's deterministic FPVector2
        input.Direction = new Vector2(x, y).ToFPVector2();

        // Send input to Quantum simulation
        callback.SetInput(input, DeterministicInputFlags.Repeatable);
    }
}
```

This approach ensures that:
1. Input is captured every frame from Unity's input system
2. Values are converted to deterministic types (FPVector2)
3. Input is sent to the Quantum simulation with the Repeatable flag

## KartInput Component

The input is further processed by the `KartInput` component, which is attached to kart entities:

```qtn
component KartInput {
    [ExcludeFromPrototype] FP Throttle;    
    [ExcludeFromPrototype] FP Steering;    
    [ExcludeFromPrototype] button Drifting;
    [ExcludeFromPrototype] FP PreviousSteering;    
    [ExcludeFromPrototype] bool PreviousDrifting;
    [ExcludeFromPrototype] FP SameSteeringTime;    
    [ExcludeFromPrototype] FP NoSteeringTime;
    [ExcludeFromPrototype] FP DriftingInputTime;    
    [ExcludeFromPrototype] FP SteeringOffset;
}
```

The C# implementation of this component includes methods for processing raw input:

```csharp
public unsafe partial struct KartInput
{
    public void Update(Frame frame, Input input)
    {
        // Store previous frame values
        PreviousSteering = Steering;
        PreviousDrifting = Drifting.IsActive;
        
        // Update current values
        Drifting = input.Drift;
        Throttle = input.Direction.Y;
        Steering = input.Direction.X;
        
        // Calculate timing values for steering and drifting
        if (FPMath.Abs(Steering) < FP._0_05)
        {
            NoSteeringTime += frame.DeltaTime;
            SameSteeringTime = 0;
        }
        else if (FPMath.Sign(Steering) == FPMath.Sign(PreviousSteering))
        {
            SameSteeringTime += frame.DeltaTime;
            NoSteeringTime = 0;
        }
        else
        {
            SameSteeringTime = 0;
            NoSteeringTime = 0;
        }
        
        // Track drifting button hold time
        if (Drifting.IsActive)
        {
            DriftingInputTime += frame.DeltaTime;
        }
        else
        {
            DriftingInputTime = 0;
        }
    }

    public FP GetTotalSteering()
    {
        return Steering + SteeringOffset;
    }
}
```

Key aspects of this implementation:
- Tracks input timing for features like drift control
- Manages state transitions (button presses/releases)
- Adds steering offset caused by drifting
- Provides a clean API for other systems to access input state

## AI Input Simulation

For AI-controlled karts, the input is simulated by the `AIDriver` component rather than coming from a player:

```csharp
public unsafe partial struct AIDriver
{
    public void Update(Frame frame, KartSystem.Filter filter, ref Input input)
    {
        AIDriverSettings settings = frame.FindAsset(SettingsRef);
        
        // Calculate target position and direction
        FPVector3 toWaypoint = TargetLocation - filter.Transform3D->Position;
        FPVector3 toNextWaypoint = NextTargetLocation - filter.Transform3D->Position;
        toWaypoint.Y = 0;
        toNextWaypoint.Y = 0;
        
        // Calculate prediction amount based on distance
        FP distance = FPVector3.Distance(TargetLocation, filter.Transform3D->Position);
        FP distanceNext = FPVector3.Distance(TargetLocation, NextTargetLocation);
        FP predictionAmount = FPMath.InverseLerp(distance, distanceNext, settings.PredictionRange);
        
        // Blend current and next waypoint based on prediction
        FPVector3 targetDirection = FPVector3.Lerp(toWaypoint, toNextWaypoint, predictionAmount).Normalized;
        
        // Calculate steering angle
        FP turnAngle = FPVector3.Angle(toWaypoint, toNextWaypoint);
        FP signedAngle = FPVector3.SignedAngle(targetDirection, filter.Kart->Velocity, FPVector3.Up);
        FP desiredDirection = FPMath.Sign(signedAngle);
        
        // Set drift input based on turn sharpness
        if (frame.Unsafe.TryGetPointer(filter.Entity, out Drifting* drifting))
        {
            bool shouldStartDrift = turnAngle >= settings.DriftingAngle && !drifting->IsDrifting;
            bool shouldEndDrift = turnAngle < settings.DriftingStopAngle && drifting->IsDrifting;
            
            input.Drift = !drifting->IsDrifting && shouldStartDrift || drifting->IsDrifting && shouldEndDrift;
        }
        
        // Calculate steering strength based on angle
        FP steeringStrength = settings.SteeringCurve.Evaluate(FPMath.Abs(signedAngle));
        
        // Set final input direction
        input.Direction = new FPVector2(FPMath.Clamp(-desiredDirection * steeringStrength, -1, 1), 1);
        
        // Handle weapon usage
        if (frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
        {
            LastWeaponTime += frame.DeltaTime;
            
            if (weapons->HeldWeapon != default
                && LastWeaponTime > FP._0_50
                && frame.FindAsset(weapons->HeldWeapon).AIShouldUse(frame, filter.Entity))
            {
                input.Powerup = true;
            }
        }
        
        // Handle respawn if stuck
        StationaryTime = filter.Kart->Velocity.SqrMagnitude < FP._7 ? 
            StationaryTime + frame.DeltaTime : 0;
            
        if (StationaryTime > 5)
        {
            input.Respawn = true;
            StationaryTime = 0;
        }
    }
}
```

AI input is designed to:
- Follow racing waypoints on the track
- Use look-ahead for smoother steering
- Determine when to drift based on turn angles
- Decide when to use weapons based on race situation
- Auto-respawn when stuck

## Input Flow Overview

The full input flow in Quantum Karts follows this sequence:

1. **Unity** captures raw input via `LocalInput.PollInput`
2. Input is converted to deterministic types and sent to Quantum
3. **Quantum** processes the input in `KartSystem.Update`
4. `KartInput.Update` transforms raw input into usable values
5. Input values are used by multiple systems:
   - `Kart.Update` for movement and physics
   - `Drifting.Update` for drift mechanics
   - `KartWeapons.UseWeapon` for weapon activation

## Optimization Notes

1. **Button States**: Quantum automatically tracks button state transitions (pressed/released), so Unity code only needs to provide current state
2. **Input Size**: The input structure is kept minimal to reduce network traffic
3. **Encoded Input**: The `Encoded` byte field can be used for even more compact representation of analog input
4. **Prediction**: The `DeterministicInputFlags.Repeatable` flag ensures consistent prediction during network delays

## Implementation Examples

### Starting a Drift Based on Input

```csharp
private bool CanStartDrift(KartInput* kartInput, Kart* kart, int desiredDirection)
{
    if (desiredDirection == Direction) { return false; }
    
    if (!kartInput->Drifting.WasPressed) { return false; }
    
    if (kart->AirTime > MaxAirTime) { return false; }
    
    if (kart->Velocity.SqrMagnitude < MinimumSpeed * MinimumSpeed) { return false; }
    
    if (FPMath.Abs(kartInput->Steering) < FP._0_05) { return false; }
    
    if (kart->IsOffroad) { return false; }
    
    return true;
}
```

### Using a Weapon

```csharp
// In KartSystem.Update
if (input.Powerup.WasPressed && frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
{
    weapons->UseWeapon(frame, filter);
}
```

### Respawn Logic

```csharp
// In KartSystem.Update
if (input.Respawn)
{
    frame.Add<RespawnMover>(filter.Entity);
}
```

## Best Practices

1. **Always use FP types**: Ensure all input processing uses Quantum's fixed-point math
2. **Handle state transitions**: Track when input state changes for one-time events
3. **Decouple input capture**: Keep Unity's input collection separate from simulation logic
4. **Input validation**: Verify input values are within expected ranges
5. **Minimal structure**: Keep the input structure as small as possible for network efficiency

---

# 03-kart-driving-system.md

# Quantum Karts Driving System

This document explains the kart driving system in Quantum Karts, covering the core physics, movement, and handling mechanics that create the kart racing experience.

## Core Components

The kart driving system consists of several interrelated components:

### Kart Component

The `Kart` component is the central element of the driving system, defined in `Kart.qtn`:

```qtn
component Kart {    
    [ExcludeFromPrototype] ComponentPrototypeRef Prototype;	
    [ExcludeFromPrototype] FPVector3 Velocity;	
    [ExcludeFromPrototype] FPVector3 OldVelocity;	
    [ExcludeFromPrototype] FPVector3 ExternalForce;	
    [ExcludeFromPrototype] FPVector3 CollisionPositionCompensation;
    [ExcludeFromPrototype] FP SidewaysSpeedSqr;
    [ExcludeFromPrototype] FP SurfaceFrictionMultiplier;
    [ExcludeFromPrototype] FP SurfaceSpeedMultiplier;
    [ExcludeFromPrototype] FP SurfaceHandlingMultiplier;
    [ExcludeFromPrototype] FPQuaternion TargetRotation;
    [ExcludeFromPrototype] byte GroundedWheels;
    [ExcludeFromPrototype] byte OffroadWheels;
    [ExcludeFromPrototype] FP AirTime;
    [ExcludeFromPrototype] FP OffroadTime;
    [ExcludeFromPrototype] PhysicsQueryRef OverlapQuery;
        
    asset_ref<KartStats> StatsAsset;
    asset_ref<KartVisuals> VisualAsset;
}
```

### KartStats Asset

The `KartStats` asset defines the movement characteristics of each kart:

```csharp
public unsafe partial class KartStats : AssetObject
{
    public FPVector3 overlapShapeSize;
    public FPVector3 overlapShapeOffset;
    public LayerMask overlapLayerMask;

    public FPAnimationCurve acceleration;
    public FPAnimationCurve turningRate;
    public FPAnimationCurve frictionEffect;
    public FP maxSpeed;
    public FP minThrottle;
    public FP gravity;
    public FP drag;
    public FP rotationCorrectionRate;
    public FP rotationSmoothingThreshold;
    public FP maxTilt;
    public FP groundDistance;
}
```

### Wheels Component

The `Wheels` component manages wheel physics and ground detection:

```qtn
component Wheels {
    [ExcludeFromPrototype] array<WheelStatus>[4] WheelStatuses;
    [ExcludeFromPrototype] FP SuspensionLength;
    [ExcludeFromPrototype] FP SuspensionTravel;
    [ExcludeFromPrototype] FP SuspensionStiffness;
    [ExcludeFromPrototype] FPVector3 COM;
    
    FPVector3 FrontLeft;
    FPVector3 FrontRight;
    FPVector3 RearLeft;
    FPVector3 RearRight;
}
```

## Physics Implementation

### Kart Movement

The core physics is implemented in the `Kart.Update` method:

```csharp
public unsafe partial struct Kart
{
    public bool IsGrounded => GroundedWheels > 1;
    public bool IsOffroad => OffroadWheels >= 4;

    public void Update(Frame frame, KartSystem.Filter filter)
    {
        Transform3D* transform = filter.Transform3D;
        Wheels* wheelComp = filter.Wheels;
        
        // Get kart stats
        var stats = frame.FindAsset(StatsAsset);
        
        // Process wheel information
        FPVector3 up = transform->Up;
        FPVector3 targetUp = up;
        FPVector3 averagePoint = transform->Position + FPVector3.Up * stats.groundDistance;
        
        GroundedWheels = 0;
        OffroadWheels = 0;
        SurfaceFrictionMultiplier = 0;
        SurfaceSpeedMultiplier = 1;
        SurfaceHandlingMultiplier = 1;
        
        // Process each wheel
        for (int i = 0; i < wheelComp->WheelStatuses.Length; i++)
        {
            WheelStatus* status = wheelComp->WheelStatuses.GetPointer(i);
            
            if (status->Grounded)
            {
                targetUp += status->HitNormal;
                averagePoint += status->HitPoint;
                GroundedWheels++;
                
                // Apply surface effects
                DrivingSurface surface = frame.FindAsset(status->HitSurface);
                SurfaceFrictionMultiplier += surface.FrictionMultiplier;
                SurfaceSpeedMultiplier += surface.SpeedMultiplier;
                SurfaceHandlingMultiplier += surface.HandlingMultiplier;
                
                if (surface.Offroad)
                {
                    OffroadWheels++;
                }
            }
        }
        
        // Average the values
        averagePoint /= (GroundedWheels + 1);
        targetUp /= (GroundedWheels + 1);
        
        SurfaceFrictionMultiplier /= wheelComp->WheelStatuses.Length;
        SurfaceSpeedMultiplier /= (GroundedWheels + 1);
        SurfaceHandlingMultiplier /= (GroundedWheels + 1);
        
        // Track airtime
        AirTime = !IsGrounded ? AirTime + frame.DeltaTime : 0;
        
        // Apply collision detection
        ApplyOverlapCollision(frame, filter.Entity);
        
        // Cap ground normal to a maximum tilt angle
        FP tiltAngle = FPVector3.Angle(targetUp, FPVector3.Up);
        if (tiltAngle > stats.maxTilt)
        {
            targetUp = FPVector3.Lerp(FPVector3.Up, targetUp, FPMath.InverseLerp(0, tiltAngle, stats.maxTilt));
        }
        
        // Calculate new position based on velocity
        FPVector3 newPosition = transform->Position + CollisionPositionCompensation + Velocity * frame.DeltaTime;
        
        // Handle ground alignment
        FPVector3 targetForward;
        
        if (IsGrounded)
        {
            // When grounded, align to surface
            Plane avgGround = new(averagePoint, targetUp);
            FP distance = avgGround.SignedDistanceTo(newPosition);
            
            // Remove gravity if close to ground
            if (distance < stats.groundDistance)
            {
                FP velocityToGround = FPVector3.Dot(Velocity, targetUp);
                
                if (velocityToGround < FP._0)
                {
                    Velocity -= targetUp * velocityToGround;
                }
                
                newPosition += (stats.groundDistance - distance) * targetUp;
            }
            
            targetForward = FPVector3.Cross(transform->Right, targetUp);
        }
        else
        {
            // In air, gradually align to level
            targetUp = FPVector3.MoveTowards(targetUp, FPVector3.Up,
                stats.rotationCorrectionRate * frame.DeltaTime);
            targetForward = FPVector3.Cross(transform->Right, targetUp);
        }
        
        // Rotation handling
        FPQuaternion lookRotation = FPQuaternion.LookRotation(targetForward, targetUp);
        FP angle = FPQuaternion.Angle(lookRotation, transform->Rotation);
        FP smoothing = FPMath.Clamp01(angle / stats.rotationSmoothingThreshold);
        FP wheelMultiplier = FP._0_25 + (FP._0_75 * (GroundedWheels / 4));
        FP lerp = FP._0_50 * smoothing * wheelMultiplier;
        
        lookRotation = FPQuaternion.Slerp(transform->Rotation, lookRotation, lerp);
        
        // Apply steering rotation
        bool hasInput = FPMath.Abs(filter.KartInput->GetTotalSteering()) > FP._0_05;
        if (hasInput)
        {
            lookRotation *= FPQuaternion.AngleAxis(
                filter.KartInput->GetTotalSteering()
                * SurfaceHandlingMultiplier
                * FPMath.Sign(FPVector3.Dot(Velocity, transform->Forward))
                * GetTurningRate(frame, filter.Drifting)
                * frame.DeltaTime,
                FPVector3.Up
            );
        }
        
        // Apply position and rotation
        transform->Position = newPosition;
        transform->Rotation = lookRotation;
        
        // Calculate sideways speed (used for drifting)
        SidewaysSpeedSqr = FPVector3.Project(Velocity, transform->Right).SqrMagnitude;
        
        // Apply physics forces
        Accelerate(frame, filter.Entity, filter.KartInput, transform->Forward);
        ApplyExternalForce(frame);
        ApplyGravity(frame, targetUp);
        ApplyFriction(frame, transform);
        ApplyDrag(frame);
        LimitVelocity(frame, filter.Entity);
        
        // Reset external force
        ExternalForce = FPVector3.Zero;
    }
    
    // Additional methods...
}
```

### Key Physics Methods

Several methods handle specific aspects of the kart physics:

#### Acceleration

```csharp
private void Accelerate(Frame frame, EntityRef entity, KartInput* input, FPVector3 direction)
{
    if (!IsGrounded)
    {
        return;
    }

    KartStats stats = frame.FindAsset(StatsAsset);

    Velocity += GetAcceleration(frame, entity) * frame.DeltaTime *
                FPMath.Clamp(input->Throttle, stats.minThrottle, 1) * direction;
}

public FP GetAcceleration(Frame frame, EntityRef entity)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    FP bonus = 0;

    if (frame.Unsafe.TryGetPointer(entity, out KartBoost* kartBoost) && kartBoost->CurrentBoost != null)
    {
        BoostConfig config = frame.FindAsset(kartBoost->CurrentBoost);
        bonus += config.AccelerationBonus;
    }

    return stats.acceleration.Evaluate(GetNormalizedSpeed(frame)) * SurfaceSpeedMultiplier + bonus;
}
```

#### Friction

```csharp
private void ApplyFriction(Frame frame, Transform3D* t)
{
    if (!IsGrounded)
    {
        return;
    }

    KartStats stats = frame.FindAsset(StatsAsset);

    FPVector3 frictionDirection = t->Right;
    FP frictionAmount = FPVector3.Dot(Velocity, frictionDirection);
    FP effect = stats.frictionEffect.Evaluate(GetNormalizedSpeed(frame));
    FPVector3 friction = frictionDirection * (frictionAmount * SurfaceFrictionMultiplier * effect);

    Velocity -= friction;
}
```

#### Gravity and Drag

```csharp
private void ApplyGravity(Frame frame, FPVector3 up)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    Velocity += up * stats.gravity * frame.DeltaTime * (IsGrounded ? FP._0_10 : FP._1);
}

private void ApplyDrag(Frame frame)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    Velocity -= Velocity * stats.drag * frame.DeltaTime * (IsGrounded ? FP._1 : FP._0_10);
}
```

#### Speed Limiting

```csharp
private void LimitVelocity(Frame frame, EntityRef entity)
{
    // No hard clamping so kart doesn't suddenly "hit a wall" when a boost ends
    Velocity = FPVector3.MoveTowards(
        Velocity,
        FPVector3.ClampMagnitude(Velocity, GetMaxSpeed(frame, entity)),
        FP._0_10
    );
}

public FP GetMaxSpeed(Frame frame, EntityRef entity)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    FP bonus = 0;

    if (frame.Unsafe.TryGetPointer(entity, out KartBoost* kartBoost) && kartBoost->CurrentBoost != null)
    {
        BoostConfig config = frame.FindAsset(kartBoost->CurrentBoost);
        bonus += config.MaxSpeedBonus;
    }

    return stats.maxSpeed * SurfaceSpeedMultiplier + bonus;
}
```

## Collision Handling

The kart system uses a custom overlap-based collision system rather than relying on the physics engine for more precise control:

```csharp
private void ApplyOverlapCollision(Frame frame, EntityRef entity)
{
    FP collisionSetback = FP._0;
    FPVector3 bounce = new();

    var hits = frame.Physics3D.GetQueryHits(OverlapQuery);
    if (hits.Count > 0)
    {
        for (int i = 0; i < hits.Count; i++)
        {
            Hit3D overlap = hits[i];

            if (overlap.Entity == entity) { continue; }

            // Don't pop out on the other side of thin obstacles
            FP dot = FPVector3.Dot(Velocity.Normalized, overlap.Normal);
            if (dot > 0) { continue; }

            // Don't sink further in the ground
            if (FPVector3.Dot(overlap.Normal, FPVector3.Down) > FP._0_50) { continue; }

            bounce += overlap.Normal;

            FPVector3 flatVelocity = Velocity;
            flatVelocity.Y = 0;

            Velocity -= dot * dot * flatVelocity * FP._0_50;

            collisionSetback = FPMath.Max(collisionSetback, overlap.OverlapPenetration);
        }

        bounce = bounce.Normalized;
    }

    bounce.Y = 0;

    CollisionPositionCompensation = bounce * collisionSetback;
}

public Shape3D GetOverlapShape(Frame frame)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    return Shape3D.CreateBox(stats.overlapShapeSize, stats.overlapShapeOffset);
}
```

## Wheel System

The wheel system is responsible for detecting the ground beneath each wheel and providing surface information:

```csharp
public unsafe class WheelQuerySystem : SystemMainThreadFilter<WheelQuerySystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform3D* Transform3D;
        public Wheels* Wheels;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        Transform3D* transform = filter.Transform3D;
        Wheels* wheels = filter.Wheels;
        
        FPVector3[] wheelPositions = new FPVector3[4];
        
        // Calculate world space position of each wheel
        wheelPositions[0] = transform->LocalToWorldPosition(wheels->FrontLeft);
        wheelPositions[1] = transform->LocalToWorldPosition(wheels->FrontRight);
        wheelPositions[2] = transform->LocalToWorldPosition(wheels->RearLeft);
        wheelPositions[3] = transform->LocalToWorldPosition(wheels->RearRight);
        
        // Center of mass offset
        wheels->COM = (wheelPositions[0] + wheelPositions[1] + wheelPositions[2] + wheelPositions[3]) / 4;
        
        // Perform raycasts for each wheel
        for (int i = 0; i < 4; i++)
        {
            FPVector3 startPos = wheelPositions[i] + transform->Up * wheels->SuspensionTravel;
            FPVector3 endPos = wheelPositions[i] - transform->Up * wheels->SuspensionLength;
            
            WheelStatus* status = wheels->WheelStatuses.GetPointer(i);
            
            status->Grounded = false;
            
            if (frame.Physics3D.Raycast(startPos, endPos, out var hit))
            {
                status->Grounded = true;
                status->HitPoint = hit.Point;
                status->HitNormal = hit.Normal;
                status->SuspensionCompression = 1 - (hit.Distance / (wheels->SuspensionLength + wheels->SuspensionTravel));
                
                // Get surface type from hit entity
                if (frame.Unsafe.TryGetPointer<DrivingSurface>(hit.Entity, out var surface))
                {
                    status->HitSurface = surface->SurfaceType;
                }
                else
                {
                    status->HitSurface = default;
                }
            }
        }
    }
}
```

## Surface System

Different surfaces can affect kart handling through the `DrivingSurface` component:

```csharp
public unsafe partial class DrivingSurface : AssetObject
{
    public bool Offroad;
    public FP FrictionMultiplier = 1;
    public FP SpeedMultiplier = 1;
    public FP HandlingMultiplier = 1;
    public ParticleRef EffectType;
}
```

The surface multipliers affect:
- **Friction**: How much sideways grip the kart has
- **Speed**: Maximum speed and acceleration
- **Handling**: How responsive steering is

## KartSystem Integration

The `KartSystem` ties all components together, filtering entities with the required components and updating them each frame:

```csharp
public unsafe class KartSystem : SystemMainThreadFilter<KartSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform3D* Transform3D;
        public Kart* Kart;
        public Wheels* Wheels;
        public KartInput* KartInput;
        public Drifting* Drifting;
        public RaceProgress* RaceProgress;
        public KartHitReceiver* KartHitReceiver;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        Input input = default;

        // Don't update karts during race setup
        if (!frame.Unsafe.TryGetPointerSingleton(out Race* race) || (race->CurrentRaceState < RaceState.InProgress))
        {
            // Handle ready toggle during waiting phase
            if (frame.Unsafe.TryGetPointer(filter.Entity, out PlayerLink* playerLink)
                && frame.GetPlayerInput(playerLink->Player)->Respawn.WasPressed)
            {
                playerLink->Ready = !playerLink->Ready;
                frame.Events.LocalPlayerReady(playerLink->Player, playerLink->Ready);
            }

            return;
        }

        // Update race progress
        filter.RaceProgress->Update(frame, filter);

        // Skip update if respawning
        if (frame.Unsafe.TryGetPointer(filter.Entity, out RespawnMover* respawnMover))
        {
            return;
        }

        // Get input from AI or player
        if (frame.Unsafe.TryGetPointer(filter.Entity, out AIDriver* ai))
        {
            ai->Update(frame, filter, ref input);
        }
        else if (frame.Unsafe.TryGetPointer(filter.Entity, out PlayerLink* playerLink))
        {
            input = *frame.GetPlayerInput(playerLink->Player);
        }

        // Handle respawn
        if (input.Respawn)
        {
            frame.Add<RespawnMover>(filter.Entity);
        }

        // Handle weapon usage
        if (input.Powerup.WasPressed && frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
        {
            weapons->UseWeapon(frame, filter);
        }

        // Update hit receiver
        filter.KartHitReceiver->Update(frame, filter);

        if (filter.KartHitReceiver->HitTimer > 0)
        {
            input.Direction = FPVector2.Zero;
            filter.Drifting->Direction = 0;
        }

        // Update all kart components
        filter.KartInput->Update(frame, input);
        filter.Wheels->Update(frame);
        filter.Drifting->Update(frame, filter);
        filter.Kart->Update(frame, filter);
    }
    
    // Additional methods for player connection, AI, spawning, etc.
}
```

## Best Practices

1. **Separation of Concerns**: Each aspect of kart physics is handled by a separate component/system
2. **Surface-based Effects**: Use driving surfaces to create varied terrain behavior
3. **Custom Collision**: Custom overlap detection for precise collision response
4. **Animation Curves**: Use FPAnimationCurve for non-linear physics behavior
5. **Wheel Raycasts**: Perform separate calculations for each wheel to handle uneven terrain
6. **Deterministic Math**: Always use Quantum's FP types for deterministic simulation
7. **Entity Filtering**: Use SystemMainThreadFilter for efficient component access

---

# 04-drifting-system.md

# Quantum Karts Drifting System

This document explains the drifting mechanics in Quantum Karts, covering how drift initiation, physics, and control work to create the core skill-based gameplay of kart racing.

## Drifting Component

The drifting system starts with the `Drifting` component defined in `Drifting.qtn`:

```qtn
component Drifting {
    [ExcludeFromPrototype] sbyte Direction;
    [ExcludeFromPrototype] FP SideAcceleration;
    [ExcludeFromPrototype] FP ForwardFactor;
    [ExcludeFromPrototype] FP MaxSteeringOffset;
    [ExcludeFromPrototype] FP MinimumSpeed;
    [ExcludeFromPrototype] FP MinSidewaysSpeedSqr;
    [ExcludeFromPrototype] FP MaxAirTime;
    [ExcludeFromPrototype] FP MaxNoSteerTime;
    [ExcludeFromPrototype] FP MaxOppositeSteerTime;
}
```

Key properties:
- **Direction**: The direction of drift (-1 for left, 0 for none, 1 for right)
- **SideAcceleration**: The force applied perpendicular to the kart's direction
- **ForwardFactor**: Balance between sideways and forward motion during drift
- **MaxSteeringOffset**: How much drift affects steering angle
- **MinimumSpeed**: Speed required to initiate a drift
- **MinSidewaysSpeedSqr**: Minimum sideways speed to maintain drift
- **MaxAirTime**: Maximum time in air before drift is canceled
- **MaxNoSteerTime**: How long without steering before drift ends
- **MaxOppositeSteerTime**: How long with opposite steering before drift ends

## Implementation 

The drifting mechanics are implemented in the `Drifting.cs` file:

```csharp
public unsafe partial struct Drifting
{
    public bool IsDrifting => Direction != 0;

    public void Update(Frame frame, KartSystem.Filter filter)
    {
        Kart* kart = filter.Kart;
        Transform3D* transform = filter.Transform3D;
        
        // Determine the intended drift direction from steering input
        int desiredDirection = FPMath.RoundToInt(FPMath.Sign(filter.KartInput->Steering));

        // Start, maintain, or end drift based on conditions
        if (CanStartDrift(filter.KartInput, kart, desiredDirection))
        {
            Direction = desiredDirection;
        }
        else if (IsDrifting && ShouldEndDrift(filter.KartInput, kart))
        {
            Direction = 0;
        }

        // Calculate drift acceleration direction by blending side and forward vectors
        FPVector3 accelerationDirection = FPVector3.Lerp(transform->Right * -Direction, transform->Forward, ForwardFactor);

        // Apply steering offset from drifting
        filter.KartInput->SteeringOffset = MaxSteeringOffset * Direction;

        // Apply side force when drifting is active
        if (IsDrifting)
        {
            kart->ExternalForce += accelerationDirection * SideAcceleration * filter.KartInput->Throttle;
        }
    }

    private bool CanStartDrift(KartInput* kartInput, Kart* kart, int desiredDirection)
    {
        // Don't start if already drifting in this direction
        if (desiredDirection == Direction) { return false; }

        // Drift button must be pressed
        if (!kartInput->Drifting.WasPressed) { return false; }

        // Can't drift if in air too long
        if (kart->AirTime > MaxAirTime) { return false; }

        // Need minimum speed to drift
        if (kart->Velocity.SqrMagnitude < MinimumSpeed * MinimumSpeed) { return false; }

        // Need to actually be steering
        if (FPMath.Abs(kartInput->Steering) < FP._0_05) { return false; }

        // Can't drift on offroad surfaces
        if (kart->IsOffroad) { return false; }

        return true;
    }

    private bool ShouldEndDrift(KartInput* kartInput, Kart* kart)
    {
        // End drift on offroad surfaces
        if (kart->IsOffroad) { return true; }

        // End drift when drift button is pressed again
        if (kartInput->Drifting.WasPressed) { return true; }

        // End drift if in air too long
        if (kart->AirTime > MaxAirTime) { return true; }

        // End drift if speed drops too low
        if (kart->Velocity.SqrMagnitude < MinimumSpeed * MinimumSpeed) { return true; }

        // End drift if not enough sideways motion and no steering input for too long
        if (kart->SidewaysSpeedSqr < MinSidewaysSpeedSqr && kartInput->NoSteeringTime > MaxNoSteerTime)
        {
            return true;
        }

        // End drift if steering in opposite direction for too long
        if (FPMath.Sign(kartInput->Steering) != Direction && kartInput->SameSteeringTime > MaxOppositeSteerTime)
        {
            return true;
        }

        return false;
    }
}
```

## Drift Boost System

Drifting in Quantum Karts is integrated with the boost system. The `DriftBoost` component extends drifting with boost rewards:

```qtn
component DriftBoost {
    [ExcludeFromPrototype] FP DriftTime;
    [ExcludeFromPrototype] byte BoostLevel;
    [ExcludeFromPrototype] FP BoostVisualFeedback;
    [ExcludeFromPrototype] array<FP>[3] BoostThresholds;
    [ExcludeFromPrototype] array<AssetRef<BoostConfig>>[3] BoostConfigs;
}
```

The implementation tracks drift time and grants boosts when thresholds are met:

```csharp
public unsafe partial struct DriftBoost
{
    public void Update(Frame frame, KartSystem.Filter filter)
    {
        Drifting* drifting = filter.Drifting;
        
        // Only update when actively drifting
        if (drifting->IsDrifting)
        {
            DriftTime += frame.DeltaTime;
            
            // Check for boost level upgrades
            for (byte i = 0; i < BoostThresholds.Length; i++)
            {
                if (DriftTime >= BoostThresholds.GetPointer(i)->Value && i > BoostLevel)
                {
                    BoostLevel = i;
                    BoostVisualFeedback = FP._1;
                    frame.Events.DriftBoostCharged(filter.Entity, BoostLevel);
                }
            }
            
            // Fade visual feedback
            if (BoostVisualFeedback > 0)
            {
                BoostVisualFeedback -= frame.DeltaTime * 2;
            }
        }
        // Apply boost when drifting ends
        else if (DriftTime > 0)
        {
            if (BoostLevel > 0 && frame.Unsafe.TryGetPointer(filter.Entity, out KartBoost* boost))
            {
                boost->StartBoost(frame, BoostConfigs.GetPointer(BoostLevel - 1)->Value, filter.Entity);
                frame.Events.DriftBoostApplied(filter.Entity, BoostLevel);
            }
            
            // Reset values
            DriftTime = 0;
            BoostLevel = 0;
            BoostVisualFeedback = 0;
        }
    }
}
```

The `BoostSystem` ties everything together:

```csharp
public unsafe class BoostSystem : SystemMainThreadFilter<BoostSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public KartBoost* KartBoost;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        filter.KartBoost->Update(frame);
    }
}
```

## Drift-Specific Physics Calculations

Several parts of the kart physics system are modified during drifting:

### 1. Turning Rate Calculation

The `Kart.GetTurningRate` method adjusts turning sensitivity during drifting:

```csharp
public FP GetTurningRate(Frame frame, Drifting* drifting)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    
    // Use maximum turning rate during drift, otherwise use speed-based turning
    return stats.turningRate.Evaluate(drifting->Direction != 0 ? 1 : GetNormalizedSpeed(frame));
}
```

This makes steering more responsive during drifts regardless of speed.

### 2. Steering Offset Application

The `KartInput` component tracks a steering offset that is applied during drifting:

```csharp
// In Drifting.Update
filter.KartInput->SteeringOffset = MaxSteeringOffset * Direction;

// In KartInput
public FP GetTotalSteering()
{
    return Steering + SteeringOffset;
}
```

This causes the kart to automatically steer in the drift direction, requiring counter-steering to balance.

### 3. Side Force Application

During drifting, a continuous side force is applied to maintain the sliding motion:

```csharp
// In Drifting.Update
if (IsDrifting)
{
    kart->ExternalForce += accelerationDirection * SideAcceleration * filter.KartInput->Throttle;
}
```

This creates the characteristic sliding motion while still allowing forward movement.

## Drift Initiation and Control

Drifting follows a specific flow:

1. **Preparation**: Player must be moving above minimum speed
2. **Initiation**: Player presses the drift button while steering left or right
3. **Maintenance**: Player must maintain speed and steering
4. **Control**: Counter-steering controls the drift angle
5. **Boost Building**: Longer drifts charge up larger boosts
6. **Release**: Letting go of drift or pressing it again ends the drift
7. **Boost Application**: If minimum drift time was achieved, a boost is applied

## KartInput Integration

The `KartInput` component tracks input timing that's crucial for drift control:

```csharp
public unsafe partial struct KartInput
{
    public void Update(Frame frame, Input input)
    {
        // Store previous frame values
        PreviousSteering = Steering;
        PreviousDrifting = Drifting.IsActive;
        
        // Update current values from input
        Drifting = input.Drift;
        Throttle = input.Direction.Y;
        Steering = input.Direction.X;
        
        // Calculate steering timing values
        if (FPMath.Abs(Steering) < FP._0_05)
        {
            NoSteeringTime += frame.DeltaTime;
            SameSteeringTime = 0;
        }
        else if (FPMath.Sign(Steering) == FPMath.Sign(PreviousSteering))
        {
            SameSteeringTime += frame.DeltaTime;
            NoSteeringTime = 0;
        }
        else
        {
            SameSteeringTime = 0;
            NoSteeringTime = 0;
        }
        
        // Track drift button hold time
        if (Drifting.IsActive)
        {
            DriftingInputTime += frame.DeltaTime;
        }
        else
        {
            DriftingInputTime = 0;
        }
    }
}
```

These timing values are used to determine when drifts should end based on player control.

## Visual Feedback System

The drifting system provides visual feedback through events:

```csharp
// In DriftBoost.Update
frame.Events.DriftBoostCharged(filter.Entity, BoostLevel);
frame.Events.DriftBoostApplied(filter.Entity, BoostLevel);
```

These events are handled on the Unity side to show:
1. **Drift Sparks**: Visual indicators showing drift direction and intensity
2. **Boost Charge**: Color changes indicating boost level
3. **Boost Effect**: Visual and audio feedback when boost is applied

## AI Drifting

AI drivers can also perform drifts using logic in the `AIDriver` component:

```csharp
public void Update(Frame frame, KartSystem.Filter filter, ref Input input)
{
    // Calculate turn angle between current and next waypoint
    FP turnAngle = FPVector3.Angle(toWaypoint, toNextWaypoint);
    
    if (frame.Unsafe.TryGetPointer(filter.Entity, out Drifting* drifting))
    {
        // Start drift on sharp turns
        bool shouldStartDrift = turnAngle >= settings.DriftingAngle && !drifting->IsDrifting;
        
        // End drift when turn smooths out
        bool shouldEndDrift = turnAngle < settings.DriftingStopAngle && drifting->IsDrifting;
        
        // Trigger drift button press when needed
        input.Drift = !drifting->IsDrifting && shouldStartDrift || drifting->IsDrifting && shouldEndDrift;
    }
}
```

AI drivers use the turn angle between waypoints to determine when to drift, mimicking player behavior.

## Drift Parameters Tuning

The drift system can be tuned through several key parameters:

1. **SideAcceleration**: How strong the sideways sliding force is
2. **ForwardFactor**: Balance between sideways and forward motion (0-1)
3. **MaxSteeringOffset**: How much automatic steering is applied during drift
4. **BoostThresholds**: Time thresholds for mini, medium, and super boosts
5. **MinSidewaysSpeedSqr**: Required sideways motion to maintain drift

These parameters can dramatically change the feel of drifting from arcade to simulation.

## Integration with Surface System

Drifting interacts with the surface system:

```csharp
// In CanStartDrift method
if (kart->IsOffroad) { return false; }

// In ShouldEndDrift method
if (kart->IsOffroad) { return true; }
```

This prevents drifting on off-road surfaces, creating strategic track choices.

## Best Practices

1. **Balanced Drift Control**: Make drifting require skill but not be frustratingly difficult
2. **Clear Visual Feedback**: Ensure players understand drift state and boost levels
3. **Surface Integration**: Use surface properties to create interesting drift opportunities
4. **Boost Rewards**: Scale boost rewards with drift difficulty and duration
5. **Deterministic Physics**: Ensure all drift calculations use Quantum's fixed-point math
6. **Input Buffering**: Track input timing to create responsive controls
7. **Testing**: Thoroughly test drift mechanics across different kart types and surfaces

---

# 05-boost-system.md

# Quantum Karts Boost System

This document details the boost system in Quantum Karts, explaining how temporary speed enhancements are implemented, configured, and integrated with other game systems.

## Core Components

The boost system consists of several interrelated components:

### KartBoost Component

The `KartBoost` component is the central element that handles boost application and timing:

```qtn
component KartBoost {
    [ExcludeFromPrototype] AssetRef<BoostConfig> CurrentBoost;
    [ExcludeFromPrototype] FP TimeRemaining;
}
```

Implementation:

```csharp
public unsafe partial struct KartBoost
{
    public void Update(Frame f)
    {
        if (TimeRemaining <= 0)
        {
            return;
        }

        TimeRemaining -= f.DeltaTime;

        if (TimeRemaining <= 0)
        {
            CurrentBoost = null;
        }
    }

    public void StartBoost(Frame f, AssetRef<BoostConfig> config, EntityRef kartEntity)
    {
        BoostConfig boost = f.FindAsset(config);
        CurrentBoost = config;
        TimeRemaining = boost.Duration;

        f.Events.OnBoostStart(kartEntity, this);
    }

    public void Interrupt()
    {
        CurrentBoost = null;
        TimeRemaining = 0;
    }
}
```

### BoostConfig Asset

The `BoostConfig` asset defines the properties of each boost type:

```csharp
public unsafe partial class BoostConfig : AssetObject
{
    public FP Duration;
    public FP AccelerationBonus;
    public FP MaxSpeedBonus;
    
    public Color ExhaustColor;
}
```

Key properties:
- **Duration**: How long the boost lasts
- **AccelerationBonus**: Additional acceleration applied during boost
- **MaxSpeedBonus**: Increase to maximum speed during boost
- **ExhaustColor**: Visual color for exhaust particles

### DriftBoost Component

The `DriftBoost` component integrates drifting with the boost system:

```qtn
component DriftBoost {
    [ExcludeFromPrototype] FP DriftTime;
    [ExcludeFromPrototype] byte BoostLevel;
    [ExcludeFromPrototype] FP BoostVisualFeedback;
    [ExcludeFromPrototype] array<FP>[3] BoostThresholds;
    [ExcludeFromPrototype] array<AssetRef<BoostConfig>>[3] BoostConfigs;
}
```

This tracks drift time and awards different boost levels based on drift duration.

## Boost System Implementation

The boost system is updated through the `BoostSystem` class:

```csharp
public unsafe class BoostSystem : SystemMainThreadFilter<BoostSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public KartBoost* KartBoost;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        filter.KartBoost->Update(frame);
    }
}
```

## Integration with Kart Physics

The boost system is integrated with the kart physics through two key methods in the `Kart` component:

### 1. Acceleration Modification

```csharp
public FP GetAcceleration(Frame frame, EntityRef entity)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    FP bonus = 0;

    if (frame.Unsafe.TryGetPointer(entity, out KartBoost* kartBoost) && kartBoost->CurrentBoost != null)
    {
        BoostConfig config = frame.FindAsset(kartBoost->CurrentBoost);
        bonus += config.AccelerationBonus;
    }

    return stats.acceleration.Evaluate(GetNormalizedSpeed(frame)) * SurfaceSpeedMultiplier + bonus;
}
```

### 2. Max Speed Modification

```csharp
public FP GetMaxSpeed(Frame frame, EntityRef entity)
{
    KartStats stats = frame.FindAsset(StatsAsset);
    FP bonus = 0;

    if (frame.Unsafe.TryGetPointer(entity, out KartBoost* kartBoost) && kartBoost->CurrentBoost != null)
    {
        BoostConfig config = frame.FindAsset(kartBoost->CurrentBoost);
        bonus += config.MaxSpeedBonus;
    }

    return stats.maxSpeed * SurfaceSpeedMultiplier + bonus;
}
```

These methods are called during the kart's physics update to modify acceleration and top speed when a boost is active.

## Boost Sources

There are multiple ways for a kart to receive a boost:

### 1. Drift Boosts

Drift boosts are awarded based on drift duration through the `DriftBoost` component:

```csharp
public unsafe partial struct DriftBoost
{
    public void Update(Frame frame, KartSystem.Filter filter)
    {
        Drifting* drifting = filter.Drifting;
        
        // When drifting, accumulate time and check for boost level upgrades
        if (drifting->IsDrifting)
        {
            DriftTime += frame.DeltaTime;
            
            // Check for boost level upgrades
            for (byte i = 0; i < BoostThresholds.Length; i++)
            {
                if (DriftTime >= BoostThresholds.GetPointer(i)->Value && i > BoostLevel)
                {
                    BoostLevel = i;
                    BoostVisualFeedback = FP._1;
                    frame.Events.DriftBoostCharged(filter.Entity, BoostLevel);
                }
            }
            
            // Fade visual feedback
            if (BoostVisualFeedback > 0)
            {
                BoostVisualFeedback -= frame.DeltaTime * 2;
            }
        }
        // When drifting ends, apply the boost if eligible
        else if (DriftTime > 0)
        {
            if (BoostLevel > 0 && frame.Unsafe.TryGetPointer(filter.Entity, out KartBoost* boost))
            {
                boost->StartBoost(frame, BoostConfigs.GetPointer(BoostLevel - 1)->Value, filter.Entity);
                frame.Events.DriftBoostApplied(filter.Entity, BoostLevel);
            }
            
            // Reset values
            DriftTime = 0;
            BoostLevel = 0;
            BoostVisualFeedback = 0;
        }
    }
}
```

This system:
1. Tracks drift time
2. Updates boost level when thresholds are crossed
3. Applies the appropriate boost when drifting ends
4. Sends events for visual feedback

### 2. Weapon Boosts

The `WeaponBoost` class implements a boost weapon that can be collected and used:

```csharp
public class WeaponBoost : WeaponAsset
{
    public BoostConfig BoostConfig;
    
    public override void Activate(Frame f, EntityRef sourceKartEntity)
    {
        if (f.Unsafe.TryGetPointer(sourceKartEntity, out KartBoost* boost))
        {
            boost->StartBoost(f, f.FindAsset<BoostConfig>(BoostConfig.Id), sourceKartEntity);
        }
    }
    
    public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
    {
        // AI logic for when to use boost weapon
        if (!f.Unsafe.TryGetPointer(aiKartEntity, out Kart* kart)) { return false; }
        
        // Use boost if not at max speed
        return kart->GetNormalizedSpeed(f) < FP._0_90;
    }
}
```

### 3. Track Boost Pads

Boost pads on the track can apply boosts through trigger collisions:

```csharp
public unsafe class BoostPadSystem : SystemSignalsOnly, ISignalOnTriggerEnter3D
{
    public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
    {
        // Check if the collider is a boost pad
        if (!f.Unsafe.TryGetPointer(info.Other, out BoostPad* boostPad)) { return; }
        
        // Check if the entity is a kart
        if (!f.Unsafe.TryGetPointer(info.Entity, out KartBoost* kartBoost)) { return; }
        
        // Apply the boost
        kartBoost->StartBoost(f, boostPad->BoostConfig, info.Entity);
        
        // Trigger visual effect
        f.Events.OnBoostPadHit(info.Entity, info.Other);
    }
}
```

## Visual Feedback

The boost system provides visual feedback through several events:

```csharp
// In KartBoost.StartBoost
f.Events.OnBoostStart(kartEntity, this);

// In DriftBoost.Update
f.Events.DriftBoostCharged(filter.Entity, BoostLevel);
f.Events.DriftBoostApplied(filter.Entity, BoostLevel);

// In BoostPadSystem
f.Events.OnBoostPadHit(info.Entity, info.Other);
```

These events are handled on the Unity side to show:
1. **Exhaust Effects**: Colored flames from the kart's exhaust
2. **Speed Lines**: Camera effect indicating increased speed
3. **Particle Effects**: Trails and sparks showing boost activation

Example Unity handler:

```csharp
public class BoostVisualController : MonoBehaviour
{
    [SerializeField] private ParticleSystem exhaustEffect;
    [SerializeField] private AudioSource boostSound;
    
    private QuantumCallback<EventOnBoostStart> boostStartCallback;
    
    private void OnEnable()
    {
        boostStartCallback = QuantumCallback.Subscribe<EventOnBoostStart>(this, OnBoostStart);
    }
    
    private void OnDisable()
    {
        if (boostStartCallback != null)
        {
            boostStartCallback.Dispose();
            boostStartCallback = null;
        }
    }
    
    private void OnBoostStart(EventOnBoostStart evt)
    {
        if (EntityRef != evt.Entity) { return; }
        
        // Get boost config
        var boostConfig = QuantumRunner.Default.Game.FindAsset<BoostConfig>(evt.KartBoost.CurrentBoost);
        
        // Set exhaust color
        var main = exhaustEffect.main;
        main.startColor = boostConfig.ExhaustColor;
        
        // Play effects
        exhaustEffect.Play();
        boostSound.Play();
    }
}
```

## Boost Types and Configurations

The boost system allows for different boost types through configuration:

### Mini-Boost (Short Drift)
```csharp
// Configuration example
miniBoostConfig.Duration = FP._1;
miniBoostConfig.AccelerationBonus = FP._2;
miniBoostConfig.MaxSpeedBonus = FP._1;
miniBoostConfig.ExhaustColor = new Color(1, 0.5f, 0);
```

### Super-Boost (Long Drift)
```csharp
// Configuration example
superBoostConfig.Duration = FP._3;
superBoostConfig.AccelerationBonus = FP._5;
superBoostConfig.MaxSpeedBonus = FP._3;
superBoostConfig.ExhaustColor = new Color(1, 0, 1);
```

### Pickup Boost
```csharp
// Configuration example
pickupBoostConfig.Duration = FP._5;
pickupBoostConfig.AccelerationBonus = FP._3;
pickupBoostConfig.MaxSpeedBonus = FP._2;
pickupBoostConfig.ExhaustColor = new Color(0, 1, 1);
```

### Boost Pad
```csharp
// Configuration example
boostPadConfig.Duration = FP._2;
boostPadConfig.AccelerationBonus = FP._2;
boostPadConfig.MaxSpeedBonus = FP._2;
boostPadConfig.ExhaustColor = new Color(1, 1, 0);
```

## Boost Stacking Behavior

The boost system handles sequential boosts by interrupting the current boost and starting a new one:

```csharp
public void StartBoost(Frame f, AssetRef<BoostConfig> config, EntityRef kartEntity)
{
    BoostConfig boost = f.FindAsset(config);
    CurrentBoost = config;
    TimeRemaining = boost.Duration;

    f.Events.OnBoostStart(kartEntity, this);
}
```

This simple approach ensures that:
1. Only one boost is active at a time
2. New boosts replace existing ones
3. The most recent boost's properties are applied

## AI Integration

AI drivers can use boosts strategically:

```csharp
public unsafe partial struct AIDriver
{
    // Additional AI weapon usage logic
    private bool ShouldUseBoostWeapon(Frame frame, EntityRef entity)
    {
        if (!frame.Unsafe.TryGetPointer(entity, out Kart* kart)) { return false; }
        
        // Use at start of race
        if (frame.Unsafe.TryGetPointerSingleton(out Race* race) && 
            race->CurrentRaceState == RaceState.Countdown) { return true; }
            
        // Use when not at max speed
        if (kart->GetNormalizedSpeed(frame) < FP._0_75) { return true; }
        
        // Use on straightaways
        if (CurrentTurnAngle < FP._15) { return true; }
        
        return false;
    }
}
```

This allows AI drivers to use boosts in appropriate situations.

## Boost Physics Considerations

When implementing boosts, special care is taken in the physics system:

```csharp
private void LimitVelocity(Frame frame, EntityRef entity)
{
    // No hard clamping so kart doesn't suddenly "hit a wall" when a boost ends
    Velocity = FPVector3.MoveTowards(
        Velocity,
        FPVector3.ClampMagnitude(Velocity, GetMaxSpeed(frame, entity)),
        FP._0_10
    );
}
```

This smooth velocity clamping ensures that:
1. Boosts can exceed normal speed limits
2. When a boost ends, speed decreases gradually
3. The transition feels natural to the player

## Best Practices

1. **Variable Boost Types**: Create different boost configurations for variety
2. **Clear Visual Feedback**: Ensure players understand when boosts are active
3. **Smooth Transitions**: Avoid abrupt speed changes when boosts start/end
4. **Strategic Placement**: Place boost pads at strategic points on tracks
5. **Balance**: Ensure boosts provide meaningful advantages without being overpowered
6. **Compound Systems**: Integrate boosts with other systems like drifting for depth
7. **Deterministic Implementation**: Use Quantum's fixed-point math for consistent network behavior

---

# 06-race-system.md

# Quantum Karts Race System

This document explains the race system in Quantum Karts, covering track definition, checkpoints, race state management, and position tracking that form the core gameplay loop.

## Core Components

The race system consists of several interrelated components:

### Race Component

The `Race` component is the central singleton that manages race state:

```qtn
component Race
{
    [ExcludeFromPrototype] RaceState CurrentRaceState;
    [ExcludeFromPrototype] FrameTimer StateTimer;
    [ExcludeFromPrototype] FP CountdownTime;
    [ExcludeFromPrototype] byte SpawnedAIDrivers;
    [ExcludeFromPrototype] byte PositionCalcInterval;
}
```

### RaceTrack Component

The `RaceTrack` component defines the track layout and checkpoints:

```qtn
component RaceTrack
{
    [ExcludeFromPrototype] byte TotalLaps;
    [ExcludeFromPrototype] list<EntityRef> Checkpoints;
    [ExcludeFromPrototype] array<FPVector3>[16] StartPositions;
    [ExcludeFromPrototype] array<FPQuaternion>[16] StartRotations;
}
```

### Checkpoint Component

The `Checkpoint` component marks important track positions:

```qtn
component Checkpoint
{
    [ExcludeFromPrototype] byte Index;
    [ExcludeFromPrototype] AssetRef<CheckpointConfig> Config;
}
```

### RaceProgress Component

The `RaceProgress` component tracks each kart's progress in the race:

```qtn
component RaceProgress
{
    [ExcludeFromPrototype] byte CurrentLap;
    [ExcludeFromPrototype] byte TargetCheckpointIndex;
    [ExcludeFromPrototype] sbyte CurrentPosition;
    [ExcludeFromPrototype] FP DistanceToCheckpoint;
    [ExcludeFromPrototype] bool Finished;
    [ExcludeFromPrototype] FP FinishTime;
    [ExcludeFromPrototype] FP LapStartTime;
    [ExcludeFromPrototype] FP BestLapTime;
    [ExcludeFromPrototype] list<FP> LapTimes;
    
    byte TotalLaps;
}
```

## Race State Management

The race progresses through several states managed by the `Race` component:

```csharp
public enum RaceState : byte
{
    None = 0,
    Waiting,    // Players joining and getting ready
    Countdown,  // Counting down to race start
    InProgress, // Race is active
    Finishing,  // First player has finished, others can still finish
    Finished    // Race is over, showing results
}

public unsafe partial struct Race
{
    public void Update(Frame frame)
    {
        if (StateTimer.ExpiredOrNotRunning(frame))
        {
            switch (CurrentRaceState)
            {
                case RaceState.Countdown:
                    ChangeState(frame, RaceState.InProgress);
                    frame.Events.OnRaceStarted();
                    break;

                case RaceState.Finishing:
                    ChangeState(frame, RaceState.Finished);
                    frame.Events.OnRaceFinished();
                    break;
            }
        }
        else if (CurrentRaceState == RaceState.Countdown)
        {
            CountdownTime = StateTimer.RemainingTime(frame).AsFloat;
            frame.Events.OnCountdownUpdated(CountdownTime);
        }
    }

    public void ChangeState(Frame frame, RaceState state)
    {
        if (state == CurrentRaceState) { return; }

        var oldState = CurrentRaceState;
        CurrentRaceState = state;

        frame.Signals.RaceStateChanged(state);
        frame.Events.OnRaceStateChanged(oldState, state);

        switch (state)
        {
            case RaceState.Countdown:
                StateTimer = FrameTimer.FromSeconds(frame, frame.RuntimeConfig.CountdownTime);
                CountdownTime = frame.RuntimeConfig.CountdownTime;
                break;

            case RaceState.Finishing:
                StateTimer = FrameTimer.FromSeconds(frame, frame.RuntimeConfig.FinishingTime);
                break;
        }
    }
    
    public bool AllPlayersReady(Frame frame)
    {
        int readyCount = 0;
        int playerCount = 0;

        foreach (var (entity, playerLink) in frame.Unsafe.GetComponentBlockIterator<PlayerLink>())
        {
            playerCount++;
            
            if (playerLink->Ready)
            {
                readyCount++;
            }
        }

        return readyCount == playerCount && playerCount > 0;
    }
}
```

The race lifecycle follows this sequence:
1. **Waiting**: Players connect and select "Ready"
2. **Countdown**: 3-second countdown before race starts
3. **InProgress**: Race is active, karts compete
4. **Finishing**: First player has finished, others have limited time to finish
5. **Finished**: Race is complete, results are shown

## Checkpoint System

The checkpoint system tracks race progress and ensures karts follow the correct path:

```csharp
public unsafe partial struct RaceProgress
{
    public void Initialize(byte totalLaps)
    {
        TotalLaps = totalLaps;
        CurrentLap = 1;
        TargetCheckpointIndex = 0;
        CurrentPosition = -1;
        Finished = false;
    }

    public bool CheckpointReached(Frame frame, Checkpoint* checkpoint, EntityRef kartEntity, out bool lapCompleted)
    {
        lapCompleted = false;

        // Skip if not the target checkpoint
        if (checkpoint->Index != TargetCheckpointIndex)
        {
            return false;
        }

        // Update to next checkpoint
        if (frame.Unsafe.TryGetPointerSingleton(out RaceTrack* track))
        {
            byte nextCheckpoint = (byte)((checkpoint->Index + 1) % track->GetCheckpoints(frame).Count);
            
            // Complete lap if crossing finish line (checkpoint 0)
            if (nextCheckpoint == 0)
            {
                FP lapTime = frame.Time - LapStartTime;
                LapTimes.Add(frame, lapTime);
                
                if (BestLapTime <= 0 || lapTime < BestLapTime)
                {
                    BestLapTime = lapTime;
                }
                
                lapCompleted = true;
                LapStartTime = frame.Time;
                CurrentLap++;
                
                // Check for race finish
                if (CurrentLap > TotalLaps)
                {
                    Finished = true;
                    FinishTime = frame.Time;
                }
            }
            
            TargetCheckpointIndex = nextCheckpoint;
        }
        
        return true;
    }

    public void UpdateDistanceToCheckpoint(Frame frame, EntityRef kart, RaceTrack* track)
    {
        if (Finished) { return; }
        
        // Get the target checkpoint entity
        var checkpoints = track->GetCheckpoints(frame);
        var checkpointEntity = checkpoints[TargetCheckpointIndex];
        
        // Get transform components
        if (frame.Unsafe.TryGetPointer(checkpointEntity, out Transform3D* checkpointTransform) && 
            frame.Unsafe.TryGetPointer(kart, out Transform3D* kartTransform))
        {
            // Calculate distance to checkpoint
            FPVector3 checkpointCenter = checkpointTransform->Position;
            DistanceToCheckpoint = FPVector3.Distance(kartTransform->Position, checkpointCenter);
        }
    }

    public void Update(Frame frame, KartSystem.Filter filter)
    {
        // Update is called every frame on the kart
    }

    public FP GetFinishTime()
    {
        return Finished ? FinishTime : FP._0;
    }

    public void SetRacePosition(sbyte position)
    {
        if (position != CurrentPosition)
        {
            CurrentPosition = position;
        }
    }
}
```

Key aspects of the checkpoint system:
1. Checkpoints must be hit in sequence
2. Crossing the finish line (checkpoint 0) completes a lap
3. Distance to the next checkpoint is used for position calculation
4. Lap times are recorded for each completed lap

## Position Calculation

Race positions are calculated at regular intervals by the `RaceSystem`:

```csharp
private void UpdatePositions(Frame f)
{
    Race* race = f.Unsafe.GetPointerSingleton<Race>();

    if (f.Number % race->PositionCalcInterval != 0) { return; }

    ProgressWrappers.Clear();

    f.Unsafe.TryGetPointerSingleton(out RaceTrack* raceTrack);

    // Collect all racers and update their distance to next checkpoint
    foreach (var pair in f.Unsafe.GetComponentBlockIterator<RaceProgress>())
    {
        pair.Component->UpdateDistanceToCheckpoint(f, pair.Entity, raceTrack);
        ProgressWrappers.Add(new() { RaceProgress = pair.Component, Entity = pair.Entity });
    }

    // Sort racers by progress
    ProgressWrappers.Sort(raceProgressComparer);

    // Assign positions
    for (int i = 0; i < ProgressWrappers.Count; i++)
    {
        ProgressWrappers[i].RaceProgress->SetRacePosition((sbyte)(i + 1));
    }

    f.Events.OnPositionsUpdated();
}
```

The position calculation logic is in the `RaceProgressComparer`:

```csharp
private class RaceProgressComparer : IComparer<ProgressWrapper>
{
    int IComparer<ProgressWrapper>.Compare(ProgressWrapper A, ProgressWrapper B)
    {
        FP aTime = A.RaceProgress->GetFinishTime();
        FP bTime = B.RaceProgress->GetFinishTime();

        // both finished
        if (aTime > 0 && bTime > 0)
            return aTime.CompareTo(bTime);

        // other finished
        if (aTime > 0 != bTime > 0)
            return aTime > 0 ? -1 : 1;

        // negate lap and checkpoint index comparisons because higher better
        int lapResult = A.RaceProgress->CurrentLap.CompareTo(B.RaceProgress->CurrentLap);
        if (lapResult != 0) return -lapResult;

        int checkpointResult = A.RaceProgress->TargetCheckpointIndex.CompareTo(B.RaceProgress->TargetCheckpointIndex);
        if (checkpointResult != 0) return -checkpointResult;

        int distanceResult = A.RaceProgress->DistanceToCheckpoint.CompareTo(B.RaceProgress->DistanceToCheckpoint);
        return distanceResult != 0 ? distanceResult : -1;
    }
}
```

This sorting logic prioritizes:
1. Finished racers (by finish time)
2. Current lap (higher is better)
3. Current checkpoint (higher is better)
4. Distance to next checkpoint (lower is better)

## Checkpoint Detection

Checkpoints are detected using Quantum's trigger system:

```csharp
public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
{
    if (f.Unsafe.TryGetPointer<RaceProgress>(info.Entity, out var playerProgress) == false)
        return;

    if (f.Unsafe.TryGetPointer<Checkpoint>(info.Other, out var checkpoint) == false)
        return;

    Race* race = f.Unsafe.GetPointerSingleton<Race>();
    f.Unsafe.TryGetPointerSingleton<RaceTrack>(out RaceTrack* track);

    bool alreadyFinished = playerProgress->Finished;

    if (playerProgress->CheckpointReached(f, checkpoint, info.Entity, out bool lapCompleted))
    {
        if (f.Unsafe.TryGetPointer(info.Entity, out AIDriver* drivingAI))
        {
            drivingAI->UpdateTarget(f, info.Entity);
        }
    }

    if (alreadyFinished)
    {
        return;
    }

    if (lapCompleted) { f.Events.OnPlayerCompletedLap(info.Entity); }

    if (playerProgress->Finished)
    {
        f.Events.OnPlayerFinished(info.Entity);
        f.Signals.PlayerFinished(info.Entity);
    }

    if (playerProgress->Finished && race->CurrentRaceState == RaceState.InProgress)
    {
        FirstPlayerFinished(f, info.Entity);
    }
}

private void FirstPlayerFinished(Frame f, EntityRef kartEntity)
{
    Race* race = f.Unsafe.GetPointerSingleton<Race>();
    race->ChangeState(f, RaceState.Finishing);
    race->StateTimer = FrameTimer.FromSeconds(f, f.RuntimeConfig.FinishingTime);
    f.Events.OnFirstPlayerFinish(kartEntity);
}
```

This system:
1. Detects when karts pass through checkpoint triggers
2. Updates progress tracking
3. Handles lap completion
4. Manages race completion when the final lap is finished

## Track Definition

Tracks are defined through the `RaceTrack` component, which includes:

```csharp
public unsafe partial struct RaceTrack
{
    public QList<EntityRef> GetCheckpoints(Frame frame)
    {
        return frame.ResolveList(Checkpoints);
    }
    
    public void GetStartPosition(Frame frame, int index, out FPVector3 position, out FPQuaternion rotation)
    {
        index = FPMath.Clamp(index, 0, StartPositions.Length - 1);
        
        position = StartPositions.GetPointer(index)->Value;
        rotation = StartRotations.GetPointer(index)->Value;
    }
    
    public FPVector3 GetCheckpointTargetPosition(Frame frame, int checkpointIndex, int difficultyLevel)
    {
        var checkpoints = GetCheckpoints(frame);
        var checkpoint = checkpoints[checkpointIndex % checkpoints.Count];
        
        if (frame.Unsafe.TryGetPointer(checkpoint, out Transform3D* transform) && 
            frame.Unsafe.TryGetPointer(checkpoint, out Checkpoint* checkpointComp))
        {
            var config = frame.FindAsset(checkpointComp->Config);
            
            // Get position offset based on difficulty
            FPVector3 offset = config.GetAITargetOffset(difficultyLevel);
            
            return transform->Position + transform->TransformDirection(offset);
        }
        
        return FPVector3.Zero;
    }
}
```

The track definition includes:
1. An ordered list of checkpoint entities
2. Start positions for each kart
3. Target racing lines for AI drivers of different skill levels

## Race Events

The race system communicates with the Unity view through several events:

```csharp
// Race state events
frame.Events.OnRaceStateChanged(oldState, state);
frame.Events.OnRaceStarted();
frame.Events.OnRaceFinished();
frame.Events.OnCountdownUpdated(CountdownTime);

// Player events
frame.Events.OnPlayerCompletedLap(info.Entity);
frame.Events.OnPlayerFinished(info.Entity);
frame.Events.OnFirstPlayerFinish(kartEntity);
frame.Events.OnPositionsUpdated();
```

These events are handled by Unity components to update:
1. UI elements (countdown, position display, lap counter)
2. Camera behavior
3. Music and sound effects
4. Post-race results screen

## Respawn System

The race system includes a respawn mechanism for karts that go off-track or get stuck:

```csharp
public unsafe class RespawnSystem : SystemMainThreadFilter<RespawnSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public RespawnMover* RespawnMover;
        public Transform3D* Transform3D;
        public RaceProgress* RaceProgress;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Find track and get current checkpoint
        if (!frame.Unsafe.TryGetPointerSingleton(out RaceTrack* track))
            return;

        byte checkpointIndex = filter.RaceProgress->TargetCheckpointIndex;
        
        // Get previous checkpoint (for respawn position)
        int prevIndex = checkpointIndex - 1;
        if (prevIndex < 0)
        {
            var checkpoints = track->GetCheckpoints(frame);
            prevIndex = checkpoints.Count - 1;
        }
        
        // Get respawn position and rotation
        FPVector3 respawnPos = FPVector3.Zero;
        FPQuaternion respawnRot = FPQuaternion.Identity;
        
        var checkpoints = track->GetCheckpoints(frame);
        var checkpointEntity = checkpoints[prevIndex];
        
        if (frame.Unsafe.TryGetPointer(checkpointEntity, out Transform3D* checkpointTransform) &&
            frame.Unsafe.TryGetPointer(checkpointEntity, out Checkpoint* checkpoint))
        {
            var config = frame.FindAsset(checkpoint->Config);
            
            // Get respawn transforms
            respawnPos = checkpointTransform->Position + checkpointTransform->TransformDirection(config.RespawnOffset);
            respawnRot = checkpointTransform->Rotation * config.RespawnRotation;
        }
        
        // Apply respawn
        filter.Transform3D->Position = respawnPos;
        filter.Transform3D->Rotation = respawnRot;
        
        // Reset physics
        if (frame.Unsafe.TryGetPointer(filter.Entity, out Kart* kart))
        {
            kart->Velocity = FPVector3.Zero;
            kart->ExternalForce = FPVector3.Zero;
        }
        
        // Add temporary invulnerability
        frame.Add<Invulnerable>(filter.Entity);
        
        // Remove respawn component
        frame.Remove<RespawnMover>(filter.Entity);
        
        // Send event
        frame.Events.OnKartRespawned(filter.Entity);
    }
}
```

This system:
1. Places karts at the last checkpoint they passed
2. Resets physics state
3. Adds temporary invulnerability
4. Can be triggered manually (respawn button) or automatically (stuck detection)

## Track Decoration

While not directly part of the race mechanics, tracks include various decorative and functional elements:

1. **Surfaces**: Different driving surfaces with unique physics properties
2. **Decoration**: Static meshes like trees, barriers, and scenery
3. **Boost Pads**: Special triggers that give karts a temporary boost
4. **Jump Pads**: Launch karts into the air
5. **Hazards**: Moving or static obstacles

These are all synchronized within the Quantum simulation to ensure deterministic behavior.

## Best Practices

1. **Clear Checkpoint Placement**: Position checkpoints to create a clear racing path
2. **Equal Start Positions**: Balance starting positions for fairness
3. **Deterministic Triggers**: Use Quantum's trigger system for consistent checkpoint detection
4. **Regular Position Updates**: Calculate positions at fixed intervals to save performance
5. **Responsive Respawn**: Place respawn points to minimize player frustration
6. **Multiple Race States**: Use distinct states to manage the race lifecycle
7. **Completion Timeout**: Give slower players a chance to finish after the winner

---

# 07-weapon-system.md

# Quantum Karts Weapon System

This document details the weapon system in Quantum Karts, explaining how weapons are acquired, stored, and used by players to gain advantages during races.

## Core Components

The weapon system consists of several interconnected components:

### KartWeapons Component

The `KartWeapons` component is attached to karts to manage their current weapon:

```qtn
component KartWeapons {
    [ExcludeFromPrototype] AssetRef<WeaponAsset> HeldWeapon;
    [ExcludeFromPrototype] byte RemainingUses;
}
```

Implementation:

```csharp
public unsafe partial struct KartWeapons
{
    public void GiveWeapon(Frame f, EntityRef entity, AssetRef<WeaponAsset> weaponAsset)
    {
        if (HeldWeapon != null)
        {
            // don't replace weapons
            return;
        }

        HeldWeapon = weaponAsset;
        RemainingUses = f.FindAsset(HeldWeapon).Uses;

        f.Events.WeaponCollected(entity, this);
    }

    public void UseWeapon(Frame f, KartSystem.Filter filter)
    {
        if (HeldWeapon == null)
        {
            return;
        }

        f.FindAsset(HeldWeapon).Activate(f, filter.Entity);

        if (--RemainingUses <= 0)
        {
            RemoveWeapon();
        }

        f.Events.WeaponUsed(filter.Entity, this);
    }

    public void RemoveWeapon()
    {
        HeldWeapon = null;
    }
}
```

### WeaponAsset Base Class

The `WeaponAsset` class is the base for all weapon types:

```csharp
public abstract partial class WeaponAsset : AssetObject
{
    [Header("Unity")]
    public Sprite WeaponSprite;
    public string WeaponName;

    /// <summary>
    /// How many times weapon can be used in total
    /// </summary>
    [Header("Quantum")]
    public byte Uses = 1;

    /// <summary>
    /// Activates the weapon
    /// </summary>
    /// <param name="f">Game frame</param>
    /// <param name="sourceKartEntity">Kart entity which used the weapon</param>
    public abstract void Activate(Frame f, EntityRef sourceKartEntity);

    /// <summary>
    /// Contains weapon specific AI behaviour
    /// </summary>
    /// <param name="f">Game frame</param>
    /// <param name="aiKartEntity">AI kart entity</param>
    /// <returns>Whether or not the AI driver should activate the weapon this frame</returns>
    public abstract bool AIShouldUse(Frame f, EntityRef aiKartEntity);
}
```

### WeaponPickup Component

The `WeaponPickup` component is attached to item boxes on the track:

```qtn
component WeaponPickup {
    [ExcludeFromPrototype] FP RespawnTimer;
    [ExcludeFromPrototype] bool Active;
    AssetRef<WeaponSelection> WeaponSelectionAsset;
}
```

Implementation:

```csharp
public unsafe partial struct WeaponPickup
{
    public void Collect(Frame f, EntityRef kartEntity)
    {
        if (!Active) { return; }
        
        // Check if kart can receive weapon
        if (!f.Unsafe.TryGetPointer(kartEntity, out KartWeapons* weapons)) { return; }
        if (weapons->HeldWeapon != null) { return; }
        
        // Get weapon selection asset
        var weaponSelection = f.FindAsset(WeaponSelectionAsset);
        
        // Select a weapon based on kart position
        AssetRef<WeaponAsset> selectedWeapon = SelectWeapon(f, kartEntity, weaponSelection);
        
        // Give weapon to kart
        weapons->GiveWeapon(f, kartEntity, selectedWeapon);
        
        // Deactivate pickup and start respawn timer
        Active = false;
        RespawnTimer = weaponSelection.RespawnTime;
        
        // Send event
        f.Events.WeaponPickupCollected(kartEntity);
    }
    
    private AssetRef<WeaponAsset> SelectWeapon(Frame f, EntityRef kartEntity, WeaponSelection selection)
    {
        // Get kart's race position
        sbyte position = sbyte.MaxValue;
        if (f.Unsafe.TryGetPointer(kartEntity, out RaceProgress* progress))
        {
            position = progress->CurrentPosition;
        }
        
        // Select weapon based on position
        if (position <= 3)
        {
            // Front positions get defensive weapons
            return selection.GetWeaponFromCategory(f, WeaponCategory.Defensive);
        }
        else if (position >= 6)
        {
            // Back positions get catch-up weapons
            return selection.GetWeaponFromCategory(f, WeaponCategory.CatchUp);
        }
        else
        {
            // Middle positions get balanced weapons
            return selection.GetWeaponFromCategory(f, WeaponCategory.Balanced);
        }
    }
    
    public void Update(Frame f)
    {
        if (!Active && RespawnTimer > 0)
        {
            RespawnTimer -= f.DeltaTime;
            
            if (RespawnTimer <= 0)
            {
                Active = true;
                f.Events.WeaponPickupRespawned(f.FindEntityRef(this));
            }
        }
    }
}
```

### WeaponSelection Asset

The `WeaponSelection` asset defines weapon distribution and probabilities:

```csharp
public partial class WeaponSelection : AssetObject
{
    public FP RespawnTime = 5;
    
    [Header("Defensive Weapons")]
    public List<WeaponProbability> DefensiveWeapons = new();
    
    [Header("Balanced Weapons")]
    public List<WeaponProbability> BalancedWeapons = new();
    
    [Header("Catch-up Weapons")]
    public List<WeaponProbability> CatchUpWeapons = new();
    
    [Serializable]
    public class WeaponProbability
    {
        public AssetRef<WeaponAsset> Weapon;
        public FP Probability;
    }
    
    public AssetRef<WeaponAsset> GetWeaponFromCategory(Frame f, WeaponCategory category)
    {
        List<WeaponProbability> weapons;
        
        switch (category)
        {
            case WeaponCategory.Defensive:
                weapons = DefensiveWeapons;
                break;
            case WeaponCategory.CatchUp:
                weapons = CatchUpWeapons;
                break;
            default:
                weapons = BalancedWeapons;
                break;
        }
        
        // Calculate total probability
        FP totalProb = FP._0;
        foreach (var weapon in weapons)
        {
            totalProb += weapon.Probability;
        }
        
        // Generate random number
        FP rand = f.RNG->NextFP(FP._0, totalProb);
        
        // Select weapon based on probability
        FP currentProb = FP._0;
        foreach (var weapon in weapons)
        {
            currentProb += weapon.Probability;
            
            if (rand <= currentProb)
            {
                return weapon.Weapon;
            }
        }
        
        // Fallback to first weapon
        return weapons[0].Weapon;
    }
}

public enum WeaponCategory
{
    Defensive,
    Balanced,
    CatchUp
}
```

## Weapon Types

Quantum Karts implements several weapon types, all derived from the `WeaponAsset` base class:

### Boost Weapon

```csharp
public class WeaponBoost : WeaponAsset
{
    public BoostConfig BoostConfig;
    
    public override void Activate(Frame f, EntityRef sourceKartEntity)
    {
        if (f.Unsafe.TryGetPointer(sourceKartEntity, out KartBoost* boost))
        {
            boost->StartBoost(f, f.FindAsset<BoostConfig>(BoostConfig.Id), sourceKartEntity);
        }
    }
    
    public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
    {
        // AI logic for when to use boost weapon
        if (!f.Unsafe.TryGetPointer(aiKartEntity, out Kart* kart)) { return false; }
        
        // Use boost if not at max speed
        return kart->GetNormalizedSpeed(f) < FP._0_90;
    }
}
```

### Shield Weapon

```csharp
public class WeaponShield : WeaponAsset
{
    public FP Duration = 5;
    
    public override void Activate(Frame f, EntityRef sourceKartEntity)
    {
        // Add shield component with duration
        var shield = new Shield { Duration = Duration };
        f.Add(sourceKartEntity, shield);
        
        f.Events.ShieldActivated(sourceKartEntity, Duration);
    }
    
    public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
    {
        // Activate shield when an incoming hazard is detected
        if (f.Unsafe.TryGetPointer(aiKartEntity, out KartHitReceiver* receiver))
        {
            return receiver->IncomingHazardDetected;
        }
        
        return false;
    }
}
```

### Hazard Spawner Weapon

```csharp
public class WeaponHazardSpawner : WeaponAsset
{
    public AssetRef<EntityPrototype> HazardPrototype;
    public FP SpawnOffset = 2;
    public bool SpawnBehind = false;
    
    public override void Activate(Frame f, EntityRef sourceKartEntity)
    {
        if (!f.Unsafe.TryGetPointer(sourceKartEntity, out Transform3D* transform))
        {
            return;
        }
        
        // Calculate spawn position
        FPVector3 direction = SpawnBehind ? -transform->Forward : transform->Forward;
        FPVector3 spawnPosition = transform->Position + direction * SpawnOffset;
        
        // Create hazard entity
        EntityRef hazard = f.Create(HazardPrototype);
        
        // Set hazard position and properties
        if (f.Unsafe.TryGetPointer(hazard, out Transform3D* hazardTransform))
        {
            hazardTransform->Position = spawnPosition;
            hazardTransform->Rotation = transform->Rotation;
        }
        
        // Link hazard to the kart that spawned it
        if (f.Unsafe.TryGetPointer(hazard, out Hazard* hazardComp))
        {
            hazardComp->SourceKart = sourceKartEntity;
        }
        
        f.Events.HazardSpawned(sourceKartEntity, hazard);
    }
    
    public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
    {
        // Use offensive weapons when there's a kart ahead
        if (SpawnBehind)
        {
            // Use defensive weapons when there's a kart behind
            return f.Unsafe.TryGetPointer(aiKartEntity, out AIDriver* driver) && 
                   driver->KartBehindDistance < FP._10;
        }
        else
        {
            return f.Unsafe.TryGetPointer(aiKartEntity, out AIDriver* driver) && 
                   driver->KartAheadDistance < FP._10;
        }
    }
}
```

## Weapon Collection and Usage

The weapon flow consists of several steps:

### 1. Weapon Pickup Collection

Weapons are collected when karts drive through weapon pickup boxes:

```csharp
public unsafe class WeaponPickupSystem : SystemMainThreadFilter<WeaponPickupSystem.Filter>, ISignalOnTriggerEnter3D
{
    public struct Filter
    {
        public EntityRef Entity;
        public WeaponPickup* WeaponPickup;
    }
    
    public override void Update(Frame frame, ref Filter filter)
    {
        // Update pickup respawn timer
        filter.WeaponPickup->Update(frame);
    }
    
    public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
    {
        // Check if trigger is a weapon pickup
        if (!f.Unsafe.TryGetPointer(info.Other, out WeaponPickup* pickup))
        {
            return;
        }
        
        // Try to give weapon to kart
        pickup->Collect(f, info.Entity);
    }
}
```

### 2. Weapon Activation

Weapons are activated when the player presses the weapon button:

```csharp
// In KartSystem.Update
if (input.Powerup.WasPressed && frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
{
    weapons->UseWeapon(frame, filter);
}
```

### 3. Weapon Effects

Each weapon type implements its own effects through the `Activate` method:

```csharp
// Example from WeaponBoost
public override void Activate(Frame f, EntityRef sourceKartEntity)
{
    if (f.Unsafe.TryGetPointer(sourceKartEntity, out KartBoost* boost))
    {
        boost->StartBoost(f, f.FindAsset<BoostConfig>(BoostConfig.Id), sourceKartEntity);
    }
}
```

## Hazard System

Many weapons create hazards that can affect other karts:

### Hazard Component

```qtn
component Hazard {
    [ExcludeFromPrototype] EntityRef SourceKart;
    [ExcludeFromPrototype] FP Lifetime;
    
    FP MaxLifetime;
    FP Damage;
    bool AffectsSource;
}
```

Implementation:

```csharp
public unsafe partial struct Hazard
{
    public void Update(Frame f)
    {
        Lifetime += f.DeltaTime;
        
        if (Lifetime >= MaxLifetime)
        {
            // Destroy hazard when lifetime expires
            f.Destroy(f.FindEntityRef(this));
        }
    }
    
    public bool CanAffectKart(EntityRef kartEntity)
    {
        // Prevent hazard from affecting its source unless allowed
        return AffectsSource || kartEntity != SourceKart;
    }
}
```

### Hazard System

```csharp
public unsafe class HazardSystem : SystemMainThreadFilter<HazardSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Hazard* Hazard;
    }
    
    public override void Update(Frame frame, ref Filter filter)
    {
        // Update hazard lifetime
        filter.Hazard->Update(frame);
    }
}
```

### Hazard Collision Detection

```csharp
public unsafe class HazardCollisionSystem : SystemSignalsOnly, ISignalOnTriggerEnter3D
{
    public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
    {
        // Check if collision involves a hazard
        if (!f.Unsafe.TryGetPointer(info.Other, out Hazard* hazard))
        {
            return;
        }
        
        // Check if collision is with a kart
        if (!f.Unsafe.TryGetPointer(info.Entity, out KartHitReceiver* hitReceiver))
        {
            return;
        }
        
        // Check if hazard can affect this kart
        if (!hazard->CanAffectKart(info.Entity))
        {
            return;
        }
        
        // Apply hazard effect
        hitReceiver->ApplyHit(f, info.Entity, hazard->Damage);
        
        // Destroy hazard after hit (if it's a one-time effect)
        f.Destroy(info.Other);
        
        // Send event
        f.Events.HazardHitKart(info.Entity, info.Other);
    }
}
```

## Hit Reception System

Karts use a `KartHitReceiver` component to handle being hit by hazards:

```qtn
component KartHitReceiver {
    [ExcludeFromPrototype] FP HitTimer;
    [ExcludeFromPrototype] FP InvulnerabilityTimer;
    [ExcludeFromPrototype] bool IncomingHazardDetected;
}
```

Implementation:

```csharp
public unsafe partial struct KartHitReceiver
{
    public void Update(Frame frame, KartSystem.Filter filter)
    {
        // Update hit recovery timer
        if (HitTimer > 0)
        {
            HitTimer -= frame.DeltaTime;
        }
        
        // Update invulnerability timer
        if (InvulnerabilityTimer > 0)
        {
            InvulnerabilityTimer -= frame.DeltaTime;
        }
        
        // Reset incoming hazard detection
        IncomingHazardDetected = false;
    }
    
    public void ApplyHit(Frame frame, EntityRef kartEntity, FP damage)
    {
        // Skip if invulnerable
        if (InvulnerabilityTimer > 0)
        {
            return;
        }
        
        // Check for shield protection
        if (frame.Unsafe.TryGetPointer(kartEntity, out Shield* shield))
        {
            // Shield blocks the hit
            frame.Remove<Shield>(kartEntity);
            frame.Events.ShieldBlocked(kartEntity);
            return;
        }
        
        // Apply hit effect
        HitTimer = damage;
        
        // Add brief invulnerability to prevent multiple hits
        InvulnerabilityTimer = FP._1;
        
        // Apply velocity reduction
        if (frame.Unsafe.TryGetPointer(kartEntity, out Kart* kart))
        {
            kart->Velocity *= FP._0_25;
        }
        
        // Send hit event
        frame.Events.KartHit(kartEntity, damage);
    }
}
```

## Shield System

The shield system provides temporary protection against hazards:

```qtn
component Shield {
    [ExcludeFromPrototype] FP Duration;
    [ExcludeFromPrototype] FP RemainingTime;
}
```

Implementation:

```csharp
public unsafe class ShieldSystem : SystemMainThreadFilter<ShieldSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Shield* Shield;
    }
    
    public override void Update(Frame frame, ref Filter filter)
    {
        filter.Shield->RemainingTime += frame.DeltaTime;
        
        if (filter.Shield->RemainingTime >= filter.Shield->Duration)
        {
            frame.Remove<Shield>(filter.Entity);
            frame.Events.ShieldExpired(filter.Entity);
        }
    }
}
```

## Weapon Selection Logic

Weapons are distributed based on race position to create rubber-banding effects:

```csharp
private AssetRef<WeaponAsset> SelectWeapon(Frame f, EntityRef kartEntity, WeaponSelection selection)
{
    // Get kart's race position
    sbyte position = sbyte.MaxValue;
    if (f.Unsafe.TryGetPointer(kartEntity, out RaceProgress* progress))
    {
        position = progress->CurrentPosition;
    }
    
    // Select weapon based on position
    if (position <= 3)
    {
        // Front positions get defensive weapons
        return selection.GetWeaponFromCategory(f, WeaponCategory.Defensive);
    }
    else if (position >= 6)
    {
        // Back positions get catch-up weapons
        return selection.GetWeaponFromCategory(f, WeaponCategory.CatchUp);
    }
    else
    {
        // Middle positions get balanced weapons
        return selection.GetWeaponFromCategory(f, WeaponCategory.Balanced);
    }
}
```

The rubber-banding is further enhanced by weapon category definitions:

- **Defensive Weapons**: Shields, backward projectiles, oil slicks
- **Balanced Weapons**: Speed boosts, standard projectiles
- **Catch-up Weapons**: Super speed boosts, homing projectiles, lightning

## AI Weapon Usage

AI drivers make strategic decisions about when to use weapons:

```csharp
// In AIDriver.Update
if (frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
{
    LastWeaponTime += frame.DeltaTime;
    
    if (weapons->HeldWeapon != default
        && LastWeaponTime > FP._0_50
        && frame.FindAsset(weapons->HeldWeapon).AIShouldUse(frame, filter.Entity))
    {
        input.Powerup = true;
    }
}
```

Each weapon type implements its own AI usage logic:

```csharp
// Example from WeaponBoost
public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
{
    // AI logic for when to use boost weapon
    if (!f.Unsafe.TryGetPointer(aiKartEntity, out Kart* kart)) { return false; }
    
    // Use boost if not at max speed
    return kart->GetNormalizedSpeed(f) < FP._0_90;
}

// Example from WeaponShield
public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
{
    // Activate shield when an incoming hazard is detected
    if (f.Unsafe.TryGetPointer(aiKartEntity, out KartHitReceiver* receiver))
    {
        return receiver->IncomingHazardDetected;
    }
    
    return false;
}
```

## Visual Feedback

The weapon system provides visual feedback through several events:

```csharp
// Weapon collection and use
f.Events.WeaponCollected(entity, this);
f.Events.WeaponUsed(filter.Entity, this);

// Pickup box events
f.Events.WeaponPickupCollected(kartEntity);
f.Events.WeaponPickupRespawned(f.FindEntityRef(this));

// Hazard events
f.Events.HazardSpawned(sourceKartEntity, hazard);
f.Events.HazardHitKart(info.Entity, info.Other);

// Shield events
f.Events.ShieldActivated(sourceKartEntity, Duration);
f.Events.ShieldBlocked(kartEntity);
f.Events.ShieldExpired(filter.Entity);

// Hit events
f.Events.KartHit(kartEntity, damage);
```

Example Unity handler for weapon display:

```csharp
public class WeaponDisplayUI : MonoBehaviour
{
    [SerializeField] private Image weaponIcon;
    [SerializeField] private Text weaponName;
    
    private QuantumCallback<EventWeaponCollected> weaponCollectedCallback;
    private QuantumCallback<EventWeaponUsed> weaponUsedCallback;
    
    private void OnEnable()
    {
        weaponCollectedCallback = QuantumCallback.Subscribe<EventWeaponCollected>(this, OnWeaponCollected);
        weaponUsedCallback = QuantumCallback.Subscribe<EventWeaponUsed>(this, OnWeaponUsed);
    }
    
    private void OnDisable()
    {
        if (weaponCollectedCallback != null)
        {
            weaponCollectedCallback.Dispose();
            weaponCollectedCallback = null;
        }
        
        if (weaponUsedCallback != null)
        {
            weaponUsedCallback.Dispose();
            weaponUsedCallback = null;
        }
    }
    
    private void OnWeaponCollected(EventWeaponCollected evt)
    {
        // Only show for local player
        if (evt.Entity != LocalPlayerManager.Instance.LocalPlayerKartEntity) { return; }
        
        // Get weapon asset
        var weapon = QuantumRunner.Default.Game.FindAsset<WeaponAsset>(evt.Weapons.HeldWeapon);
        
        // Update UI
        weaponIcon.sprite = weapon.WeaponSprite;
        weaponName.text = weapon.WeaponName;
        weaponIcon.gameObject.SetActive(true);
    }
    
    private void OnWeaponUsed(EventWeaponUsed evt)
    {
        // Only handle for local player
        if (evt.Entity != LocalPlayerManager.Instance.LocalPlayerKartEntity) { return; }
        
        // Hide weapon icon if no uses left
        if (evt.Weapons.RemainingUses <= 0)
        {
            weaponIcon.gameObject.SetActive(false);
        }
    }
}
```

## Best Practices

1. **Weapon Balance**: Create a mix of offensive, defensive, and utility weapons
2. **Position-Based Distribution**: Provide stronger catch-up weapons to racers in the back
3. **Clear Visual Feedback**: Ensure players understand what weapons they have and when they're affected
4. **AI Strategy**: Give AI drivers strategic weapon usage behaviors
5. **Feedback Events**: Use events to synchronize visual and audio effects with weapon actions
6. **Weapon Categories**: Group weapons into categories for balanced distribution
7. **Deterministic RNG**: Use Quantum's deterministic random number generator for weapon selection
8. **Invulnerability Periods**: Prevent chain-stunning with brief invulnerability after hits

---

# 08-ai-system.md

# Quantum Karts AI System

This document explains the AI driver system in Quantum Karts, covering how computer-controlled karts navigate the track, make racing decisions, and provide challenging opponents for players.

## Core Components

The AI system consists of several interconnected components:

### AIDriver Component

The `AIDriver` component is the central element that controls computer-driven karts:

```qtn
component AIDriver {
    [ExcludeFromPrototype] FP StationaryTime;
    [ExcludeFromPrototype] FP LastWeaponTime;
    [ExcludeFromPrototype] FPVector3 TargetLocation;
    [ExcludeFromPrototype] FPVector3 NextTargetLocation;
    [ExcludeFromPrototype] FP KartAheadDistance;
    [ExcludeFromPrototype] FP KartBehindDistance;
    [ExcludeFromPrototype] byte AIIndex;
    
    asset_ref<AIDriverSettings> SettingsRef;
}
```

### AIDriverSettings Asset

The `AIDriverSettings` asset defines the behavior characteristics of AI drivers:

```csharp
public unsafe partial class AIDriverSettings : AssetObject
{
    [Header("Race Data")]
    public AssetRef<KartStats> KartStats;
    public AssetRef<KartVisuals> KartVisuals;
    
    [Header("AI Behavior")]
    [Range(0, 5)]
    public int Difficulty = 2;
    
    public FP PredictionRange = 5;
    public FP DriftingAngle = 45;
    public FP DriftingStopAngle = 15;
    
    public FPAnimationCurve SteeringCurve;
    
    [Header("Weapon Usage")]
    public FP WeaponUseChance = FP._0_75;
    public FP MinWeaponInterval = 1;
}
```

## AI Driver Implementation

The core AI logic is implemented in the `AIDriver` component's `Update` method:

```csharp
public unsafe partial struct AIDriver
{
    public void Update(Frame frame, KartSystem.Filter filter, ref Input input)
    {
        AIDriverSettings settings = frame.FindAsset(SettingsRef);

        // Calculate distances between current target and next target
        FP distance = FPVector3.Distance(TargetLocation, filter.Transform3D->Position);
        FP distanceNext = FPVector3.Distance(TargetLocation, NextTargetLocation);
        
        // Calculate how much to look ahead based on settings
        FP predictionAmount = FPMath.InverseLerp(distance, distanceNext, settings.PredictionRange);

        // Calculate direction vectors
        FPVector3 toWaypoint = TargetLocation - filter.Transform3D->Position;
        FPVector3 toNextWaypoint = NextTargetLocation - filter.Transform3D->Position;

        // Remove vertical component for 2D steering calculations
        FPVector3 flatVelocity = filter.Kart->Velocity;
        flatVelocity.Y = 0;
        toWaypoint.Y = 0;
        toNextWaypoint.Y = 0;

        // Check if kart is stuck (low speed for too long)
        StationaryTime = flatVelocity.SqrMagnitude < FP._7 ? StationaryTime + frame.DeltaTime : 0;

        if (StationaryTime > 5)
        {
            // Trigger respawn if stuck for too long
            input.Respawn = true;
            StationaryTime = 0;
        }

        // Handle weapon usage
        if (frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
        {
            LastWeaponTime += frame.DeltaTime;

            if (weapons->HeldWeapon != default
                && LastWeaponTime > settings.MinWeaponInterval
                && frame.RNG->NextFP() < settings.WeaponUseChance
                && frame.FindAsset(weapons->HeldWeapon).AIShouldUse(frame, filter.Entity))
            {
                input.Powerup = true;
                LastWeaponTime = 0;
            }
        }

        // Calculate steering target by blending current and next waypoint
        FPVector3 targetDirection = FPVector3.Lerp(toWaypoint, toNextWaypoint, predictionAmount).Normalized;

        // Calculate turn angle and direction
        FP turnAngle = FPVector3.Angle(toWaypoint, toNextWaypoint);
        FP signedAngle = FPVector3.SignedAngle(targetDirection, flatVelocity, FPVector3.Up);
        FP desiredDirection = FPMath.Sign(signedAngle);

        // Handle drifting input
        if (frame.Unsafe.TryGetPointer(filter.Entity, out Drifting* drifting))
        {
            bool shouldStartDrift = turnAngle >= settings.DriftingAngle && !drifting->IsDrifting;
            bool shouldEndDrift = turnAngle < settings.DriftingStopAngle && drifting->IsDrifting;

            input.Drift = !drifting->IsDrifting && shouldStartDrift || drifting->IsDrifting && shouldEndDrift;
        }

        // Calculate steering intensity based on angle
        FP steeringStrength = settings.SteeringCurve.Evaluate(FPMath.Abs(signedAngle));

        // Set final input values
        input.Direction = new FPVector2(FPMath.Clamp(-desiredDirection * steeringStrength, -1, 1), 1);
    }

    public void UpdateTarget(Frame frame, EntityRef entity)
    {
        RaceTrack* raceTrack = frame.Unsafe.GetPointerSingleton<RaceTrack>();
        RaceProgress* raceProgress = frame.Unsafe.GetPointer<RaceProgress>(entity);

        AIDriverSettings settings = frame.FindAsset(SettingsRef);

        // Get current target checkpoint
        TargetLocation = raceTrack->GetCheckpointTargetPosition(frame, raceProgress->TargetCheckpointIndex, settings.Difficulty);

        // Get next checkpoint for look-ahead
        int nextIndex = raceProgress->TargetCheckpointIndex + 1;

        if (nextIndex >= raceTrack->GetCheckpoints(frame).Count)
        {
            nextIndex = 0;
        }

        NextTargetLocation = raceTrack->GetCheckpointTargetPosition(frame, nextIndex, settings.Difficulty);
        
        // Update kart proximity awareness
        UpdateNearbyKarts(frame, entity);
    }
    
    private void UpdateNearbyKarts(Frame frame, EntityRef entity)
    {
        KartAheadDistance = FP.MaxValue;
        KartBehindDistance = FP.MaxValue;
        
        if (!frame.Unsafe.TryGetPointer(entity, out Transform3D* transform))
        {
            return;
        }
        
        // Check all karts to find nearest ahead and behind
        foreach (var (otherEntity, kart) in frame.Unsafe.GetComponentBlockIterator<Kart>())
        {
            if (otherEntity == entity) { continue; }
            
            if (frame.Unsafe.TryGetPointer(otherEntity, out Transform3D* otherTransform) && 
                frame.Unsafe.TryGetPointer(otherEntity, out RaceProgress* otherProgress) &&
                frame.Unsafe.TryGetPointer(entity, out RaceProgress* progress))
            {
                // Get vectors and distance
                FPVector3 toOtherKart = otherTransform->Position - transform->Position;
                FP distance = toOtherKart.Magnitude;
                
                // Check if ahead or behind based on race position
                if (otherProgress->CurrentPosition < progress->CurrentPosition)
                {
                    // Kart is ahead in race
                    KartAheadDistance = FPMath.Min(KartAheadDistance, distance);
                }
                else if (otherProgress->CurrentPosition > progress->CurrentPosition)
                {
                    // Kart is behind in race
                    KartBehindDistance = FPMath.Min(KartBehindDistance, distance);
                }
                else
                {
                    // Same position, use dot product to determine ahead/behind
                    FP dot = FPVector3.Dot(transform->Forward, toOtherKart.Normalized);
                    
                    if (dot > 0)
                    {
                        // Kart is ahead spatially
                        KartAheadDistance = FPMath.Min(KartAheadDistance, distance);
                    }
                    else
                    {
                        // Kart is behind spatially
                        KartBehindDistance = FPMath.Min(KartBehindDistance, distance);
                    }
                }
            }
        }
    }
}
```

## AI Integration with Race System

AI drivers are created and managed by the `KartSystem` class:

```csharp
public unsafe class KartSystem : SystemMainThreadFilter<KartSystem.Filter>, ISignalRaceStateChanged
{
    // Other implementations...
    
    public void RaceStateChanged(Frame frame, RaceState state)
    {
        if (state == RaceState.Waiting)
        {
            SpawnAIDrivers(frame);
            return;
        }

        if (state == RaceState.Countdown && frame.RuntimeConfig.FillWithAI)
        {
            FillWithAI(frame);
            return;
        }
    }
    
    private void ToggleKartEntityAI(Frame frame, EntityRef kartEntity, bool useAI, AssetRef<AIDriverSettings> settings = default)
    {
        if (kartEntity == default) { return; }

        if (useAI)
        {
            AddResult result = frame.Add<AIDriver>(kartEntity);

            if (result != 0)
            {
                AIDriver* drivingAI = frame.Unsafe.GetPointer<AIDriver>(kartEntity);

                if (settings == default)
                {
                    RaceSettings rs = frame.FindAsset(frame.RuntimeConfig.RaceSettings);
                    settings = rs.GetRandomAIConfig(frame);
                }

                drivingAI->SettingsRef = settings;
                drivingAI->UpdateTarget(frame, kartEntity);
            }
        }
        else if (frame.Unsafe.TryGetPointer(kartEntity, out AIDriver* ai))
        {
            frame.Remove<AIDriver>(kartEntity);
        }
    }
    
    private void SpawnAIDriver(Frame frame, AssetRef<AIDriverSettings> driverAsset)
    {
        if (driverAsset == null)
        {
            RaceSettings rs = frame.FindAsset(frame.RuntimeConfig.RaceSettings);
            driverAsset = rs.GetRandomAIConfig(frame);
        }

        var driverData = frame.FindAsset(driverAsset);
        EntityRef kartEntity = SpawnKart(frame, driverData.KartVisuals, driverData.KartStats);
        frame.Add<AIDriver>(kartEntity);

        if (frame.Unsafe.TryGetPointer(kartEntity, out AIDriver* ai) && frame.Unsafe.TryGetPointerSingleton(out Race* race))
        {
            ai->AIIndex = race->SpawnedAIDrivers++;
        }

        ToggleKartEntityAI(frame, kartEntity, true, driverAsset);
    }
    
    private void SpawnAIDrivers(Frame frame)
    {
        RaceSettings rs = frame.FindAsset(frame.RuntimeConfig.RaceSettings);
        byte count = frame.RuntimeConfig.AICount;

        for (int i = 0; i < count; i++)
        {
            SpawnAIDriver(frame, rs.GetRandomAIConfig(frame));
        }
    }
    
    private void FillWithAI(Frame frame)
    {
        int playerCount = frame.ComponentCount<Kart>();
        int missingDrivers = frame.RuntimeConfig.DriverCount - playerCount;

        if (missingDrivers <= 0)
        {
            return;
        }

        RaceSettings rs = frame.FindAsset(frame.RuntimeConfig.RaceSettings);

        for (int i = 0; i < missingDrivers; i++)
        {
            SpawnAIDriver(frame, rs.GetRandomAIConfig(frame));
        }
    }
    
    public void PlayerFinished(Frame f, EntityRef entity)
    {
        // When a player finishes, convert them to AI
        ToggleKartEntityAI(f, entity, true);
    }
}
```

AI drivers are automatically created in several scenarios:
1. When the race starts, based on `AICount` setting
2. To fill empty slots up to `DriverCount` when the race begins
3. When a player disconnects, their kart is taken over by AI
4. When a player finishes the race, their kart is controlled by AI

## Checkpoint Target Positions

The `RaceTrack` component provides target positions for AI drivers based on difficulty:

```csharp
public FPVector3 GetCheckpointTargetPosition(Frame frame, int checkpointIndex, int difficultyLevel)
{
    var checkpoints = GetCheckpoints(frame);
    var checkpoint = checkpoints[checkpointIndex % checkpoints.Count];
    
    if (frame.Unsafe.TryGetPointer(checkpoint, out Transform3D* transform) && 
        frame.Unsafe.TryGetPointer(checkpoint, out Checkpoint* checkpointComp))
    {
        var config = frame.FindAsset(checkpointComp->Config);
        
        // Get position offset based on difficulty
        FPVector3 offset = config.GetAITargetOffset(difficultyLevel);
        
        return transform->Position + transform->TransformDirection(offset);
    }
    
    return FPVector3.Zero;
}
```

Each checkpoint defines multiple target positions based on difficulty:

```csharp
public partial class CheckpointConfig : AssetObject
{
    public FPVector3[] TargetOffsets = new FPVector3[6];
    
    public FPVector3 GetAITargetOffset(int difficulty)
    {
        difficulty = FPMath.Clamp(difficulty, 0, 5);
        return TargetOffsets[difficulty];
    }
}
```

This allows for:
1. Optimal racing lines for higher difficulty AI
2. Suboptimal paths for lower difficulty AI
3. Different lines based on kart type and characteristics

## Difficulty Levels

AI difficulty is determined by several factors:

### 1. Steering Curve

The `SteeringCurve` defines how aggressively the AI responds to angles:

```csharp
// Example steering curves
// Low difficulty - gentle, slow response
lowDifficulty.SteeringCurve.AddKey(0, FP._0);
lowDifficulty.SteeringCurve.AddKey(45, FP._0_25);
lowDifficulty.SteeringCurve.AddKey(90, FP._0_50);
lowDifficulty.SteeringCurve.AddKey(180, FP._0_75);

// High difficulty - sharp, responsive steering
highDifficulty.SteeringCurve.AddKey(0, FP._0);
highDifficulty.SteeringCurve.AddKey(20, FP._0_50);
highDifficulty.SteeringCurve.AddKey(45, FP._0_75);
highDifficulty.SteeringCurve.AddKey(90, FP._1);
```

### 2. Prediction Range

How far ahead the AI looks to anticipate turns:

```csharp
// Low difficulty - minimal look-ahead
lowDifficulty.PredictionRange = FP._2;

// High difficulty - extensive look-ahead
highDifficulty.PredictionRange = FP._8;
```

### 3. Drifting Thresholds

When AI drivers initiate and release drifts:

```csharp
// Low difficulty - conservative drifting
lowDifficulty.DriftingAngle = 60;
lowDifficulty.DriftingStopAngle = 30;

// High difficulty - aggressive drifting
highDifficulty.DriftingAngle = 35;
highDifficulty.DriftingStopAngle = 10;
```

### 4. Target Racing Lines

The position on the track that AI drivers aim for:

```csharp
// Low difficulty - safer, wider racing line
lowDifficultyCheckpoint.TargetOffsets[0] = new FPVector3(0, 0, 0);

// High difficulty - optimal racing line
highDifficultyCheckpoint.TargetOffsets[5] = new FPVector3(-1.5f, 0, 0);
```

### 5. Weapon Usage

How often and strategically AI uses weapons:

```csharp
// Low difficulty - random weapon usage
lowDifficulty.WeaponUseChance = FP._0_30;
lowDifficulty.MinWeaponInterval = 4;

// High difficulty - strategic weapon usage
highDifficulty.WeaponUseChance = FP._0_90;
highDifficulty.MinWeaponInterval = 1;
```

## AI Behavior Patterns

AI drivers exhibit several behavior patterns:

### 1. Path Following

The core behavior is following checkpoint targets:

```csharp
// Calculate steering target
FPVector3 targetDirection = FPVector3.Lerp(toWaypoint, toNextWaypoint, predictionAmount).Normalized;

// Calculate steering input
FP signedAngle = FPVector3.SignedAngle(targetDirection, flatVelocity, FPVector3.Up);
FP desiredDirection = FPMath.Sign(signedAngle);
FP steeringStrength = settings.SteeringCurve.Evaluate(FPMath.Abs(signedAngle));

// Set steering input
input.Direction = new FPVector2(FPMath.Clamp(-desiredDirection * steeringStrength, -1, 1), 1);
```

### 2. Stuck Detection and Recovery

AI detects when it's not making progress and triggers respawn:

```csharp
// Check if kart is stuck
StationaryTime = flatVelocity.SqrMagnitude < FP._7 ? StationaryTime + frame.DeltaTime : 0;

if (StationaryTime > 5)
{
    // Trigger respawn
    input.Respawn = true;
    StationaryTime = 0;
}
```

### 3. Drift Control

AI initiates drifts on sharp turns and releases when the angle decreases:

```csharp
if (frame.Unsafe.TryGetPointer(filter.Entity, out Drifting* drifting))
{
    bool shouldStartDrift = turnAngle >= settings.DriftingAngle && !drifting->IsDrifting;
    bool shouldEndDrift = turnAngle < settings.DriftingStopAngle && drifting->IsDrifting;

    input.Drift = !drifting->IsDrifting && shouldStartDrift || drifting->IsDrifting && shouldEndDrift;
}
```

### 4. Weapon Usage

AI makes decisions about when to use weapons:

```csharp
if (frame.Unsafe.TryGetPointer(filter.Entity, out KartWeapons* weapons))
{
    LastWeaponTime += frame.DeltaTime;

    if (weapons->HeldWeapon != default
        && LastWeaponTime > settings.MinWeaponInterval
        && frame.RNG->NextFP() < settings.WeaponUseChance
        && frame.FindAsset(weapons->HeldWeapon).AIShouldUse(frame, filter.Entity))
    {
        input.Powerup = true;
        LastWeaponTime = 0;
    }
}
```

Each weapon type implements its own AI usage logic:

```csharp
// Example from WeaponBoost
public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
{
    // Use boost if not at max speed
    if (!f.Unsafe.TryGetPointer(aiKartEntity, out Kart* kart)) { return false; }
    return kart->GetNormalizedSpeed(f) < FP._0_90;
}

// Example from WeaponShield
public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
{
    // Activate shield when an incoming hazard is detected
    if (f.Unsafe.TryGetPointer(aiKartEntity, out KartHitReceiver* receiver))
    {
        return receiver->IncomingHazardDetected;
    }
    return false;
}

// Example from WeaponHazardSpawner
public override bool AIShouldUse(Frame f, EntityRef aiKartEntity)
{
    // Use offensive weapons when there's a kart ahead
    if (f.Unsafe.TryGetPointer(aiKartEntity, out AIDriver* driver))
    {
        return driver->KartAheadDistance < FP._10;
    }
    return false;
}
```

### 5. Awareness of Other Karts

AI tracks nearby karts for strategic decision making:

```csharp
private void UpdateNearbyKarts(Frame frame, EntityRef entity)
{
    KartAheadDistance = FP.MaxValue;
    KartBehindDistance = FP.MaxValue;
    
    // Implementation details...
    
    // Check all karts to find nearest ahead and behind
    foreach (var (otherEntity, kart) in frame.Unsafe.GetComponentBlockIterator<Kart>())
    {
        if (otherEntity == entity) { continue; }
        
        // Determine if kart is ahead or behind based on race position and spatial positioning
        // Set KartAheadDistance and KartBehindDistance accordingly
    }
}
```

This awareness is used for:
1. Deciding when to use offensive weapons
2. Deciding when to use defensive weapons
3. Potentially adjusting racing lines to block or overtake

## AI Performance Optimization

The AI system is optimized in several ways:

### 1. Filtered Updates

AI is only updated for karts with the required components:

```csharp
public unsafe class KartSystem : SystemMainThreadFilter<KartSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform3D* Transform3D;
        public Kart* Kart;
        public Wheels* Wheels;
        public KartInput* KartInput;
        public Drifting* Drifting;
        public RaceProgress* RaceProgress;
        public KartHitReceiver* KartHitReceiver;
    }
}
```

### 2. Target Caching

Target positions are only updated when passing checkpoints:

```csharp
public void UpdateTarget(Frame frame, EntityRef entity)
{
    // Update target positions based on current checkpoint
}

// Called when checkpoint is reached
if (playerProgress->CheckpointReached(f, checkpoint, info.Entity, out bool lapCompleted))
{
    if (f.Unsafe.TryGetPointer(info.Entity, out AIDriver* drivingAI))
    {
        drivingAI->UpdateTarget(f, info.Entity);
    }
}
```

### 3. Limited Complexity

AI uses simple, efficient calculations:
- Direct angle calculations instead of complex path finding
- Fixed waypoints rather than dynamic navigation
- Limited lookahead to next checkpoint only

## Best Practices

1. **Difficulty Scaling**: Create a range of AI difficulties through configuration
2. **Checkpoint Design**: Place checkpoints to create good AI racing lines
3. **Runtime Conversion**: Allow AI to take over for disconnected or finished players
4. **Configurable Behavior**: Use asset-based configuration for different AI personalities
5. **Efficient Implementation**: Optimize AI calculations for performance
6. **Deterministic Logic**: Ensure AI behavior is fully deterministic for network play
7. **Strategic Decisions**: Implement weapon usage based on race situation
8. **Recovery Logic**: Add detection and recovery for stuck situations

---

# 09-unity-integration.md

# Quantum Karts Unity Integration

This document explains how the Quantum simulation integrates with Unity visuals in the Quantum Karts project, covering how the deterministic game state is translated into visual representations, effects, and UI.

## Core Integration Architecture

Quantum Karts follows a strict simulation-view separation pattern:

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

This architecture ensures that:
1. The simulation runs deterministically across all clients
2. Visual representation can be customized without affecting gameplay
3. Network synchronization only needs to transmit input, not visual state

## Key Integration Components

### 1. CustomViewContext

The `CustomViewContext` class extends Quantum's standard `QuantumGame` class to add game-specific functionality:

```csharp
public class CustomViewContext : QuantumUnityAdapter
{
    public QuantumCallbackHandler<EventWeaponCollected> _WeaponCollected;
    public QuantumCallbackHandler<EventWeaponUsed> _WeaponUsed;
    public QuantumCallbackHandler<EventOnBoostStart> _BoostStart;
    // Additional event handlers...
    
    public CustomViewContext(Game game) : base(game) { }
    
    public override void OnEnable()
    {
        base.OnEnable();
        
        // Register event handlers
        _WeaponCollected = new QuantumCallbackHandler<EventWeaponCollected>(
            callback: OnWeaponCollected, 
            notifyMultipleTimes: false,
            throwOnDuplicates: false
        );
        
        // Additional event registrations...
    }
    
    public override void OnDisable()
    {
        base.OnDisable();
        
        // Unregister event handlers
        _WeaponCollected = null;
        _WeaponUsed = null;
        // Additional event cleanup...
    }
    
    // Event handler methods
    private void OnWeaponCollected(EventWeaponCollected evt)
    {
        // Handle event
    }
    
    // Additional event handlers...
}
```

### 2. EntityViewComponent

All visual representations use the `QuantumEntityViewComponent` base class:

```csharp
public abstract class QuantumEntityViewComponent<TContext> : MonoBehaviour, IQuantumEntityView<TContext> 
    where TContext : CustomViewContext
{
    public EntityRef EntityRef { get; set; }
    public TContext Game { get; set; }
    
    public virtual void OnActivate(Frame frame) { }
    public virtual void OnDeactivate() { }
    public virtual void OnUpdate(Frame frame) { }
}
```

### 3. Visual Kart Spawner

The `VisualKartSpawner` creates the visual representation of karts:

```csharp
public unsafe class VisualKartSpawner : QuantumEntityViewComponent<CustomViewContext>
{
    public override void OnActivate(Frame frame)
    {
        if (frame.Unsafe.TryGetPointer(EntityRef, out Kart* kart))
        {
            KartVisuals visuals = frame.FindAsset(kart->VisualAsset);
            GameObject visualKart = Instantiate(visuals.KartPrefab, transform);

            visualKart.transform.localPosition = visuals.LocalOffset;

            var kartView = visualKart.GetComponent<KartViewController>();
            kartView.Initialize(Game);

            PlayerName nameDisplay = GetComponentInChildren<PlayerName>();

            if (LocalPlayerManager.Instance.LocalPlayerKartView == kartView)
            {
                nameDisplay.gameObject.SetActive(false);
            }
            else
            {
                nameDisplay.SetName(kartView.DriverName);
            }
        }
        else
        {
            Debug.Log("kart comp not found");
        }
    }
}
```

### 4. KartViewController

The `KartViewController` manages the visual aspects of a kart:

```csharp
public unsafe class KartViewController : MonoBehaviour
{
    [SerializeField] private Transform kartModel;
    [SerializeField] private Transform[] wheels;
    [SerializeField] private ParticleSystem[] driftParticles;
    [SerializeField] private TrailRenderer[] driftTrails;
    [SerializeField] private ParticleSystem exhaustSystem;
    [SerializeField] private AudioSource engineSound;
    [SerializeField] private AudioSource driftSound;
    [SerializeField] private AudioSource boostSound;
    
    private EntityRef _entityRef;
    private CustomViewContext _game;
    private bool _isDrifting;
    private int _driftBoostLevel;
    private bool _isBoosting;
    private string _driverName;
    
    public string DriverName => _driverName;
    
    public void Initialize(CustomViewContext game)
    {
        _game = game;
        _entityRef = transform.parent.GetComponent<QuantumEntityView>().EntityRef;
        
        // Subscribe to events
        QuantumCallback.Subscribe(this, (EventDriftStarted evt) => OnDriftStarted(evt));
        QuantumCallback.Subscribe(this, (EventDriftEnded evt) => OnDriftEnded(evt));
        QuantumCallback.Subscribe(this, (EventDriftBoostCharged evt) => OnDriftBoostCharged(evt));
        QuantumCallback.Subscribe(this, (EventOnBoostStart evt) => OnBoostStarted(evt));
        QuantumCallback.Subscribe(this, (EventKartHit evt) => OnKartHit(evt));
        
        // Set driver name based on player or AI
        if (_game.Frames.Verified.TryGetPointer(_entityRef, out PlayerLink* link))
        {
            _driverName = _game.PlayerNames.GetPlayerName(link->Player);
        }
        else if (_game.Frames.Verified.TryGetPointer(_entityRef, out AIDriver* ai))
        {
            var settings = _game.Frames.Verified.FindAsset(ai->SettingsRef);
            _driverName = $"AI {ai->AIIndex + 1}";
        }
        else
        {
            _driverName = "Unknown";
        }
    }
    
    private void Update()
    {
        if (_game == null || _game.Frames.Verified == null)
            return;
            
        // Update visual elements based on simulation state
        UpdateVelocityBasedEffects();
        UpdateWheelVisuals();
        UpdateEngineSound();
    }
    
    private void UpdateVelocityBasedEffects()
    {
        if (_game.Frames.Verified.TryGetPointer(_entityRef, out Kart* kart))
        {
            // Update effects based on speed
            FP speed = kart->GetNormalizedSpeed(_game.Frames.Verified);
            
            // Update engine pitch based on speed
            engineSound.pitch = 0.8f + speed.AsFloat * 0.7f;
            
            // Update exhaust particles based on speed and boost
            var emission = exhaustSystem.emission;
            emission.rateOverTime = (speed.AsFloat * 50) + (_isBoosting ? 100 : 0);
        }
    }
    
    private void UpdateWheelVisuals()
    {
        if (_game.Frames.Verified.TryGetPointer(_entityRef, out Wheels* wheelComp))
        {
            // Update wheel positions and rotations based on suspension
            for (int i = 0; i < wheels.Length && i < wheelComp->WheelStatuses.Length; i++)
            {
                var status = wheelComp->WheelStatuses.GetPointer(i)->Value;
                wheels[i].localPosition = new Vector3(
                    wheels[i].localPosition.x,
                    status.Grounded ? -status.SuspensionCompression.AsFloat * 0.1f : 0,
                    wheels[i].localPosition.z
                );
                
                // Rotate wheel based on speed
                wheels[i].Rotate(Vector3.right, 
                    _game.Frames.Verified.TryGetPointer(_entityRef, out Kart* kart) ? 
                    kart->Velocity.Magnitude.AsFloat * 10 * Time.deltaTime : 0);
            }
        }
    }
    
    private void UpdateEngineSound()
    {
        if (_game.Frames.Verified.TryGetPointer(_entityRef, out Kart* kart))
        {
            // Update engine volume based on speed and proximity to camera
            float distance = Vector3.Distance(Camera.main.transform.position, transform.position);
            float volume = Mathf.Lerp(0.1f, 1.0f, Mathf.Clamp01(10 / distance));
            engineSound.volume = volume * (0.5f + kart->GetNormalizedSpeed(_game.Frames.Verified).AsFloat * 0.5f);
        }
    }
    
    // Event handlers
    private void OnDriftStarted(EventDriftStarted evt)
    {
        if (evt.Entity != _entityRef) return;
        
        _isDrifting = true;
        _driftBoostLevel = 0;
        
        // Activate drift particles and sound
        foreach (var particle in driftParticles)
        {
            particle.Play();
        }
        
        foreach (var trail in driftTrails)
        {
            trail.emitting = true;
        }
        
        driftSound.Play();
    }
    
    private void OnDriftEnded(EventDriftEnded evt)
    {
        if (evt.Entity != _entityRef) return;
        
        _isDrifting = false;
        
        // Deactivate drift effects
        foreach (var particle in driftParticles)
        {
            particle.Stop();
        }
        
        foreach (var trail in driftTrails)
        {
            trail.emitting = false;
        }
        
        driftSound.Stop();
    }
    
    private void OnDriftBoostCharged(EventDriftBoostCharged evt)
    {
        if (evt.Entity != _entityRef) return;
        
        _driftBoostLevel = evt.BoostLevel;
        
        // Update drift particle color based on boost level
        Color boostColor = Color.white;
        switch (_driftBoostLevel)
        {
            case 1: boostColor = Color.blue; break;
            case 2: boostColor = Color.yellow; break;
            case 3: boostColor = Color.red; break;
        }
        
        foreach (var particle in driftParticles)
        {
            var main = particle.main;
            main.startColor = boostColor;
        }
        
        foreach (var trail in driftTrails)
        {
            trail.startColor = boostColor;
        }
    }
    
    private void OnBoostStarted(EventOnBoostStart evt)
    {
        if (evt.Entity != _entityRef) return;
        
        _isBoosting = true;
        
        // Get boost config
        var boostConfig = _game.Frames.Verified.FindAsset<BoostConfig>(evt.KartBoost.CurrentBoost);
        
        // Play boost sound
        boostSound.Play();
        
        // Update exhaust color
        var main = exhaustSystem.main;
        main.startColor = boostConfig.ExhaustColor;
        
        // Schedule boost end
        StartCoroutine(EndBoostAfter(boostConfig.Duration.AsFloat));
    }
    
    private IEnumerator EndBoostAfter(float duration)
    {
        yield return new WaitForSeconds(duration);
        _isBoosting = false;
        
        // Reset exhaust color
        var main = exhaustSystem.main;
        main.startColor = Color.white;
    }
    
    private void OnKartHit(EventKartHit evt)
    {
        if (evt.Entity != _entityRef) return;
        
        // Play hit effects
        // Shake camera if local player
        if (LocalPlayerManager.Instance.LocalPlayerKartView == this)
        {
            CameraShake.Instance.ShakeCamera(evt.Damage.AsFloat * 0.5f);
        }
    }
}
```

### 5. LocalInput

The `LocalInput` class captures Unity input and sends it to Quantum:

```csharp
public class LocalInput : MonoBehaviour
{
    private void Start()
    {
        QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
    }

    public void PollInput(CallbackPollInput callback)
    {
        Quantum.Input input = new Quantum.Input();

        // Note: Use GetButton not GetButtonDown/Up Quantum calculates up/down itself.
        input.Drift = UnityEngine.Input.GetButton("Jump");
        input.Powerup = UnityEngine.Input.GetButton("Fire1");
        input.Respawn = UnityEngine.Input.GetKey(KeyCode.R);

        var x = UnityEngine.Input.GetAxis("Horizontal");
        var y = UnityEngine.Input.GetAxis("Vertical");

        // Input that is passed into the simulation needs to be deterministic that's why it's converted to FPVector2.
        input.Direction = new Vector2(x, y).ToFPVector2();

        callback.SetInput(input, DeterministicInputFlags.Repeatable);
    }
}
```

## Event-Based Communication

### 1. Event Registration

Events are defined in Quantum and subscribed to in Unity:

```csharp
// In a MonoBehaviour
private void OnEnable()
{
    // Subscribe to events
    _driftStartedCallback = QuantumCallback.Subscribe<EventDriftStarted>(this, OnDriftStarted);
    _boostStartCallback = QuantumCallback.Subscribe<EventOnBoostStart>(this, OnBoostStarted);
    _raceStateChangedCallback = QuantumCallback.Subscribe<EventOnRaceStateChanged>(this, OnRaceStateChanged);
}

private void OnDisable()
{
    // Unsubscribe from events
    if (_driftStartedCallback != null)
    {
        _driftStartedCallback.Dispose();
        _driftStartedCallback = null;
    }
    
    // Additional cleanup...
}
```

### 2. Event Implementation

Events are triggered in Quantum and handled in Unity:

```csharp
// In Quantum (simulation)
public void StartBoost(Frame f, AssetRef<BoostConfig> config, EntityRef kartEntity)
{
    BoostConfig boost = f.FindAsset(config);
    CurrentBoost = config;
    TimeRemaining = boost.Duration;

    f.Events.OnBoostStart(kartEntity, this);
}

// In Unity (view)
private void OnBoostStarted(EventOnBoostStart evt)
{
    if (evt.Entity != _entityRef) return;
    
    // Play visual and audio effects
    _isBoosting = true;
    var boostConfig = _game.Frames.Verified.FindAsset<BoostConfig>(evt.KartBoost.CurrentBoost);
    boostSound.Play();
    
    var main = exhaustSystem.main;
    main.startColor = boostConfig.ExhaustColor;
}
```

## Asset References

Assets are shared between Quantum and Unity through AssetDBs:

### 1. Quantum Asset Definition

```csharp
public unsafe partial class KartVisuals : AssetObject
{
    public GameObject KartPrefab;
    public Vector3 LocalOffset;
    public AudioClip EngineSound;
    public AudioClip DriftSound;
    public AudioClip BoostSound;
}
```

### 2. Unity Asset Reference

```csharp
public unsafe class VisualKartSpawner : QuantumEntityViewComponent<CustomViewContext>
{
    public override void OnActivate(Frame frame)
    {
        if (frame.Unsafe.TryGetPointer(EntityRef, out Kart* kart))
        {
            KartVisuals visuals = frame.FindAsset(kart->VisualAsset);
            GameObject visualKart = Instantiate(visuals.KartPrefab, transform);
            
            // Use asset references to configure the view
            visualKart.transform.localPosition = visuals.LocalOffset;
        }
    }
}
```

## UI Integration

### 1. Race HUD

The race UI is updated based on Quantum state:

```csharp
public unsafe class RaceHUD : MonoBehaviour
{
    [SerializeField] private Text lapCounter;
    [SerializeField] private Text positionText;
    [SerializeField] private Text timerText;
    [SerializeField] private Text countdownText;
    [SerializeField] private GameObject raceStartPanel;
    [SerializeField] private GameObject raceFinishPanel;
    
    private QuantumCallback<EventOnRaceStateChanged> _raceStateCallback;
    private QuantumCallback<EventOnCountdownUpdated> _countdownCallback;
    private QuantumCallback<EventOnPositionsUpdated> _positionsCallback;
    
    private void OnEnable()
    {
        _raceStateCallback = QuantumCallback.Subscribe<EventOnRaceStateChanged>(this, OnRaceStateChanged);
        _countdownCallback = QuantumCallback.Subscribe<EventOnCountdownUpdated>(this, OnCountdownUpdated);
        _positionsCallback = QuantumCallback.Subscribe<EventOnPositionsUpdated>(this, OnPositionsUpdated);
    }
    
    private void OnDisable()
    {
        if (_raceStateCallback != null)
        {
            _raceStateCallback.Dispose();
            _raceStateCallback = null;
        }
        
        // Additional cleanup...
    }
    
    private void Update()
    {
        UpdateRaceTime();
    }
    
    private void UpdateRaceTime()
    {
        var game = QuantumRunner.Default.Game;
        if (game?.Frames.Verified == null) return;
        
        if (game.Frames.Verified.TryGetPointerSingleton(out Race* race))
        {
            if (race->CurrentRaceState == RaceState.InProgress)
            {
                float raceTime = game.Frames.Verified.Time.AsFloat;
                int minutes = Mathf.FloorToInt(raceTime / 60);
                int seconds = Mathf.FloorToInt(raceTime % 60);
                int milliseconds = Mathf.FloorToInt((raceTime * 100) % 100);
                
                timerText.text = $"{minutes:00}:{seconds:00}:{milliseconds:00}";
            }
        }
    }
    
    private void OnRaceStateChanged(EventOnRaceStateChanged evt)
    {
        switch (evt.NewState)
        {
            case RaceState.Waiting:
                raceStartPanel.SetActive(true);
                raceFinishPanel.SetActive(false);
                countdownText.gameObject.SetActive(false);
                break;
                
            case RaceState.Countdown:
                raceStartPanel.SetActive(false);
                countdownText.gameObject.SetActive(true);
                break;
                
            case RaceState.InProgress:
                countdownText.gameObject.SetActive(false);
                break;
                
            case RaceState.Finished:
                raceFinishPanel.SetActive(true);
                ShowRaceResults();
                break;
        }
    }
    
    private void OnCountdownUpdated(EventOnCountdownUpdated evt)
    {
        countdownText.text = Mathf.CeilToInt(evt.RemainingTime.AsFloat).ToString();
    }
    
    private void OnPositionsUpdated(EventOnPositionsUpdated evt)
    {
        UpdatePlayerUI();
    }
    
    private void UpdatePlayerUI()
    {
        var game = QuantumRunner.Default.Game;
        if (game?.Frames.Verified == null) return;
        
        EntityRef localKartEntity = LocalPlayerManager.Instance.LocalPlayerKartEntity;
        
        if (game.Frames.Verified.TryGetPointer(localKartEntity, out RaceProgress* progress))
        {
            // Update lap counter
            lapCounter.text = $"LAP {progress->CurrentLap}/{progress->TotalLaps}";
            
            // Update position
            positionText.text = FormatPosition(progress->CurrentPosition);
        }
    }
    
    private string FormatPosition(sbyte position)
    {
        string suffix;
        switch (position)
        {
            case 1: suffix = "ST"; break;
            case 2: suffix = "ND"; break;
            case 3: suffix = "RD"; break;
            default: suffix = "TH"; break;
        }
        
        return $"{position}{suffix}";
    }
    
    private void ShowRaceResults()
    {
        // Implement race results UI population
    }
}
```

### 2. Minimap

A minimap shows kart positions on the track:

```csharp
public unsafe class MinimapController : MonoBehaviour
{
    [SerializeField] private RectTransform minimapContainer;
    [SerializeField] private GameObject kartIconPrefab;
    [SerializeField] private Color playerIconColor = Color.green;
    [SerializeField] private Color aiIconColor = Color.red;
    
    private Dictionary<EntityRef, RectTransform> _kartIcons = new Dictionary<EntityRef, RectTransform>();
    private Vector2 _mapScale = new Vector2(10, 10); // Scale factor for converting world to minimap coords
    
    private void Update()
    {
        UpdateKartIcons();
    }
    
    private void UpdateKartIcons()
    {
        var game = QuantumRunner.Default.Game;
        if (game?.Frames.Verified == null) return;
        
        // Create icons for any new karts
        foreach (var (entity, kart) in game.Frames.Verified.Unsafe.GetComponentBlockIterator<Kart>())
        {
            if (!_kartIcons.ContainsKey(entity))
            {
                CreateKartIcon(entity);
            }
        }
        
        // Update positions for all karts
        foreach (var kvp in _kartIcons)
        {
            if (game.Frames.Verified.TryGetPointer(kvp.Key, out Transform3D* transform))
            {
                // Convert world position to minimap coordinates
                Vector2 minimapPos = new Vector2(
                    transform->Position.X.AsFloat * _mapScale.x,
                    transform->Position.Z.AsFloat * _mapScale.y
                );
                
                kvp.Value.anchoredPosition = minimapPos;
                
                // Rotate icon to match kart direction
                float angle = Mathf.Atan2(transform->Forward.X.AsFloat, transform->Forward.Z.AsFloat) * Mathf.Rad2Deg;
                kvp.Value.rotation = Quaternion.Euler(0, 0, -angle);
            }
        }
    }
    
    private void CreateKartIcon(EntityRef entity)
    {
        var game = QuantumRunner.Default.Game;
        
        // Create icon
        GameObject iconObj = Instantiate(kartIconPrefab, minimapContainer);
        RectTransform iconTransform = iconObj.GetComponent<RectTransform>();
        _kartIcons[entity] = iconTransform;
        
        // Set color based on player vs AI
        Image iconImage = iconObj.GetComponent<Image>();
        
        bool isPlayer = game.Frames.Verified.TryGetPointer(entity, out PlayerLink* playerLink);
        bool isLocalPlayer = isPlayer && entity == LocalPlayerManager.Instance.LocalPlayerKartEntity;
        
        if (isLocalPlayer)
        {
            iconImage.color = playerIconColor;
            iconTransform.SetAsLastSibling(); // Draw on top
            iconTransform.localScale = Vector3.one * 1.5f; // Make larger
        }
        else if (isPlayer)
        {
            iconImage.color = new Color(0, 0.7f, 1);
        }
        else
        {
            iconImage.color = aiIconColor;
        }
    }
}
```

## Camera System

A camera system follows the player's kart:

```csharp
public class KartCameraController : MonoBehaviour
{
    [SerializeField] private Vector3 offset = new Vector3(0, 3, -6);
    [SerializeField] private float smoothTime = 0.2f;
    [SerializeField] private float lookAheadFactor = 0.5f;
    [SerializeField] private float tiltFactor = 0.1f;
    
    private Transform _target;
    private Vector3 _currentVelocity;
    private Rigidbody _targetRigidbody;
    
    private void Start()
    {
        // Subscribe to local player setup
        LocalPlayerManager.OnLocalPlayerKartSet += HandleLocalPlayerSet;
    }
    
    private void HandleLocalPlayerSet(KartViewController kartView)
    {
        _target = kartView.transform;
        _targetRigidbody = _target.GetComponentInParent<Rigidbody>();
    }
    
    private void LateUpdate()
    {
        if (_target == null) return;
        
        // Calculate target position with look-ahead
        Vector3 lookAheadPos = Vector3.zero;
        if (_targetRigidbody != null)
        {
            lookAheadPos = _targetRigidbody.velocity * lookAheadFactor;
            lookAheadPos.y = 0; // Only look ahead on XZ plane
        }
        
        Vector3 targetPos = _target.position + _target.TransformDirection(offset) + lookAheadPos;
        
        // Smooth position
        transform.position = Vector3.SmoothDamp(transform.position, targetPos, ref _currentVelocity, smoothTime);
        
        // Calculate rotation with tilt
        float tilt = 0;
        if (_targetRigidbody != null)
        {
            // Add tilt based on lateral velocity
            Vector3 localVel = _target.InverseTransformDirection(_targetRigidbody.velocity);
            tilt = -localVel.x * tiltFactor;
        }
        
        // Look at target with tilt
        Quaternion targetRotation = Quaternion.LookRotation(_target.position - transform.position, Vector3.up);
        targetRotation *= Quaternion.Euler(0, 0, tilt);
        transform.rotation = targetRotation;
    }
}
```

## Particle and Audio Effects

Special effects are synchronized with simulation events:

```csharp
public unsafe class KartEffectsController : MonoBehaviour
{
    [SerializeField] private ParticleSystem[] wheelSmoke;
    [SerializeField] private ParticleSystem[] driftSparks;
    [SerializeField] private ParticleSystem boostTrail;
    [SerializeField] private AudioSource skidSound;
    
    private EntityRef _entityRef;
    private CustomViewContext _game;
    
    public void Initialize(CustomViewContext game, EntityRef entityRef)
    {
        _game = game;
        _entityRef = entityRef;
    }
    
    private void Update()
    {
        if (_game == null || _game.Frames.Verified == null)
            return;
            
        UpdateWheelEffects();
    }
    
    private void UpdateWheelEffects()
    {
        if (_game.Frames.Verified.TryGetPointer(_entityRef, out Kart* kart))
        {
            // Update wheel smoke based on sideways speed
            bool shouldEmitSmoke = kart->SidewaysSpeedSqr > FP._5;
            
            foreach (var smoke in wheelSmoke)
            {
                var emission = smoke.emission;
                emission.enabled = shouldEmitSmoke;
            }
            
            // Update skid sound
            if (shouldEmitSmoke && !skidSound.isPlaying)
            {
                skidSound.Play();
            }
            else if (!shouldEmitSmoke && skidSound.isPlaying)
            {
                skidSound.Stop();
            }
        }
    }
    
    public void OnDriftStarted()
    {
        foreach (var spark in driftSparks)
        {
            spark.Play();
        }
    }
    
    public void OnDriftEnded()
    {
        foreach (var spark in driftSparks)
        {
            spark.Stop();
        }
    }
    
    public void OnBoostStarted(Color boostColor, float duration)
    {
        var main = boostTrail.main;
        main.startColor = boostColor;
        main.duration = duration;
        boostTrail.Play();
    }
}
```

## Map Loading

Maps are loaded from Quantum assets:

```csharp
public unsafe class MapLoader : MonoBehaviour
{
    [SerializeField] private Transform mapContainer;
    
    public void LoadMap(AssetRef<RaceTrackAsset> trackAssetRef)
    {
        var game = QuantumRunner.Default.Game;
        if (game == null) return;
        
        // Clear existing map
        foreach (Transform child in mapContainer)
        {
            Destroy(child.gameObject);
        }
        
        // Load new map
        var trackAsset = game.FindAsset<RaceTrackAsset>(trackAssetRef);
        if (trackAsset == null) return;
        
        // Instantiate map prefab
        Instantiate(trackAsset.MapPrefab, mapContainer);
        
        // Notify map loaded
        game.Events.OnMapLoaded(trackAsset.MapName);
    }
}
```

## Local Player Management

A singleton manages references to the local player:

```csharp
public class LocalPlayerManager : MonoBehaviour
{
    public static LocalPlayerManager Instance { get; private set; }
    
    public EntityRef LocalPlayerKartEntity { get; private set; }
    public KartViewController LocalPlayerKartView { get; private set; }
    
    public static event Action<KartViewController> OnLocalPlayerKartSet;
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    public void SetLocalPlayerKart(EntityRef entity, KartViewController view)
    {
        LocalPlayerKartEntity = entity;
        LocalPlayerKartView = view;
        
        OnLocalPlayerKartSet?.Invoke(view);
    }
}
```

## Network Integration

Network synchronization is handled by Quantum:

```csharp
public class NetworkManager : MonoBehaviour
{
    public static NetworkManager Instance { get; private set; }
    
    [SerializeField] private byte maxPlayers = 8;
    [SerializeField] private string gameVersion = "1.0";
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    public void StartHost()
    {
        var config = GetQuantumConfig();
        var param = new QuantumRunner.StartParameters();
        param.GameMode = Photon.Deterministic.DeterministicGameMode.Host;
        param.LocalPlayer = CreatePlayerData();
        param.RuntimeConfig = GetRuntimeConfig();
        
        QuantumRunner.StartGame(config, param);
    }
    
    public void JoinRoom(string roomName)
    {
        var config = GetQuantumConfig();
        var param = new QuantumRunner.StartParameters();
        param.GameMode = Photon.Deterministic.DeterministicGameMode.Client;
        param.LocalPlayer = CreatePlayerData();
        param.RuntimeConfig = GetRuntimeConfig();
        param.RoomName = roomName;
        
        QuantumRunner.StartGame(config, param);
    }
    
    private RuntimeConfigContainer GetRuntimeConfig()
    {
        var container = new RuntimeConfigContainer();
        
        // Set race-specific config
        container.RaceSettings = SelectedTrack.RaceSettingsAsset;
        container.AICount = SelectedGameMode.AICount;
        container.DriverCount = SelectedGameMode.TotalDrivers;
        container.CountdownTime = 3;
        container.FinishingTime = 30;
        container.FillWithAI = true;
        
        return container;
    }
    
    private RuntimePlayer CreatePlayerData()
    {
        RuntimePlayer player = new RuntimePlayer();
        
        // Set player-specific data
        player.KartStats = SelectedKart.StatsAsset;
        player.KartVisuals = SelectedKart.VisualsAsset;
        player.PlayerName = PlayerPrefs.GetString("PlayerName", "Player");
        
        return player;
    }
}
```

## Optimization Techniques

Several techniques optimize the Unity integration:

### 1. Entity Pooling

```csharp
public class EntityViewPool : MonoBehaviour
{
    [SerializeField] private GameObject prefab;
    [SerializeField] private int poolSize = 10;
    
    private Queue<GameObject> _pool = new Queue<GameObject>();
    
    private void Awake()
    {
        // Pre-instantiate objects
        for (int i = 0; i < poolSize; i++)
        {
            var obj = Instantiate(prefab, transform);
            obj.SetActive(false);
            _pool.Enqueue(obj);
        }
    }
    
    public GameObject Get()
    {
        if (_pool.Count > 0)
        {
            var obj = _pool.Dequeue();
            obj.SetActive(true);
            return obj;
        }
        else
        {
            // Create new object if pool is empty
            return Instantiate(prefab);
        }
    }
    
    public void Return(GameObject obj)
    {
        obj.SetActive(false);
        obj.transform.SetParent(transform);
        _pool.Enqueue(obj);
    }
}
```

### 2. Culling and LOD

```csharp
public class KartViewLOD : MonoBehaviour
{
    [SerializeField] private GameObject highDetailModel;
    [SerializeField] private GameObject lowDetailModel;
    [SerializeField] private ParticleSystem[] highDetailEffects;
    [SerializeField] private float lodDistance = 50f;
    
    private Transform _cameraTransform;
    
    private void Start()
    {
        _cameraTransform = Camera.main.transform;
    }
    
    private void Update()
    {
        float distance = Vector3.Distance(transform.position, _cameraTransform.position);
        
        bool useHighDetail = distance < lodDistance;
        
        highDetailModel.SetActive(useHighDetail);
        lowDetailModel.SetActive(!useHighDetail);
        
        foreach (var effect in highDetailEffects)
        {
            var emission = effect.emission;
            emission.enabled = useHighDetail;
        }
    }
}
```

### 3. Event Batching

```csharp
public class EventBatcher
{
    public const int BatchInterval = 5; // Process events every 5 frames
    private int _frameCounter = 0;
    
    private Queue<Action> _pendingEvents = new Queue<Action>();
    
    public void AddEvent(Action action)
    {
        _pendingEvents.Enqueue(action);
    }
    
    public void Update()
    {
        _frameCounter++;
        
        if (_frameCounter >= BatchInterval)
        {
            _frameCounter = 0;
            
            int eventCount = _pendingEvents.Count;
            for (int i = 0; i < eventCount; i++)
            {
                _pendingEvents.Dequeue()?.Invoke();
            }
        }
    }
}
```

## Best Practices

1. **Strict Separation**: Keep simulation and view code completely separate
2. **Event-Based Communication**: Use events for simulation-to-view communication
3. **Reusable Components**: Create modular, reusable view components
4. **Asset References**: Use asset references to share data between simulation and view
5. **Optimization**: Implement pooling, LOD, and culling for performance
6. **Clean Subscriptions**: Always unsubscribe from events when components are disabled
7. **Local Player Identification**: Have a central manager for the local player references
8. **Customization**: Keep visuals configurable through assets and prefabs

---

# 00-summary.md

# Quantum Motor Dome Documentation Summary

This collection of notes provides a comprehensive reference for Quantum Motor Dome, a multiplayer 3D arena game built with Photon Quantum 3.0.2. These documents focus on code accuracy and practical implementation of game mechanics using the Quantum ECS framework.

## Core Concepts

1. [**Project Overview**](01-project-overview.md)
   - Overview of Quantum Motor Dome architecture
   - Project structure and organization
   - Game flow and systems

2. [**Game State Management**](02-game-state-management.md)
   - State machine implementation
   - Game flow control
   - System activation/deactivation

3. [**Input System**](03-input-system.md)
   - Input structure and handling
   - Controls mapping
   - Input processing

## Core Gameplay

4. [**Ship Movement System**](04-ship-movement-system.md)
   - Ship physics and movement
   - Trail mechanics
   - Spherical world navigation

5. [**Collision System**](05-collision-system.md)
   - Collision detection
   - Trail segment collision
   - Ship-to-ship collision

6. [**Pickup System**](06-pickup-system.md)
   - Pickup types and spawning
   - Collection mechanics
   - Boost and score implementation

## Game Features

7. [**Scoring and Reconnection**](07-scoring-and-reconnection.md)
   - Trail growth and scoring
   - Reconnection mechanics
   - Points calculation

8. [**Spawning System**](08-spawning-system.md)
   - Ship spawning
   - Respawn protection
   - Spawn positioning

9. [**Unity Integration**](09-unity-integration.md)
   - Visual representation in Unity
   - Ship model and effects
   - Camera and UI integration
   - Synchronization with Quantum simulation

## How to Use These Notes

- Start with the [Project Overview](01-project-overview.md) for a high-level understanding
- Review the [Game State Management](02-game-state-management.md) to understand game flow
- Explore the [Ship Movement System](04-ship-movement-system.md) for core mechanics
- Study the other documents for specific implementations

Each document contains detailed code examples that can be directly used in your Quantum projects. The focus is on providing clear, accurate code snippets that demonstrate best practices for working with the Quantum framework in a 3D arena game context.

---

# 01-project-overview.md

# Quantum Motor Dome Project Overview

This document provides a comprehensive overview of the Quantum Motor Dome project, a multiplayer 3D arena game built with Photon Quantum 3.0.2. These notes explain the project structure, core systems, and implementation details to help you understand how to create a similar arena game with Quantum's deterministic networking framework.

## Project Structure

Quantum Motor Dome demonstrates a multiplayer arena game with the following organization:

### Core Simulation Code (Quantum)
- **Assets/QuantumUser/Simulation/Game**: Contains all the deterministic simulation code
  - **DSL**: Component and state definitions in Quantum DSL
  - **Systems**: Game logic implementation
  - **Filters**: Entity filtering structures

### Unity View Code
- **Assets/Scripts**: Contains Unity-side view code
  - **View Logic**: View representations of simulation elements
  - **UI**: User interface and menu systems
  - **Camera**: Camera control and effects
  - **Effects**: Visual and audio effects

## Game Concept

Quantum Motor Dome is a multiplayer arena game where players control ships that move around a spherical arena. Key features include:

1. **Trail Mechanics**: Each ship leaves a trail behind it
2. **Collision**: Players can collide with other players' trails
3. **Reconnection**: Players can reconnect their trail to score points
4. **Pickups**: Collectible items provide boosts and score bonuses
5. **Spherical Movement**: All gameplay takes place on the surface of a sphere

## Architecture Overview

Quantum Motor Dome follows Quantum's core architecture principles:

### Simulation-View Separation

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

- **Simulation**: Deterministic game logic running in Quantum
- **View**: Visual representation in Unity
- **Events**: One-way communication from simulation to view
- **Input**: Player commands sent from view to simulation

### ECS Implementation

The game uses Quantum's Entity Component System:
- **Entities**: Dynamic game objects (ships, pickups)
- **Components**: Data containers attached to entities (Ship, PlayerLink)
- **Systems**: Logic that processes entities with specific components (ShipMovementSystem, CollisionSystem)

### Game State Flow

The game transitions through several states managed by the GameStateSystem:

```
Lobby → Pregame → Intro → Countdown → Game → Outro → Postgame
  ↑                                                    |
  └────────────────────────────────────────────────────┘
```

Each state activates specific systems related to that phase of gameplay.

## Core Components

### Ship Component

The Ship component represents the player-controlled vehicle:

```qtn
component Ship
{
	[Header("Runtime Properties")]
	FP BoostAmount;
	int Score;
	list<FPVector3> Segments;
	list<PhysicsQueryRef> SegmentQueries;

	[Header("Movement State")]
	FP SteerAmount;
	bool IsBraking;
	bool IsBoosting;
}
```

Key aspects:
- `BoostAmount`: Current boost energy (0-100)
- `Score`: Player's current score (length of trail)
- `Segments`: List of positions forming the ship's trail
- `SegmentQueries`: Physics queries for collision detection
- Movement state flags for steering, braking, and boosting

### Player Link

The PlayerLink connects ships to players:

```qtn
component PlayerLink
{
	player_ref Player;
}

struct PlayerData
{
	bool ready;
	Int16 points;
}
```

### Global State

The global state manages game-wide information:

```qtn
global
{
	FrameTimer clock;
	dictionary<Int32, PlayerData> playerData;
	
	FrameTimer StateTimer;
    GameState DelayedState;
    
    GameState CurrentState;
    GameState PreviousState;
}
```

## Core Systems

### 1. Game State System

The `GameStateSystem` manages the game flow:

```csharp
unsafe class GameStateSystem : SystemMainThread
{
    static readonly ReadOnlyDictionary<GameState, Type> stateTable =
        new(new Dictionary<GameState, Type>()
        {
            { GameState.Lobby, typeof(IGameState_Lobby) },
            { GameState.Pregame, typeof(IGameState_Pregame) },
            { GameState.Intro, typeof(IGameState_Intro) },
            { GameState.Countdown, typeof(IGameState_Countdown) },
            { GameState.Game, typeof(IGameState_Game) },
            { GameState.Outro, typeof(IGameState_Outro) },
            { GameState.Postgame, typeof(IGameState_Postgame) }
        });
    
    // Implementation details...
    
    public static void SetStateDelayed(Frame f, GameState state, FP delay)
    {
        f.Global->DelayedState = state;
        f.Global->StateTimer = FrameTimer.FromSeconds(f, delay);
    }

    public static void SetState(Frame f, GameState state)
    {
        f.Global->CurrentState = state;
    }
}
```

This system manages state transitions and enables/disables other systems based on the current game state.

### 2. Ship Movement System

The `ShipMovementSystem` handles ship movement and trail mechanics:

```csharp
unsafe class ShipMovementSystem : SystemMainThreadFilter<ShipFilter>, IGameState_Game
{
    public override void Update(Frame f, ref ShipFilter filter)
    {
        // Process player input
        Input* input = f.GetPlayerInput(filter.Link->Player);
        
        // Update ship state based on input
        filter.Player->SteerAmount = FPMath.Clamp(input->steer, -1, 1);
        filter.Player->IsBoosting = input->boost && filter.Player->BoostAmount > 0;
        filter.Player->IsBraking = input->brake;
        
        // Apply steering
        FP steerRate = filter.Player->SteerAmount * spec.steerRate;
        if (filter.Player->IsBraking) steerRate /= 2;
        filter.Transform->Rotation *= FPQuaternion.AngleAxis(steerRate * f.DeltaTime, FPVector3.Up);
        
        // Apply movement
        FP speed = filter.Player->IsBoosting ? spec.speedBoosting : input->brake ? spec.speedBraking : spec.speedNormal;
        
        // Handle boost consumption
        if (filter.Player->IsBoosting)
        {
            filter.Player->BoostAmount -= spec.boostDrain * f.DeltaTime;
            if (filter.Player->BoostAmount < 0) filter.Player->BoostAmount = 0;
        }
        
        // Update position
        filter.Transform->Position += filter.Transform->Forward * speed * f.DeltaTime;
        
        // Orient to sphere surface
        Orient(f, filter.Transform, filter.Player);
        
        // Update trail segments
        // Implementation details...
    }
    
    // Additional methods...
}
```

### 3. Collision Systems

Collision detection is handled by a pair of systems:

```csharp
// Injection system creates physics queries
public unsafe class ShipCollisionInjectionSystem : SystemMainThread, IGameState_Game
{
    public override void Update(Frame f)
    {
        // Create linecast queries between segment points
        // Implementation details...
    }
}

// Retrieval system processes query results
public unsafe class ShipCollisionRetrievalSystem : SystemMainThread, IGameState_Game
{
    public override void Update(Frame f)
    {
        // Process linecast query results
        // Handle collisions between ships and trails
        // Implementation details...
    }
}
```

### 4. Pickup System

The `PickupSystem` manages collectible items:

```csharp
unsafe class PickupSystem<P> : SystemSignalsOnly, ISignalOnTriggerEnter3D, IGameState_Game where P : unmanaged, IComponent
{
    public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
    {
        // Handle pickup collection
        if (!f.TryGet(info.Other, out P pickup)) return;
        if (!f.Unsafe.TryGetPointer(info.Entity, out Ship* ship)) return;
        if (!f.TryGet(info.Entity, out PlayerLink link)) return;

        // Apply pickup effect based on type
        if (pickup is TrailPickup)
        {
            // Increase score
            int oldScore = ship->Score;
            ship->Score += ship->Score > 0 ? 5 : 2;
            f.Events.PlayerScoreChanged(link.Player, oldScore, ship->Score);
        }
        else if (pickup is BoostPickup)
        {
            // Add boost energy
            ship->BoostAmount += f.RuntimeConfig.boostPickupValue;
            if (ship->BoostAmount > 100) ship->BoostAmount = 100;
        }

        // Send event and spawn new pickup
        f.Events.PickupCollected(info.Entity, ComponentTypeId<P>.Id);
        f.Destroy(info.Other);

        if (f.ComponentCount<P>() < SpawnCap(f))
        {
            SpawnPickup(f);
        }
    }
    
    // Implementation details...
}
```

## Unity-Quantum Integration

The integration between Quantum and Unity happens primarily through:

1. **EntityView Components**: Create visual representations of Quantum entities
2. **Event Handling**: Process events from Quantum simulation to update visuals
3. **Input Processing**: Capture Unity input and send it to Quantum

Example of the ShipView class:

```csharp
public unsafe class ShipView : MonoBehaviour
{
    // Implementation details...
    
    private void Update()
    {
        // Get ship data from Quantum
        Ship* player = game.Frames.Predicted.Unsafe.GetPointer<Ship>(EntityRef);
        
        // Update visual representation based on simulation data
        // Implementation details...
        
        // Apply visual effects for boosting, steering, etc.
        // Implementation details...
    }
    
    // Event handlers for Quantum events
    void PlayerDataChangedCallback(EventPlayerDataChanged evt)
    {
        // Handle player data changes
        // Implementation details...
    }
    
    void PlayerVulnerableCallback(EventPlayerVulnerable evt)
    {
        // Handle player vulnerability changes
        // Implementation details...
    }
}
```

## Key Game Mechanics

### 1. Spherical Movement

Ships move on the surface of a sphere, with orientation automatically adjusted:

```csharp
public static void Orient(Frame f, Transform3D* tf, Ship* player)
{
    MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);

    FPVector3 n = mm.mapOrigin - tf->Position;
    tf->Position =
        (tf->Position - mm.mapOrigin).Normalized
        * (mm.mapRadius - spec.radius)
        + mm.mapOrigin;

    tf->Rotation = FPQuaternion.FromToRotation(tf->Up, n) * tf->Rotation;
}
```

### 2. Trail System

Ships leave a trail of segments behind them:

```csharp
Collections.QList<FPVector3> segs = f.ResolveList(filter.Player->Segments);

if (segs.Count < filter.Player->Score)
{
    segs.Add(filter.Transform->Position);
}

// Update segment positions
for (int i = segs.Count - 2; i >= 0; i--)
{
    MoveDistance(f, segs.GetPointer(i), segs.GetPointer(i + 1), spec.segmentDistance, spec.radius);
}
```

### 3. Reconnection Mechanic

Players can reconnect their trail to score points:

```csharp
// Check if this is a self-collision with the head segment
if (i == 0 && hit.Entity == ship.Entity && ship.Player->Score > 20)
{
    // Evaluate alignment quality
    ship.Player->Segments.Resolve(f, out var segs);
    FP dot = FPVector3.Dot(ship.Transform->Forward,
        (segs[1] - segs[0]).Normalized);
        
    if (dot > spec.connectThreshold)
    {
        // Award points based on trail length
        f.Global->playerData.Resolve(f, out var dict);
        dict.TryGetValuePointer(ship.Link->Player, out var pd);
        pd->points += (short)segs.Count;
        
        // Fire events and respawn player
        // Implementation details...
    }
}
```

## Game Configuration

The game is configured through several asset objects, primarily:

### ShipSpec

```csharp
public partial class ShipSpec : AssetObject
{
    public FP radius;
    public FP speedNormal;
    public FP speedBoosting;
    public FP speedBraking;
    public FP steerRate;
    public FP segmentDistance;
    public FP boostDrain;
    [Range(0, 1)] public FP connectThreshold;
    public FP despawnAfterConnectDelay;
}
```

### MapMeta

```csharp
public class MapMeta : AssetObject
{
    public FPVector3 mapOrigin;
    public FP mapRadius;
}
```

## How To Use These Notes

- Start with the Project Overview to understand the game's architecture
- Explore the Ship Movement System to understand the core mechanics
- Follow other documents based on specific features you're interested in
- Use the code examples as reference when implementing your own arena game

The focus is on presenting accurate code examples that can be used as templates for your own Quantum projects.

---

# 02-game-state-management.md

# Quantum Motor Dome Game State Management

This document explains the state management system in Quantum Motor Dome, covering how the game transitions between different states and how systems are activated/deactivated accordingly.

## Game State Definition

The game state is defined as an enum in the Quantum DSL:

```qtn
enum GameState
{
	Off = 0,
	Lobby,
	Pregame,
	Intro,
	Countdown,
	Game,
	Outro,
	Postgame
}
```

These states represent the different phases of gameplay:

- **Off**: Initial state before game starts
- **Lobby**: Players are joining and waiting
- **Pregame**: Preparing for the game to start
- **Intro**: Playing introduction sequence
- **Countdown**: Counting down to start the game
- **Game**: Main gameplay phase
- **Outro**: End of game sequence
- **Postgame**: Showing results before returning to lobby

## Global State Variables

The global state variables keep track of the current game state:

```qtn
global
{
	FrameTimer clock;
	dictionary<Int32, PlayerData> playerData;
	
	FrameTimer StateTimer;
    GameState DelayedState;
    
    GameState CurrentState;
    GameState PreviousState;
}
```

Key variables:
- `CurrentState`: The active game state
- `PreviousState`: The previous game state (for transition events)
- `StateTimer`: Timer for delayed state transitions
- `DelayedState`: The state to transition to when the timer expires

## System Interfaces

Systems can implement game state interfaces to specify which states they should be active in:

```csharp
public interface IGameState { }
public interface IGameState_Lobby : IGameState { }
public interface IGameState_Pregame : IGameState { }
public interface IGameState_Intro : IGameState { }
public interface IGameState_Countdown : IGameState { }
public interface IGameState_Game : IGameState { }
public interface IGameState_Outro : IGameState { }
public interface IGameState_Postgame : IGameState { }
```

Example implementation:

```csharp
// This system is only active during the Game state
public unsafe class ShipMovementSystem : SystemMainThreadFilter<ShipFilter>, IGameState_Game
{
    public override bool StartEnabled => false;
    
    // System implementation...
}

// This system is active during both Game and Countdown states
public unsafe class PickupSystem<P> : SystemSignalsOnly, ISignalOnTriggerEnter3D, IGameState_Game, IGameState_Countdown
{
    public override bool StartEnabled => false;
    
    // System implementation...
}
```

## GameStateSystem

The `GameStateSystem` is the central component that manages state transitions and system activation:

```csharp
unsafe class GameStateSystem : SystemMainThread
{
    static readonly ReadOnlyDictionary<GameState, Type> stateTable =
        new(new Dictionary<GameState, Type>()
        {
            { GameState.Lobby, typeof(IGameState_Lobby) },
            { GameState.Pregame, typeof(IGameState_Pregame) },
            { GameState.Intro, typeof(IGameState_Intro) },
            { GameState.Countdown, typeof(IGameState_Countdown) },
            { GameState.Game, typeof(IGameState_Game) },
            { GameState.Outro, typeof(IGameState_Outro) },
            { GameState.Postgame, typeof(IGameState_Postgame) }
        });

    public override void OnInit(Frame f)
    {
        // immediately start the game
        f.Global->StateTimer = FrameTimer.FromSeconds(f, 0);
        
        f.Global->DelayedState = 0;
        f.Global->PreviousState = 0;
        SetState(f, GameState.Lobby);
    }

    public override void Update(Frame f)
    {
        var timer = f.Global->StateTimer;
        bool didStateTimerExpireThisFrame = timer.IsRunning(f) == false && timer.TargetFrame == f.Number;
        if (didStateTimerExpireThisFrame)
        {
            f.Global->StateTimer = FrameTimer.None;
            SetState(f, f.Global->DelayedState);
            f.Global->DelayedState = 0;
        }

        if (f.Global->CurrentState != f.Global->PreviousState)
        {
            if (stateTable.TryGetValue(f.Global->CurrentState, out Type t))
            {
                // Disable systems that should not be active in the current state
                foreach (SystemBase sys in f.SystemsAll
                    .Where(s => s.GetType().GetInterfaces().Contains(typeof(IGameState)) && !s.GetType().GetInterfaces().Contains(t)))
                {
                    f.SystemDisable(sys.GetType());
                }

                // Enable systems that should be active in the current state
                foreach (SystemBase sys in f.SystemsAll
                    .Where(s => s.GetType().GetInterfaces().Contains(typeof(IGameState)) && s.GetType().GetInterfaces().Contains(t)))
                {
                    if (!f.SystemIsEnabledSelf(sys.GetType()))
                        f.SystemEnable(sys.GetType());
                }
            }

            // Fire event for state change
            f.Events.GameStateChanged(f.Global->CurrentState, f.Global->PreviousState);
            f.Global->PreviousState = f.Global->CurrentState;
        }
    }

    public static void SetStateDelayed(Frame f, GameState state, FP delay)
    {
        f.Global->DelayedState = state;
        f.Global->StateTimer = FrameTimer.FromSeconds(f, delay);
    }

    public static void SetState(Frame f, GameState state)
    {
        f.Global->CurrentState = state;
    }
}
```

This system has three main functions:
1. **Immediate state transitions** through `SetState()`
2. **Delayed state transitions** through `SetStateDelayed()`
3. **System activation/deactivation** based on the current state

## State-Specific Systems

Various systems in the game implement state interfaces to be activated only during specific game states:

### Lobby State Systems

```csharp
public unsafe class LobbySystem : SystemMainThread, IGameState_Lobby
{
    public override bool StartEnabled => false;

    public override void Update(Frame f)
    {
        // Check if all players are ready
        bool allReady = true;
        foreach (var key in f.Global->playerData.Resolve(f, out var dict).Keys)
        {
            var pd = dict[key];
            if (!pd.ready)
            {
                allReady = false;
                break;
            }
        }

        // If all players are ready, transition to Pregame
        if (allReady && f.Global->playerData.Resolve(f, out _).Count > 0)
        {
            GameStateSystem.SetState(f, GameState.Pregame);
        }
    }
}
```

### Pregame State Systems

```csharp
public unsafe class PregameSystem : SystemMainThread, IGameState_Pregame
{
    public override bool StartEnabled => false;

    public override void OnEnabled(Frame f)
    {
        // Spawn map entities
        // Implementation details...
        
        // Transition to Intro after setup
        GameStateSystem.SetState(f, GameState.Intro);
    }
}
```

### Intro State Systems

```csharp
public unsafe class IntroSystem : SystemMainThread, IGameState_Intro
{
    public override bool StartEnabled => false;

    public override void OnEnabled(Frame f)
    {
        // Reset player data
        f.Global->playerData.Resolve(f, out var dict).Clear();
        foreach (var (entity, link) in f.Unsafe.GetComponentBlockIterator<PlayerLink>())
        {
            dict.Add(link.Player, new PlayerData());
        }
        
        // Wait for player input to continue
        // Implementation details...
    }
    
    // Process intro finished command
    public void IntroFinished(Frame f, IntroFinishedCommand cmd)
    {
        GameStateSystem.SetState(f, GameState.Countdown);
    }
}
```

### Countdown State Systems

```csharp
public unsafe class CountdownSystem : SystemMainThread, IGameState_Countdown
{
    public override bool StartEnabled => false;
    FP countdownTime = 3;
    
    public override void OnEnabled(Frame f)
    {
        // Start countdown timer
        f.Global->clock = FrameTimer.FromSeconds(f, countdownTime);
    }

    public override void Update(Frame f)
    {
        // Check if countdown has finished
        if (!f.Global->clock.IsRunning(f))
        {
            GameStateSystem.SetState(f, GameState.Game);
        }
    }
}
```

### Game State Systems

```csharp
public unsafe class GameClockSystem : SystemMainThread, IGameState_Game
{
    public override bool StartEnabled => false;
    FP gameTime = 180; // 3 minutes
    
    public override void OnEnabled(Frame f)
    {
        // Start game timer
        f.Global->clock = FrameTimer.FromSeconds(f, gameTime);
    }

    public override void Update(Frame f)
    {
        // Check if game time has expired
        if (!f.Global->clock.IsRunning(f))
        {
            GameStateSystem.SetState(f, GameState.Outro);
        }
    }
}
```

### Outro State Systems

```csharp
public unsafe class OutroSystem : SystemMainThread, IGameState_Outro
{
    public override bool StartEnabled => false;
    FP outroTime = 5;
    
    public override void OnEnabled(Frame f)
    {
        // Start outro timer
        f.Global->clock = FrameTimer.FromSeconds(f, outroTime);
    }

    public override void Update(Frame f)
    {
        // Check if outro has finished
        if (!f.Global->clock.IsRunning(f))
        {
            GameStateSystem.SetState(f, GameState.Postgame);
        }
    }
}
```

### Postgame State Systems

```csharp
public unsafe class PostgameSystem : SystemMainThread, IGameState_Postgame
{
    public override bool StartEnabled => false;
    FP postgameTime = 10;
    
    public override void OnEnabled(Frame f)
    {
        // Calculate final scores
        // Implementation details...
        
        // Start postgame timer
        f.Global->clock = FrameTimer.FromSeconds(f, postgameTime);
    }

    public override void Update(Frame f)
    {
        // Check if postgame has finished
        if (!f.Global->clock.IsRunning(f))
        {
            // Return to lobby
            GameStateSystem.SetState(f, GameState.Lobby);
        }
    }
}
```

## Delayed State Transitions

The system supports delayed state transitions using `FrameTimer`:

```csharp
// Transition to Postgame after 5 seconds
GameStateSystem.SetStateDelayed(f, GameState.Postgame, 5);
```

Implementation in GameStateSystem:

```csharp
public static void SetStateDelayed(Frame f, GameState state, FP delay)
{
    f.Global->DelayedState = state;
    f.Global->StateTimer = FrameTimer.FromSeconds(f, delay);
}
```

## Game State Events

State changes trigger events to synchronize with the Unity view:

```qtn
synced event GameStateChanged{ GameState NewState; GameState OldState; }
```

These events are subscribed to in Unity:

```csharp
public class GameStateBridge : MonoBehaviour
{
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventGameStateChanged>(this, OnGameStateChanged);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventGameStateChanged>(this);
    }
    
    private void OnGameStateChanged(EventGameStateChanged evt)
    {
        switch (evt.NewState)
        {
            case GameState.Lobby:
                UIScreen.Focus(InterfaceManager.Instance.lobbyScreen);
                break;
            case GameState.Pregame:
                // Implementation details...
                break;
            case GameState.Intro:
                // Play intro sequence
                break;
            case GameState.Countdown:
                UIScreen.Focus(InterfaceManager.Instance.countdownScreen);
                break;
            case GameState.Game:
                UIScreen.Focus(InterfaceManager.Instance.hudScreen);
                break;
            case GameState.Outro:
                // Play outro sequence
                break;
            case GameState.Postgame:
                UIScreen.Focus(InterfaceManager.Instance.resultsScreen);
                break;
        }
    }
}
```

## Integration with Player State

Player states can also affect game state:

```csharp
// In LobbySystem
public override void Update(Frame f)
{
    // Check if all players are ready
    bool allReady = true;
    foreach (var key in f.Global->playerData.Resolve(f, out var dict).Keys)
    {
        var pd = dict[key];
        if (!pd.ready)
        {
            allReady = false;
            break;
        }
    }

    // If all players are ready, transition to Pregame
    if (allReady && f.Global->playerData.Resolve(f, out _).Count > 0)
    {
        GameStateSystem.SetState(f, GameState.Pregame);
    }
}
```

## Best Practices

1. **Interface-Based Activation**: Use interfaces to specify when systems should be active
2. **Clear State Transitions**: Create clear paths between states
3. **Event-Based Synchronization**: Use events to keep Unity view in sync with game state
4. **Timer-Based Progression**: Use timers for automated state progression
5. **Centralized State Management**: Use a single system for all state transitions
6. **Declarative System Design**: Systems declare which states they belong to
7. **Delayed State Transitions**: Support both immediate and delayed transitions

---

# 03-input-system.md

# Quantum Motor Dome Input System

This document details the input system used in the Quantum Motor Dome project, covering how player input is defined, processed, and applied to ships within the deterministic simulation.

## Input Definition

The Quantum Motor Dome input structure is defined in `input.qtn` as follows:

```qtn
input
{
	FP steer;
	bool boost;
	bool brake;
}
```

This structure contains:
- **steer**: Analog value for steering the ship (-1 to 1)
- **boost**: Boolean for activating boost
- **brake**: Boolean for braking/slowing down

## Unity Input Collection

The Unity-side input is captured in the `LocalInput` class, which subscribes to Quantum's input polling callback:

```csharp
public class LocalInput : MonoBehaviour
{
	private void OnEnable()
	{
		QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
	}

	public void PollInput(CallbackPollInput callback)
	{
		Quantum.Input i = new()
		{
			steer = UnityEngine.Input.GetAxis("Horizontal").ToFP(),
			boost = UnityEngine.Input.GetButton("Boost"),
			brake = UnityEngine.Input.GetButton("Brake")
		};

		callback.SetInput(i, DeterministicInputFlags.Repeatable);
	}
}
```

Key aspects of this implementation:
1. **Subscription**: Subscribes to the `CallbackPollInput` event from Quantum
2. **Input Mapping**: Maps Unity input to Quantum input structure
3. **Conversion**: Converts Unity's float values to Quantum's deterministic FP type
4. **Flags**: Uses `DeterministicInputFlags.Repeatable` to ensure deterministic behavior

## Input Application

The input is applied in the `ShipMovementSystem`, which processes player input and updates ship movement:

```csharp
unsafe class ShipMovementSystem : SystemMainThreadFilter<ShipFilter>, IGameState_Game
{
    public override void Update(Frame f, ref ShipFilter filter)
    {
        if (f.Has<Delay>(filter.Entity)) return;

        // Get input from the player
        Input* input = f.GetPlayerInput(filter.Link->Player);

        // Update ship state based on input
        filter.Player->SteerAmount = FPMath.Clamp(input->steer, -1, 1);
        filter.Player->IsBoosting = input->boost && filter.Player->BoostAmount > 0;
        filter.Player->IsBraking = input->brake;

        // Apply steering
        FP steerRate = filter.Player->SteerAmount * spec.steerRate;
        if (filter.Player->IsBraking) steerRate /= 2; // Reduce steering rate when braking
        filter.Transform->Rotation *= FPQuaternion.AngleAxis(steerRate * f.DeltaTime, FPVector3.Up);
        
        // Calculate speed based on input
        FP speed = filter.Player->IsBoosting ? 
            spec.speedBoosting : 
            input->brake ? spec.speedBraking : spec.speedNormal;

        // Handle boost consumption
        if (filter.Player->IsBoosting)
        {
            filter.Player->BoostAmount -= spec.boostDrain * f.DeltaTime;
            if (filter.Player->BoostAmount < 0) filter.Player->BoostAmount = 0;
        }

        // Apply movement
        filter.Transform->Position += filter.Transform->Forward * speed * f.DeltaTime;
        
        // Implementation details for trail and orientation continue...
    }
}
```

Key aspects of input application:
1. **Input Retrieval**: Uses `f.GetPlayerInput(filter.Link->Player)` to get input for the specific player
2. **State Mapping**: Maps input values to ship state properties
3. **Conditional Logic**: Applies effects based on combinations of input (e.g., boosting requires both boost button and available boost energy)
4. **Resource Management**: Consumes boost resource when boost input is active

## Input Filters

The `ShipMovementSystem` uses a filter to process only entities with the required components:

```csharp
public struct ShipFilter
{
    public EntityRef Entity;
    public Transform3D* Transform;
    public Ship* Player;
    public PlayerLink* Link;
}
```

This ensures that input processing only happens for valid ships that have:
- A Transform3D component for position and rotation
- A Ship component for ship-specific properties
- A PlayerLink component to connect the ship to a player

## Player Commands

In addition to regular input polling, the game also supports command-based input for specific actions:

```csharp
public struct IntroFinishedCommand : ICommand
{
    public void Execute(Frame f)
    {
        foreach (var system in f.SystemsAll.OfType<IntroSystem>())
        {
            system.IntroFinished(f, this);
        }
    }
}
```

Commands are triggered from Unity:

```csharp
public void SendIntroFinishedCommand()
{
    if (QuantumRunner.Default?.Game?.PlayerIsLocal(LocalData.LocalPlayerRef) == true)
    {
        QuantumRunner.Default.Game.SendCommand(new IntroFinishedCommand());
    }
}
```

Key aspects of command-based input:
1. **Command Interface**: Implements the `ICommand` interface
2. **Targeted Execution**: Commands target specific systems
3. **Local Validation**: Only the local player sends commands
4. **Non-Continuous Actions**: Used for discrete actions rather than continuous input

## Pause and UI Input

The `LocalInput` class also handles input for UI and pausing:

```csharp
private void Update()
{
    if (UnityEngine.Input.GetKeyDown(KeyCode.P))
    {
        if (UIScreen.activeScreen == InterfaceManager.Instance.hudScreen)
            UIScreen.Focus(InterfaceManager.Instance.pauseScreen);
        else if (UIScreen.ScreenInHierarchy(InterfaceManager.Instance.hudScreen))
            UIScreen.activeScreen.BackTo(InterfaceManager.Instance.hudScreen);
    }
}
```

This approach separates UI/pausing input (handled in Unity) from gameplay input (sent to Quantum).

## Input Response Visualization

The Unity-side `ShipView` class visualizes the ship's response to input:

```csharp
public unsafe class ShipView : MonoBehaviour
{
    public float oversteerAmount = 10;
    public float rollAmount = 45;
    public float steerVisualRate = 20;
    
    private void Update()
    {
        Ship* player = game.Frames.Predicted.Unsafe.GetPointer<Ship>(EntityRef);
        
        // Apply visual steering effects
        Quaternion rollRot = Quaternion.AngleAxis(player->SteerAmount.AsFloat * -rollAmount, Vector3.forward);
        Quaternion oversteerRot = Quaternion.Euler(0, player->SteerAmount.AsFloat * oversteerAmount, 0);
        Quaternion tgtRot = oversteerRot * rollRot;
        Quaternion srcRot = pivot.localRotation;
        pivot.localRotation = Quaternion.RotateTowards(
            srcRot, 
            tgtRot, 
            Mathf.Sqrt(Quaternion.Angle(srcRot, tgtRot)) * steerVisualRate * Time.deltaTime
        );
        
        // Handle boost visualization
        if (player->IsBoosting && !wasBoosting) boostSrc.Play();
        else if (!player->IsBoosting && wasBoosting) boostSrc.Stop();
        wasBoosting = player->IsBoosting;
    }
}
```

Key aspects of input visualization:
1. **Steering Effects**: Applies roll and oversteer visual effects based on steering input
2. **Smoothing**: Smoothly interpolates between visual states
3. **Audio Feedback**: Plays audio effects when boost state changes
4. **State Tracking**: Tracks previous state to detect changes

## Input Configuration

Input sensitivities and effects are configured in the `ShipSpec` asset:

```csharp
public partial class ShipSpec : AssetObject
{
    public FP speedNormal;
    public FP speedBoosting;
    public FP speedBraking;
    public FP steerRate;
    public FP boostDrain;
}
```

This allows for adjustment of:
- **Movement Speeds**: Normal, boosting, and braking speeds
- **Steering Sensitivity**: How quickly the ship turns in response to input
- **Boost Consumption**: How quickly boost energy depletes when used

## Input Flow

The complete input flow in Quantum Motor Dome follows this sequence:

1. **Unity** captures raw input via `LocalInput.PollInput`
2. Input is converted to deterministic types and sent to Quantum
3. **Quantum** processes the input in `ShipMovementSystem.Update`
4. Ship state is updated based on input values
5. Physics calculations are applied based on the updated state
6. The ship's position, rotation, and other properties are updated
7. **Unity** retrieves the updated state from Quantum
8. **ShipView** updates the visual representation based on the ship state

## Best Practices

1. **Deterministic Conversion**: Always convert Unity input to deterministic types (FP) before sending to Quantum
2. **Input Validation**: Validate input ranges (e.g., clamp steer value between -1 and 1)
3. **Resource Checks**: Check resource availability before applying effects (e.g., boost requires energy)
4. **Separation of Concerns**: Keep gameplay input (Quantum) separate from UI input (Unity)
5. **Smooth Visualization**: Apply smoothing and visual enhancements to make input response feel natural
6. **Configurable Parameters**: Store input sensitivities and effects in configurable assets
7. **Command Pattern**: Use commands for discrete, non-continuous actions
8. **Contextual Behavior**: Adjust input response based on context (e.g., reduced steering while braking)

---

# 04-ship-movement-system.md

# Quantum Motor Dome Ship Movement System

This document explains the ship movement system in Quantum Motor Dome, covering the core physics, movement mechanics, and trail implementation that forms the foundation of the gameplay.

## Core Components

The ship movement system consists of several interrelated components:

### Ship Component

The `Ship` component is the central element that defines a player-controlled ship:

```qtn
component Ship
{
	[Header("Runtime Properties")]
	FP BoostAmount;
	int Score;
	list<FPVector3> Segments;
	list<PhysicsQueryRef> SegmentQueries;

	[Header("Movement State")]
	FP SteerAmount;
	bool IsBraking;
	bool IsBoosting;
}
```

Key properties:
- `BoostAmount`: Current boost energy (0-100)
- `Score`: Player's current score (correlates to trail length)
- `Segments`: List of positions forming the ship's trail
- `SegmentQueries`: Physics queries for collision detection
- Movement state flags for steering, braking, and boosting

### ShipSpec Asset

The `ShipSpec` asset defines the movement characteristics of ships:

```csharp
public partial class ShipSpec : AssetObject
{
    public FP radius;
    public FP speedNormal;
    public FP speedBoosting;
    public FP speedBraking;
    public FP steerRate;
    public FP segmentDistance;
    public FP boostDrain;
    [Range(0, 1)] public FP connectThreshold;
    public FP despawnAfterConnectDelay;
}
```

Key properties:
- `radius`: Size of the ship for collision and positioning
- `speedNormal/speedBoosting/speedBraking`: Movement speeds under different states
- `steerRate`: How quickly the ship turns
- `segmentDistance`: Distance between trail segments
- `boostDrain`: How quickly boost energy depletes when used
- `connectThreshold`: Alignment threshold for successful trail reconnection
- `despawnAfterConnectDelay`: Delay before respawning after a successful reconnection

### MapMeta Asset

The `MapMeta` asset defines the spherical arena:

```csharp
public class MapMeta : AssetObject
{
    public FPVector3 mapOrigin;
    public FP mapRadius;
}
```

## ShipFilter

The movement system uses a filter to efficiently process only entities with the required components:

```csharp
public struct ShipFilter
{
    public EntityRef Entity;
    public Transform3D* Transform;
    public Ship* Player;
    public PlayerLink* Link;
}
```

## Ship Movement Implementation

The core ship movement logic is implemented in the `ShipMovementSystem`:

```csharp
unsafe class ShipMovementSystem : SystemMainThreadFilter<ShipFilter>, IGameState_Game
{
    public override bool StartEnabled => false;

    static ShipSpec spec;

    public override void OnInit(Frame f)
    {
        spec = f.FindAsset<ShipSpec>(f.SimulationConfig.shipSpec.Id);
    }

    public override void Update(Frame f, ref ShipFilter filter)
    {
        if (f.Has<Delay>(filter.Entity)) return;

        Input* input = f.GetPlayerInput(filter.Link->Player);

        Collections.QList<FPVector3> segs =
            f.ResolveList(filter.Player->Segments);

        if (segs.Count < filter.Player->Score)
        {
            segs.Add(filter.Transform->Position);
        }
        
        // Update ship state based on input
        filter.Player->SteerAmount = FPMath.Clamp(input->steer, -1, 1);
        filter.Player->IsBoosting = input->boost && filter.Player->BoostAmount > 0;
        filter.Player->IsBraking = input->brake;

        // Apply steering
        FP steerRate = filter.Player->SteerAmount * spec.steerRate;
        if (filter.Player->IsBraking) steerRate /= 2;

        filter.Transform->Rotation *= FPQuaternion.AngleAxis(steerRate * f.DeltaTime, FPVector3.Up);
        
        // Calculate speed based on input state
        FP speed = filter.Player->IsBoosting ? 
            spec.speedBoosting : 
            input->brake ? spec.speedBraking : spec.speedNormal;

        // Handle boost energy consumption
        if (filter.Player->IsBoosting)
        {
            filter.Player->BoostAmount -= spec.boostDrain * f.DeltaTime;
            if (filter.Player->BoostAmount < 0) filter.Player->BoostAmount = 0;
        }

        // Apply movement
        filter.Transform->Position += filter.Transform->Forward * speed * f.DeltaTime;
        
        // Orient to sphere surface
        Orient(f, filter.Transform, filter.Player);
        
        // Update trail segments
        if (segs.Count > 0)
        {
            FPVector3* ptr = segs.GetPointer(segs.Count - 1);
            *ptr = filter.Transform->Position;

            for (int i = segs.Count - 2; i >= 0; i--)
            {
                MoveDistance(f, segs.GetPointer(i), segs.GetPointer(i + 1), spec.segmentDistance, spec.radius);
            }
        }
    }
}
```

The system performs several key operations:
1. **Input Processing**: Retrieves and applies player input
2. **State Update**: Updates ship state based on input
3. **Steering**: Applies rotation based on steering input
4. **Speed Calculation**: Determines speed based on current state (normal/boosting/braking)
5. **Boost Management**: Consumes boost energy when boosting
6. **Position Update**: Moves the ship based on current speed and direction
7. **Orientation**: Ensures the ship stays properly oriented on the sphere
8. **Trail Management**: Updates the positions of trail segments

## Spherical Movement

One of the unique aspects of the game is that ships move on the surface of a sphere. This is handled by the `Orient` method:

```csharp
public static void Orient(Frame f, Transform3D* tf, Ship* player)
{
    MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);

    // Calculate vector from sphere center to ship
    FPVector3 n = mm.mapOrigin - tf->Position;
    
    // Project ship onto sphere surface at the correct radius
    tf->Position =
        (tf->Position - mm.mapOrigin).Normalized
        * (mm.mapRadius - spec.radius)
        + mm.mapOrigin;

    // Rotate ship to align with sphere surface
    tf->Rotation = FPQuaternion.FromToRotation(tf->Up, n) * tf->Rotation;
}
```

This method:
1. Gets the vector from the sphere center to the ship
2. Projects the ship onto the sphere surface, accounting for ship radius
3. Reorients the ship to align with the sphere surface

## Trail System

The trail system is a core gameplay mechanic. Each ship leaves a trail of segments behind it, which is implemented as a list of positions:

```csharp
// Add a new segment if needed
if (segs.Count < filter.Player->Score)
{
    segs.Add(filter.Transform->Position);
}

// Update the most recent segment to follow the ship
if (segs.Count > 0)
{
    FPVector3* ptr = segs.GetPointer(segs.Count - 1);
    *ptr = filter.Transform->Position;

    // Update all other segments to maintain proper spacing
    for (int i = segs.Count - 2; i >= 0; i--)
    {
        MoveDistance(f, segs.GetPointer(i), segs.GetPointer(i + 1), spec.segmentDistance, spec.radius);
    }
}
```

The `MoveDistance` method ensures that trail segments:
1. Maintain proper spacing between segments
2. Stay on the sphere surface
3. Form a smooth trail behind the ship

```csharp
static void MoveDistance(Frame f, FPVector3* src, FPVector3* dest, FP distance, FP mapOffset)
{
    MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);

    FPVector3 d = *src - *dest;

    if (d.SqrMagnitude > distance * distance)
    {
        // Move segment toward next segment to maintain spacing
        *src = *dest + d.Normalized * distance;
        
        // Project segment onto sphere surface
        *src = (*src - mm.mapOrigin).Normalized
            * (mm.mapRadius - mapOffset)
            + mm.mapOrigin;
    }
}
```

## Trail Growth

The `Score` property of the `Ship` component determines how many trail segments the ship should have. When the score increases (e.g., through pickup collection), the trail grows:

```csharp
public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
{
    // Skip non-pickup collisions
    if (!f.TryGet(info.Other, out TrailPickup pickup)) return;
    if (!f.Unsafe.TryGetPointer(info.Entity, out Ship* ship)) return;
    if (!f.TryGet(info.Entity, out PlayerLink link)) return;

    // Increase score (trail length)
    int oldScore = ship->Score;
    ship->Score += ship->Score > 0 ? 5 : 2;
    f.Events.PlayerScoreChanged(link.Player, oldScore, ship->Score);
    
    // Destroy pickup
    f.Destroy(info.Other);
    
    // Spawn new pickup if needed
    if (f.ComponentCount<TrailPickup>() < PickupSystem<TrailPickup>.SpawnCap(f))
    {
        PickupSystem<TrailPickup>.SpawnPickup(f);
    }
}
```

## Collision Queries

The game needs to detect collisions between ships and trails. This is handled by two systems working together:

1. **ShipCollisionInjectionSystem**: Creates physics queries for each trail segment:

```csharp
public unsafe class ShipCollisionInjectionSystem : SystemMainThread, IGameState_Game
{
    public override void Update(Frame f)
    {
        foreach (var (entity, ship) in f.Unsafe.GetComponentBlockIterator<Ship>())
        {
            if (f.Has<Delay>(entity)) continue;
            
            // Get ship segments
            Collections.QList<FPVector3> segments = f.ResolveList(ship.Segments);
            if (segments.Count < 2) continue;
            
            // Free existing queries
            Collections.QList<PhysicsQueryRef> queries = f.ResolveList(ship.SegmentQueries);
            foreach (var query in queries)
            {
                f.Physics3D.FreeQuery(query);
            }
            queries.Clear();
            
            // Create linecast queries between segments
            for (int i = 0; i < segments.Count - 1; i++)
            {
                FPVector3 start = segments[i];
                FPVector3 end = segments[i + 1];
                
                // Create linecast query
                PhysicsQueryRef query = f.Physics3D.Linecast(
                    start, 
                    end, 
                    0, 
                    entity
                );
                queries.Add(query);
            }
        }
    }
}
```

2. **ShipCollisionRetrievalSystem**: Processes the results of those queries:

```csharp
public unsafe class ShipCollisionRetrievalSystem : SystemMainThread, IGameState_Game
{
    public override void Update(Frame f)
    {
        foreach (var (entity, ship) in f.Unsafe.GetComponentBlockIterator<Ship>())
        {
            if (f.Has<Delay>(entity) || f.Has<SpawnProtection>(entity)) continue;
            
            // Process linecast results
            Collections.QList<PhysicsQueryRef> queries = f.ResolveList(ship.SegmentQueries);
            for (int i = 0; i < queries.Count; i++)
            {
                PhysicsQueryRef query = queries[i];
                var results = f.Physics3D.GetLinecastHits(query);
                
                foreach (var hit in results)
                {
                    // Skip hits with self and ships with spawn protection
                    if (hit.Entity == entity) continue;
                    if (f.Has<SpawnProtection>(hit.Entity)) continue;
                    
                    // Trigger collision
                    HandleCollision(f, entity, hit.Entity, i);
                }
            }
        }
    }
    
    private void HandleCollision(Frame f, EntityRef shipEntity, EntityRef hitEntity, int segmentIndex)
    {
        // Implementation of collision response
        // (e.g., destroy ship, spawn explosion, etc.)
    }
}
```

## Trail Reconnection

A key gameplay mechanic is the ability to reconnect a ship's trail to itself, scoring points:

```csharp
private void HandleCollision(Frame f, EntityRef shipEntity, EntityRef hitEntity, int segmentIndex)
{
    // Skip if not a ship
    if (!f.Unsafe.TryGetComponent(hitEntity, out Ship hitShip)) return;
    
    // Check if we hit our own trail
    if (hitEntity == shipEntity)
    {
        // Check if this is the head segment reconnecting to the tail
        if (segmentIndex == 0)
        {
            ShipSpec spec = f.FindAsset<ShipSpec>(f.SimulationConfig.shipSpec.Id);
            Ship* ship = f.Unsafe.GetPointer<Ship>(shipEntity);
            
            // Get segments
            Collections.QList<FPVector3> segments = f.ResolveList(ship->Segments);
            if (segments.Count < spec.minReconnectSegments) return;
            
            // Check alignment quality
            Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(shipEntity);
            FP dot = FPVector3.Dot(
                transform->Forward,
                (segments[1] - segments[0]).Normalized
            );
            
            // Reconnection successful if alignment is good
            if (dot > spec.connectThreshold)
            {
                // Award points
                f.Unsafe.TryGetPointer(shipEntity, out PlayerLink* link);
                int points = ship->Score * ship->Score / 10;
                f.Events.PlayerScored(link->Player, points);
                
                // Reset ship
                f.Add<Delay>(shipEntity, new Delay { TimeRemaining = spec.despawnAfterConnectDelay });
                f.Events.PlayerReconnected(shipEntity, segments.Count);
            }
        }
    }
    else
    {
        // Handle ship-to-ship collision
        // Implementation details...
    }
}
```

The reconnection mechanic:
1. Checks if a ship has collided with its own trail
2. Verifies it's the head segment connecting to a point in the trail
3. Checks alignment quality (ship must be facing in a similar direction as the trail)
4. Awards points based on trail length
5. Triggers a respawn after a delay

## Unity Visualization

The Unity-side `ShipView` class visualizes the ship and its trail:

```csharp
public unsafe class ShipView : MonoBehaviour
{
    public Transform pivot;
    public Transform socket;
    public Transform reconnectTarget;
    [SerializeField] LineRenderer ren;
    public LineRenderer trailRenderer;
    
    private void Update()
    {
        Ship* player = game.Frames.Predicted.Unsafe.GetPointer<Ship>(EntityRef);
        Quantum.Collections.QList<Photon.Deterministic.FPVector3> segs = 
            game.Frames.Predicted.ResolveList(player->Segments);

        // Update trail renderer
        ren.positionCount = segs.Count;
        for (int i = 0; i < segs.Count; i++)
        {
            Photon.Deterministic.FPVector3* seg = segs.GetPointer(i);
            ren.SetPosition(i, seg->ToUnityVector3());
        }

        // Handle trail disconnection visual
        if (trailSegs <= 1 && segs.Count > 1)
        {
            // disconnect socket from ship
            socket.SetParent(transform);
        }

        trailSegs = segs.Count;

        // Position trail socket
        if (trailSegs > 1)
        {
            Vector3 end = segs.GetPointer(0)->ToUnityVector3();
            Vector3 next = segs.GetPointer(1)->ToUnityVector3();
            socket.position = end;
            socket.rotation = Quaternion.LookRotation(next - end, -end);
        }
        
        // Apply visual effects for steering
        Quaternion rollRot = Quaternion.AngleAxis(player->SteerAmount.AsFloat * -rollAmount, Vector3.forward);
        Quaternion oversteerRot = Quaternion.Euler(0, player->SteerAmount.AsFloat * oversteerAmount, 0);
        Quaternion tgtRot = oversteerRot * rollRot;
        Quaternion srcRot = pivot.localRotation;
        pivot.localRotation = Quaternion.RotateTowards(
            srcRot, 
            tgtRot, 
            Mathf.Sqrt(Quaternion.Angle(srcRot, tgtRot)) * steerVisualRate * Time.deltaTime
        );

        // Handle boost audio
        wasBoosting = player->IsBoosting;
    }
}
```

Key aspects of the visualization:
1. **Trail Rendering**: Uses a LineRenderer to visualize the trail segments
2. **Trail Socket**: Visual connection point for the start of the trail
3. **Steering Effects**: Applies visual tilt and oversteer based on steering input
4. **Boost Effects**: Plays audio and visual effects when boosting

## Best Practices

1. **Separation of Systems**: Split functionality into focused systems (movement, collision detection, collision response)
2. **Efficient Queries**: Use physics queries for collision detection rather than manual checks
3. **Trail Management**: Keep trail segments properly spaced and oriented on the sphere
4. **Visual Feedback**: Apply smooth visual effects to make movement feel natural
5. **Resource Management**: Manage resources like boost energy and explicitly free physics queries
6. **Spherical Projection**: Consistently project positions onto the sphere surface
7. **State-Based Speed**: Vary speed based on current state (normal/boosting/braking)
8. **Configurable Parameters**: Store movement parameters in configurable assets

---

# 05-collision-system.md

# Quantum Motor Dome Collision System

This document explains the collision detection and handling system in Quantum Motor Dome, covering how ships interact with trails, other ships, and how reconnection mechanics work.

## Collision Architecture

The collision system is split into two main components to optimize performance:

1. **Query Injection System**: Creates physics queries for all trail segments
2. **Query Retrieval System**: Processes the results of those queries and handles collisions

This separation allows for efficient physics processing by minimizing the number of collision checks performed each frame.

## Ship Segments and Queries

Each ship maintains two lists for collision detection:

```qtn
component Ship
{
	// Other properties...
	list<FPVector3> Segments;
	list<PhysicsQueryRef> SegmentQueries;
}
```

- `Segments`: Stores the positions of each segment in the ship's trail
- `SegmentQueries`: Stores physics query references for collision detection between segments

## Collision Query Injection

The `ShipCollisionInjectionSystem` creates linecast queries between each pair of adjacent trail segments:

```csharp
public unsafe class ShipCollisionInjectionSystem : SystemMainThread, IGameState_Game
{
    public override bool StartEnabled => false;

    public override void Update(Frame f)
    {
        foreach (var (entity, ship) in f.Unsafe.GetComponentBlockIterator<Ship>())
        {
            if (f.Has<Delay>(entity)) continue;
            
            // Get trail segments
            Collections.QList<FPVector3> segments = f.ResolveList(ship.Segments);
            if (segments.Count < 2) continue;
            
            // Free existing queries
            Collections.QList<PhysicsQueryRef> queries = f.ResolveList(ship.SegmentQueries);
            foreach (var query in queries)
            {
                f.Physics3D.FreeQuery(query);
            }
            queries.Clear();
            
            // Create linecast queries between each pair of adjacent segments
            for (int i = 0; i < segments.Count - 1; i++)
            {
                FPVector3 start = segments[i];
                FPVector3 end = segments[i + 1];
                
                // Create linecast query
                PhysicsQueryRef query = f.Physics3D.Linecast(
                    start, 
                    end, 
                    f.Physics3D.AllLayers,
                    entity
                );
                queries.Add(query);
            }
        }
    }
}
```

Key aspects of this system:
1. **Query Management**: Frees old queries before creating new ones to prevent memory leaks
2. **Targeted Checks**: Creates linecast queries only between adjacent segments
3. **Entity Reference**: Includes the source entity in the query for proper filtering
4. **Efficiency**: Only processes entities without the `Delay` component

## Collision Query Retrieval

The `ShipCollisionRetrievalSystem` processes the results of linecast queries and handles collisions:

```csharp
public unsafe class ShipCollisionRetrievalSystem : SystemMainThread, IGameState_Game
{
    public override bool StartEnabled => false;

    public override void Update(Frame f)
    {
        ShipSpec spec = f.FindAsset<ShipSpec>(f.SimulationConfig.shipSpec.Id);
        
        foreach (var (entity, ship) in f.Unsafe.GetComponentBlockIterator<Ship>())
        {
            // Skip entities with delay or spawn protection
            if (f.Has<Delay>(entity) || f.Has<SpawnProtection>(entity)) continue;
            
            // Get query results
            Collections.QList<PhysicsQueryRef> queries = f.ResolveList(ship.SegmentQueries);
            
            for (int i = 0; i < queries.Count; i++)
            {
                PhysicsQueryRef query = queries[i];
                var results = f.Physics3D.GetLinecastHits(query);
                
                foreach (var hit in results)
                {
                    // Skip self hits and entities with spawn protection
                    if (hit.Entity == entity) continue;
                    if (f.Has<SpawnProtection>(hit.Entity)) continue;
                    
                    // Handle the collision
                    HandleCollision(f, entity, hit.Entity, i, spec);
                }
            }
        }
    }
    
    private void HandleCollision(Frame f, EntityRef entity, EntityRef hitEntity, int segmentIndex, ShipSpec spec)
    {
        // Implementation details...
    }
}
```

Key aspects of this system:
1. **Query Processing**: Retrieves the results of each query
2. **Filtering**: Skips irrelevant hits (self, entities with spawn protection)
3. **Collision Handling**: Delegates actual collision response to a separate method
4. **Segment Index**: Tracks which segment was involved in the collision for special handling (e.g., reconnection)

## Collision Types

The system handles three main types of collisions:

### 1. Self-Collision (Reconnection)

When a ship's head collides with its own trail (except the segment directly connected to the head):

```csharp
private void HandleCollision(Frame f, EntityRef entity, EntityRef hitEntity, int segmentIndex, ShipSpec spec)
{
    // Check if this is a self-collision
    if (hitEntity == entity)
    {
        // Check if this is the head segment
        if (segmentIndex == 0)
        {
            Ship* ship = f.Unsafe.GetPointer<Ship>(entity);
            Collections.QList<FPVector3> segments = f.ResolveList(ship->Segments);
            
            // Require minimum segment count for reconnection
            if (segments.Count < 10) return;
            
            // Check alignment between ship heading and trail direction
            Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(entity);
            FP dot = FPVector3.Dot(
                transform->Forward,
                (segments[1] - segments[0]).Normalized
            );
            
            // Reconnection successful if alignment is good
            if (dot > spec.connectThreshold)
            {
                // Get player link
                f.Unsafe.TryGetPointer(entity, out PlayerLink* link);
                
                // Award points based on trail length
                int points = ship->Score * ship->Score / 10;
                f.Global->playerData.Resolve(f, out var dict);
                dict.TryGetValuePointer(link->Player, out var pd);
                pd->points += (short)points;
                
                // Send event
                f.Events.PlayerReconnected(entity, segments.Count);
                
                // Add delay for respawn
                f.Add<Delay>(entity, new Delay { 
                    TimeRemaining = spec.despawnAfterConnectDelay 
                });
                f.Events.PlayerDataChanged(link->Player, f.Number);
            }
        }
    }
    else
    {
        // Handle other collision types...
    }
}
```

Key aspects of reconnection:
1. **Segment Index Check**: Only the first segment (head) can trigger reconnection
2. **Minimum Length**: Requires a minimum number of segments for valid reconnection
3. **Alignment Check**: Verifies the ship is moving in a similar direction to the trail
4. **Point Calculation**: Awards points based on the square of the trail length
5. **Respawn Delay**: Adds a delay component for respawning the ship

### 2. Ship-to-Ship Collision

When two ships collide with each other:

```csharp
private void HandleCollision(Frame f, EntityRef entity, EntityRef hitEntity, int segmentIndex, ShipSpec spec)
{
    // Self-collision handling...
    
    // Check if this is a ship-to-ship collision
    if (f.Unsafe.TryGetComponent(hitEntity, out Ship hitShip))
    {
        // Get transforms
        Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(entity);
        Transform3D* hitTransform = f.Unsafe.GetPointer<Transform3D>(hitEntity);
        
        // Calculate impact velocity
        FPVector3 relativeVelocity = transform->Forward - hitTransform->Forward;
        FP impactSpeed = relativeVelocity.Magnitude;
        
        // Only handle significant impacts
        if (impactSpeed > FP._0_50)
        {
            // Determine which ship gets destroyed based on impact angle
            FP dot = FPVector3.Dot(transform->Forward, hitTransform->Forward);
            
            // Head-on collision destroys both ships
            if (dot < FP._0_50)
            {
                DestroyShip(f, entity);
                DestroyShip(f, hitEntity);
            }
            // Side impact - destroy the ship that was hit from the side
            else if (dot > FP._0_50)
            {
                FP dot1 = FPVector3.Dot(transform->Forward, (hitTransform->Position - transform->Position).Normalized);
                FP dot2 = FPVector3.Dot(hitTransform->Forward, (transform->Position - hitTransform->Position).Normalized);
                
                if (dot1 > dot2)
                    DestroyShip(f, hitEntity);
                else
                    DestroyShip(f, entity);
            }
        }
    }
    else
    {
        // Handle ship-to-trail collision...
    }
}
```

Key aspects of ship-to-ship collisions:
1. **Impact Velocity**: Calculates the relative velocity between ships
2. **Threshold Check**: Only processes collisions above a minimum impact speed
3. **Collision Angle**: Determines the type of collision (head-on, side impact)
4. **Dual Destruction**: In head-on collisions, both ships are destroyed
5. **Side Impact Logic**: In side impacts, the ship hit from the side is destroyed

### 3. Ship-to-Trail Collision

When a ship collides with another ship's trail:

```csharp
private void HandleCollision(Frame f, EntityRef entity, EntityRef hitEntity, int segmentIndex, ShipSpec spec)
{
    // Self-collision handling...
    // Ship-to-ship collision handling...
    
    // This must be a ship-to-trail collision
    DestroyShip(f, entity);
    
    // Award points to the owner of the trail
    f.Unsafe.TryGetPointer(entity, out PlayerLink* victimLink);
    f.Unsafe.TryGetPointer(hitEntity, out PlayerLink* killerLink);
    
    if (victimLink != null && killerLink != null && victimLink->Player != killerLink->Player)
    {
        f.Global->playerData.Resolve(f, out var dict);
        dict.TryGetValuePointer(killerLink->Player, out var pd);
        pd->points += 50;
        
        f.Events.PlayerKilled(victimLink->Player, killerLink->Player);
    }
}
```

Key aspects of ship-to-trail collisions:
1. **Ship Destruction**: The colliding ship is always destroyed
2. **Point Awarding**: Points are awarded to the owner of the trail
3. **Player Verification**: Ensures both ships are owned by players and not the same player
4. **Kill Event**: Fires an event for UI feedback

## Ship Destruction

Ship destruction is handled by a common helper method:

```csharp
private void DestroyShip(Frame f, EntityRef entity)
{
    // Send explosion event
    f.Events.ShipExploded(entity);
    
    // Add delay component to prevent respawning immediately
    f.Add<Delay>(entity, new Delay { 
        TimeRemaining = FP._3
    });
    
    // Add destroyer component for cleanup
    f.Add<Destroyer>(entity);
    
    // Get position for explosion effect
    Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(entity);
    
    // Spawn explosion entity
    EntityRef explosion = f.Create(f.SimulationConfig.explosion);
    Transform3D* exTransform = f.Unsafe.GetPointer<Transform3D>(explosion);
    exTransform->Position = transform->Position;
    exTransform->Rotation = transform->Rotation;
    
    // Reset the ship's state
    Ship* ship = f.Unsafe.GetPointer<Ship>(entity);
    ship->Score = 0;
    ship->BoostAmount = 100;
    
    // Clear segments
    Collections.QList<FPVector3> segments = f.ResolveList(ship->Segments);
    segments.Clear();
    
    // Free segment queries
    Collections.QList<PhysicsQueryRef> queries = f.ResolveList(ship->SegmentQueries);
    foreach (var query in queries)
    {
        f.Physics3D.FreeQuery(query);
    }
    queries.Clear();
}
```

Key aspects of ship destruction:
1. **Event Firing**: Sends an explosion event for visual/audio effects
2. **Delay Addition**: Adds a delay to prevent immediate respawning
3. **Destroyer Component**: Adds a component to mark the entity for cleanup
4. **Explosion Creation**: Spawns an explosion entity at the ship's position
5. **State Reset**: Resets the ship's score and boost amount
6. **Segment Clearing**: Removes all trail segments
7. **Query Cleanup**: Frees all physics queries to prevent memory leaks

## Spawn Protection

To prevent unfair collisions immediately after spawning, ships are given temporary spawn protection:

```csharp
public unsafe class SpawnProtectionSystem : SystemMainThreadFilter<SpawnProtectionSystem.Filter>, IGameState_Game
{
    public struct Filter
    {
        public EntityRef Entity;
        public SpawnProtection* Protection;
    }
    
    public override void Update(Frame f, ref Filter filter)
    {
        filter.Protection->TimeRemaining -= f.DeltaTime;
        
        if (filter.Protection->TimeRemaining <= 0)
        {
            f.Remove<SpawnProtection>(filter.Entity);
            f.Events.PlayerVulnerable(filter.Entity);
        }
    }
}
```

The `SpawnProtection` component is added when a ship is spawned and automatically removed after a duration:

```qtn
component SpawnProtection
{
    FP TimeRemaining;
}
```

## Delay System

The `Delay` component is used to prevent immediate respawns after destruction:

```csharp
public unsafe class DelaySystem : SystemMainThreadFilter<DelaySystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Delay* Delay;
    }
    
    public override void Update(Frame f, ref Filter filter)
    {
        filter.Delay->TimeRemaining -= f.DeltaTime;
        
        if (filter.Delay->TimeRemaining <= 0)
        {
            f.Remove<Delay>(filter.Entity);
            
            // Respawn the ship if it was destroyed
            if (f.Has<Destroyer>(filter.Entity))
            {
                f.Remove<Destroyer>(filter.Entity);
                
                // Reposition the ship to a random spawn point
                if (f.Unsafe.TryGetPointer(filter.Entity, out Transform3D* transform))
                {
                    // Get random spawn position
                    MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);
                    ShipSpec spec = f.FindAsset<ShipSpec>(f.SimulationConfig.shipSpec.Id);
                    
                    transform->Position = new FPVector3(
                        f.RNG->NextFP(-1, 1),
                        f.RNG->NextFP(-1, 1),
                        f.RNG->NextFP(-1, 1)
                    ).Normalized * (mm.mapRadius - spec.radius) + mm.mapOrigin;
                    
                    transform->Rotation = FPQuaternion.LookRotation(
                        -transform->Position.Normalized,
                        FPVector3.Up
                    );
                }
                
                // Add spawn protection
                f.Add<SpawnProtection>(filter.Entity, new SpawnProtection { 
                    TimeRemaining = FP._3
                });
            }
        }
    }
}
```

Key aspects of the delay system:
1. **Timer Countdown**: Decrements the remaining time each frame
2. **Component Removal**: Removes the Delay component when the timer expires
3. **Ship Respawning**: Handles respawning if the entity has a Destroyer component
4. **Position Randomization**: Places the ship at a random position on the sphere
5. **Spawn Protection**: Adds a SpawnProtection component to prevent immediate collisions

## Unity Visualization

The collision events are visualized in Unity using the `ShipView` class:

```csharp
public class ShipView : MonoBehaviour
{
    public GameObject explosionPrefab;
    
    void PlayerVulnerableCallback(EventPlayerVulnerable evt)
    {
        if (evt.Entity == EntityRef)
        {
            // Update ship material to show it's vulnerable
            prop.SetFloat("_Invulnerable", 0);
            foreach (Renderer ren in renderers) ren.SetPropertyBlock(prop);
        }
    }
    
    void OnDestroy()
    {
        // Player ship explosion effect
        if (explosionPrefab != null)
        {
            Instantiate(explosionPrefab, transform.position, transform.rotation);
        }
        
        // Unsubscribe from events
        QuantumEvent.UnsubscribeListener<EventPlayerVulnerable>(this);
        // Other event unsubscriptions...
    }
}
```

## Collision Events

The collision system generates several events for Unity visualization:

```qtn
// Ship exploded
event ShipExploded { entity_ref Entity; }

// Ship reconnected its trail
event PlayerReconnected { entity_ref Entity; Int32 SegmentCount; }

// Player was killed by another player
event PlayerKilled { player_ref Victim; player_ref Killer; }

// Ship is now vulnerable after spawn protection
event PlayerVulnerable { entity_ref Entity; }
```

These events trigger visual effects, sound effects, score updates, and other feedback in the Unity view.

## Best Practices

1. **System Separation**: Split collision detection and handling into separate systems
2. **Query Management**: Always free queries when no longer needed to prevent memory leaks
3. **Spawn Protection**: Use temporary invulnerability to prevent unfair deaths
4. **Collision Types**: Handle different collision scenarios with appropriate responses
5. **Delay Mechanism**: Use delay components to control timing of respawns
6. **Event Communication**: Use events to communicate collision information to the Unity view
7. **Resource Cleanup**: Clear trail segments and queries when ships are destroyed
8. **Alignment Checks**: Use dot products to assess collision angles and alignment quality
9. **Efficient Filtering**: Skip unnecessary collision checks (self, entities with protection)

---

# 06-pickup-system.md

# Quantum Motor Dome Pickup System

This document details the pickup system in Quantum Motor Dome, covering how pickups are spawned, collected, and their effects on gameplay.

## Pickup Types

The game features two main types of pickups:

1. **Trail Pickups**: Increase the ship's trail length (score)
2. **Boost Pickups**: Replenish the ship's boost energy

Each pickup type is defined as a separate component:

```qtn
component Pickup
{
    asset_ref<PickupConfig> config;
}

component TrailPickup : Pickup
{
}

component BoostPickup : Pickup
{
}
```

## Pickup Configuration

Pickups are configured through the `PickupConfig` asset:

```csharp
public class PickupConfig : AssetObject
{
    public FP rotationSpeed;
    public FP bounceHeight;
    public FP bounceSpeed;
    
    [Header("Trail Pickup Settings")]
    public int trailSegmentsBase = 2;
    public int trailSegmentsBonus = 5;
    
    [Header("Boost Pickup Settings")]
    public FP boostEnergy = 50;
}
```

This configuration controls:
- Visual behavior (rotation speed, bounce height and speed)
- Trail pickup value (base and bonus segment counts)
- Boost pickup value (amount of boost energy restored)

## Generic Pickup System

The game uses a generic pickup system that can work with different pickup types:

```csharp
unsafe class PickupSystem<P> : SystemSignalsOnly, ISignalOnTriggerEnter3D, IGameState_Game where P : unmanaged, IComponent
{
    public override bool StartEnabled => false;

    public static int SpawnCap(Frame f) => 5 * f.ActiveUsers;

    public override void OnEnabled(Frame f)
    {
        if (f.IsVerified)
            for (int i = 0; i < SpawnCap(f); i++)
                SpawnPickup(f);
    }

    public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
    {
        if (!f.TryGet(info.Other, out P pickup)) return;
        if (!f.Unsafe.TryGetPointer(info.Entity, out Ship* ship)) return;
        if (!f.TryGet(info.Entity, out PlayerLink link)) return;

        // Apply pickup effect based on type
        if (pickup is TrailPickup)
        {
            int oldScore = ship->Score;
            ship->Score += ship->Score > 0 ? 5 : 2;
            f.Events.PlayerScoreChanged(link.Player, oldScore, ship->Score);
        }
        else if (pickup is BoostPickup)
        {
            // Add boost energy and clamp to maximum
            ship->BoostAmount += f.RuntimeConfig.boostPickupValue;
            if (ship->BoostAmount > 100) ship->BoostAmount = 100;
        }

        // Send event and destroy pickup
        f.Events.PickupCollected(info.Entity, ComponentTypeId<P>.Id);
        f.Destroy(info.Other);

        // Spawn a new pickup if below cap
        if (f.ComponentCount<P>() < SpawnCap(f))
        {
            SpawnPickup(f);
        }
    }
    
    public static EntityRef SpawnPickup(Frame f)
    {
        MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);

        EntityRef entity = default;
        if (typeof(P) == typeof(TrailPickup))
            entity = f.Create(f.SimulationConfig.trailPickup);
        else if (typeof(P) == typeof(BoostPickup))
            entity = f.Create(f.SimulationConfig.boostPickup);

        if (f.Unsafe.TryGetPointer(entity, out Pickup* p) &&
            f.Unsafe.TryGetPointer(entity, out Transform3D* tf))
        {
            // Position pickup randomly on the sphere surface
            tf->Position = new FPVector3(
                f.RNG->NextInclusive((FP)(-1), (FP)(1)),
                f.RNG->NextInclusive((FP)(-1), (FP)(1)),
                f.RNG->NextInclusive((FP)(-1), (FP)(1))
                ).Normalized * mm.mapRadius
                + mm.mapOrigin;
                
            // Orient pickup to face outward from sphere
            tf->Rotation = FPQuaternion.LookRotation(-tf->Position);
        }

        return entity;
    }
    
    public static EntityRef SpawnPickup(Frame f, FPVector3 position)
    {
        MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);

        EntityRef entity = default;
        if (typeof(P) == typeof(TrailPickup))
            entity = f.Create(f.SimulationConfig.trailPickup);
        else if (typeof(P) == typeof(BoostPickup))
            entity = f.Create(f.SimulationConfig.boostPickup);

        if (f.Unsafe.TryGetPointer(entity, out Pickup* p) &&
            f.Unsafe.TryGetPointer(entity, out Transform3D* tf))
        {
            // Position pickup at specified position, projected onto sphere
            tf->Position = ((position - mm.mapOrigin).Normalized * mm.mapRadius) + mm.mapOrigin;
            tf->Rotation = FPQuaternion.LookRotation(-tf->Position);
        }

        return entity;
    }
}
```

Key aspects of this system:
1. **Generic Implementation**: Uses a type parameter to work with different pickup types
2. **Event Handling**: Subscribes to the `OnTriggerEnter3D` event to detect collisions
3. **Spawn Cap**: Maintains a maximum number of pickups based on active players
4. **Initial Population**: Spawns pickups when the system is enabled
5. **Pickup Effects**: Applies different effects based on pickup type
6. **Spawn Methods**: Provides methods for random spawning and position-specific spawning

## Spawn Cap Calculation

The number of pickups allowed in the game scales with the number of active players:

```csharp
public static int SpawnCap(Frame f) => 5 * f.ActiveUsers;
```

This ensures that:
1. Solo players have enough pickups to find
2. Multiplayer games have more pickups to support more players
3. The density of pickups remains consistent regardless of player count

## Pickup Distribution

Pickups are distributed randomly across the sphere:

```csharp
// Position pickup randomly on the sphere surface
tf->Position = new FPVector3(
    f.RNG->NextInclusive((FP)(-1), (FP)(1)),
    f.RNG->NextInclusive((FP)(-1), (FP)(1)),
    f.RNG->NextInclusive((FP)(-1), (FP)(1))
    ).Normalized * mm.mapRadius
    + mm.mapOrigin;
```

Key aspects of distribution:
1. **Random Direction**: Generates a random unit vector by normalizing a random 3D vector
2. **Sphere Projection**: Projects the position onto the sphere surface at the map radius
3. **Deterministic RNG**: Uses Quantum's deterministic random number generator

## Trail Pickup Effects

When a ship collects a trail pickup:

```csharp
if (pickup is TrailPickup)
{
    int oldScore = ship->Score;
    ship->Score += ship->Score > 0 ? 5 : 2;
    f.Events.PlayerScoreChanged(link.Player, oldScore, ship->Score);
}
```

Key aspects of trail pickups:
1. **Progressive Value**: Worth more (5 segments) for ships that already have a trail
2. **Starter Value**: Worth less (2 segments) for ships with no trail
3. **Score Event**: Fires an event to update UI elements with the new score

## Boost Pickup Effects

When a ship collects a boost pickup:

```csharp
else if (pickup is BoostPickup)
{
    // Add boost energy and clamp to maximum
    ship->BoostAmount += f.RuntimeConfig.boostPickupValue;
    if (ship->BoostAmount > 100) ship->BoostAmount = 100;
}
```

Key aspects of boost pickups:
1. **Energy Restoration**: Adds a configurable amount of boost energy
2. **Maximum Cap**: Prevents boost energy from exceeding 100
3. **Configuration**: Uses a value from the runtime configuration for flexibility

## Pickup Collection

The pickup collection process happens in the `OnTriggerEnter3D` method:

```csharp
public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
{
    if (!f.TryGet(info.Other, out P pickup)) return;
    if (!f.Unsafe.TryGetPointer(info.Entity, out Ship* ship)) return;
    if (!f.TryGet(info.Entity, out PlayerLink link)) return;

    // Apply pickup effect based on type
    // ...
    
    // Send event and destroy pickup
    f.Events.PickupCollected(info.Entity, ComponentTypeId<P>.Id);
    f.Destroy(info.Other);

    // Spawn a new pickup if below cap
    if (f.ComponentCount<P>() < SpawnCap(f))
    {
        SpawnPickup(f);
    }
}
```

Key aspects of collection:
1. **Type Verification**: Ensures the colliding entity is a valid pickup of the correct type
2. **Ship Verification**: Ensures the collecting entity is a ship with a player link
3. **Effect Application**: Applies the appropriate effect based on pickup type
4. **Event Notification**: Fires an event to trigger visual/audio feedback
5. **Pickup Destruction**: Removes the pickup from the game
6. **Respawn Logic**: Spawns a new pickup to maintain the desired pickup density

## Pickup Events

The pickup system generates events for Unity visualization:

```qtn
event PickupCollected { entity_ref Entity; Byte TypeId; }
event PlayerScoreChanged { player_ref Player; Int32 OldScore; Int32 NewScore; }
```

These events are subscribed to in Unity to provide visual and audio feedback:

```csharp
public class PickupEffects : MonoBehaviour
{
    [SerializeField] AudioClip trailPickupSound;
    [SerializeField] AudioClip boostPickupSound;
    [SerializeField] GameObject trailPickupVFX;
    [SerializeField] GameObject boostPickupVFX;
    
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventPickupCollected>(this, OnPickupCollected);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventPickupCollected>(this);
    }
    
    private void OnPickupCollected(EventPickupCollected evt)
    {
        // Get the ship view
        QuantumEntityView view = QuantumEntityView.FindEntityView(evt.Entity);
        if (view == null) return;
        
        // Determine pickup type and play appropriate effects
        if (evt.TypeId == ComponentTypeId<TrailPickup>.Id)
        {
            // Play trail pickup effects
            AudioSource.PlayClipAtPoint(trailPickupSound, view.transform.position);
            Instantiate(trailPickupVFX, view.transform.position, Quaternion.identity);
        }
        else if (evt.TypeId == ComponentTypeId<BoostPickup>.Id)
        {
            // Play boost pickup effects
            AudioSource.PlayClipAtPoint(boostPickupSound, view.transform.position);
            Instantiate(boostPickupVFX, view.transform.position, Quaternion.identity);
        }
    }
}
```

## Pickup Visualization

Pickups have visual representations in Unity that are driven by the `PickupView` component:

```csharp
public class PickupView : MonoBehaviour
{
    public float rotationSpeed = 50f;
    public float bounceHeight = 0.3f;
    public float bounceSpeed = 2f;
    
    private Vector3 startPosition;
    
    private void Start()
    {
        startPosition = transform.localPosition;
    }
    
    private void Update()
    {
        // Rotate pickup
        transform.Rotate(Vector3.up, rotationSpeed * Time.deltaTime);
        
        // Bounce pickup
        float bounce = Mathf.Sin(Time.time * bounceSpeed) * bounceHeight;
        transform.localPosition = startPosition + Vector3.up * bounce;
    }
}
```

This adds visual interest through:
1. **Rotation**: Continuous rotation to attract attention
2. **Bouncing**: Vertical oscillation to create a floating effect
3. **Parameterization**: Configurable values for designers to adjust

## Pickup Prototypes

Pickups are defined as entity prototypes in the Quantum asset database:

```csharp
// In SimulationConfig.User.cs
public AssetRef<EntityPrototype> trailPickup;
public AssetRef<EntityPrototype> boostPickup;

// In the Unity editor
[Serializable]
public class PickupPrototype
{
    public GameObject visualPrefab;
    public Collider triggerCollider;
    public PickupConfig config;
}
```

A typical pickup prototype includes:
1. **Pickup Component**: TrailPickup or BoostPickup component
2. **Transform3D**: For position and rotation
3. **PhysicsCollider3D**: For collision detection (as a trigger)
4. **Configuration**: Reference to a PickupConfig asset

## Game State Integration

The pickup system is only active during specific game states:

```csharp
unsafe class PickupSystem<P> : SystemSignalsOnly, ISignalOnTriggerEnter3D, IGameState_Game
{
    public override bool StartEnabled => false;
    
    // Implementation...
}
```

By implementing `IGameState_Game`, the system is automatically:
1. Disabled during lobby, countdown, and other non-gameplay states
2. Enabled when the game state changes to the main gameplay state
3. Disabled again when the game ends

## Specialized Pickup Spawning

In addition to random spawning, the system supports spawning pickups at specific positions:

```csharp
public static EntityRef SpawnPickup(Frame f, FPVector3 position)
{
    // Implementation...
}
```

This is used for:
1. **Respawn Bonuses**: Spawning pickups when a player respawns
2. **Death Drops**: Spawning pickups at the location where a ship was destroyed
3. **Reconnection Rewards**: Spawning pickups when a ship successfully reconnects its trail

## Best Practices

1. **Generic Implementation**: Use type parameters for shared functionality across pickup types
2. **Scalable Distribution**: Scale pickup count based on active players
3. **Spherical Placement**: Properly project pickups onto the sphere surface
4. **Progressive Value**: Make pickups more valuable for players already performing well
5. **Visual Feedback**: Use events to trigger appropriate visual and audio effects
6. **Game State Integration**: Only activate pickups during appropriate game states
7. **Cap Enforcement**: Maintain a maximum number of pickups to ensure balanced gameplay
8. **Configuration Assets**: Store pickup parameters in configurable assets
9. **Type Identification**: Use component type IDs for efficient type checking in events

---

# 07-scoring-and-reconnection.md

# Quantum Motor Dome Scoring and Reconnection

This document explains the scoring system and reconnection mechanics in Quantum Motor Dome, covering how players earn points and the mechanics of trail reconnection.

## Scoring System Overview

The game features multiple ways for players to earn points:

1. **Trail Reconnection**: Connecting your ship's head to its own trail
2. **Player Elimination**: Eliminating other players by causing them to collide with your trail
3. **Pickup Collection**: Collecting trail pickups increases trail length (score)

Points are stored in the global player data dictionary:

```qtn
struct PlayerData
{
	bool ready;
	Int16 points;
}

global
{
	dictionary<Int32, PlayerData> playerData;
	// Other global properties...
}
```

## Trail Growth and Score

The Ship component tracks each player's score, which directly correlates to trail length:

```qtn
component Ship
{
	[Header("Runtime Properties")]
	FP BoostAmount;
	int Score;
	list<FPVector3> Segments;
	list<PhysicsQueryRef> SegmentQueries;
	
	// Other properties...
}
```

The Score property serves two purposes:
1. It represents the number of trail segments the ship should have
2. It's used for calculating points in reconnection and other scoring opportunities

## Trail Pickup Collection

Collecting trail pickups increases the ship's score (trail length):

```csharp
public void OnTriggerEnter3D(Frame f, TriggerInfo3D info)
{
    if (!f.TryGet(info.Other, out TrailPickup pickup)) return;
    if (!f.Unsafe.TryGetPointer(info.Entity, out Ship* ship)) return;
    if (!f.TryGet(info.Entity, out PlayerLink link)) return;

    // Increase score (trail length)
    int oldScore = ship->Score;
    ship->Score += ship->Score > 0 ? 5 : 2;
    f.Events.PlayerScoreChanged(link.Player, oldScore, ship->Score);
    
    // Rest of implementation...
}
```

Key aspects of trail pickup scoring:
1. **Progressive Value**: Pickups are worth more (5 segments) for ships that already have a trail
2. **Starter Value**: Pickups are worth less (2 segments) for ships with no trail
3. **Event Notification**: Fires an event to update UI elements with the new score

## Reconnection Mechanics

The reconnection mechanic is a core gameplay element where players connect their ship back to their own trail to score points.

### Detection

Reconnection is detected in the collision system:

```csharp
private void HandleCollision(Frame f, EntityRef entity, EntityRef hitEntity, int segmentIndex, ShipSpec spec)
{
    // Check if this is a self-collision
    if (hitEntity == entity)
    {
        // Only the head segment can reconnect
        if (segmentIndex == 0)
        {
            Ship* ship = f.Unsafe.GetPointer<Ship>(entity);
            Collections.QList<FPVector3> segments = f.ResolveList(ship->Segments);
            
            // Require minimum segment count for reconnection
            if (segments.Count < 10) return;
            
            // Check alignment between ship heading and trail direction
            Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(entity);
            FP dot = FPVector3.Dot(
                transform->Forward,
                (segments[1] - segments[0]).Normalized
            );
            
            // Reconnection successful if alignment is good
            if (dot > spec.connectThreshold)
            {
                // Reconnection successful!
                HandleReconnection(f, entity, ship, segments);
            }
        }
    }
    
    // Rest of collision handling...
}
```

Key aspects of reconnection detection:
1. **Segment Index Check**: Only the head segment (segmentIndex == 0) can reconnect
2. **Minimum Length**: Requires a minimum number of segments (typically 10)
3. **Alignment Check**: Checks that the ship is facing in roughly the same direction as the trail
4. **Threshold Comparison**: Uses a configurable threshold for the alignment dot product

### Alignment Requirement

The alignment check ensures that reconnection requires skill and intentionality:

```csharp
// Check alignment between ship heading and trail direction
Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(entity);
FP dot = FPVector3.Dot(
    transform->Forward,
    (segments[1] - segments[0]).Normalized
);

// Reconnection successful if alignment is good
if (dot > spec.connectThreshold)
{
    // Reconnection successful!
    // Implementation...
}
```

This calculation:
1. Gets the ship's forward direction
2. Gets the direction of the first trail segment
3. Calculates the dot product (cosine of the angle between them)
4. Compares against the connectThreshold (typically 0.7-0.9)

The configuration is stored in the `ShipSpec` asset:

```csharp
public partial class ShipSpec : AssetObject
{
    // Other properties...
    [Range(0, 1)] public FP connectThreshold;
    public FP despawnAfterConnectDelay;
}
```

### Point Calculation

When reconnection is successful, points are awarded based on trail length:

```csharp
private void HandleReconnection(Frame f, EntityRef entity, Ship* ship, Collections.QList<FPVector3> segments)
{
    // Get player link
    f.Unsafe.TryGetPointer(entity, out PlayerLink* link);
    
    // Award points based on trail length (squared for exponential reward)
    int points = ship->Score * ship->Score / 10;
    f.Global->playerData.Resolve(f, out var dict);
    dict.TryGetValuePointer(link->Player, out var pd);
    pd->points += (short)points;
    
    // Send event
    f.Events.PlayerReconnected(entity, segments.Count);
    
    // Add delay for respawn
    f.Add<Delay>(entity, new Delay { 
        TimeRemaining = spec.despawnAfterConnectDelay 
    });
    f.Events.PlayerDataChanged(link->Player, f.Number);
}
```

Key aspects of reconnection scoring:
1. **Quadratic Scaling**: Points awarded are proportional to the square of the trail length
2. **Division Factor**: The division by 10 balances the scoring to reasonable values
3. **Event Notification**: Fires events for UI feedback and visual effects
4. **Delayed Respawn**: Adds a delay before respawning to show the reconnection effect

### Visual Feedback

When reconnection occurs, the Unity side provides visual feedback:

```csharp
public class ReconnectionEffect : MonoBehaviour
{
    [SerializeField] private ParticleSystem reconnectionVFX;
    [SerializeField] private AudioClip reconnectionSound;
    
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventPlayerReconnected>(this, OnPlayerReconnected);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventPlayerReconnected>(this);
    }
    
    private void OnPlayerReconnected(EventPlayerReconnected evt)
    {
        // Find entity view
        var entityView = QuantumEntityView.FindEntityView(evt.Entity);
        if (entityView == null) return;
        
        // Play visual effect
        Instantiate(reconnectionVFX, entityView.transform.position, Quaternion.identity);
        
        // Play sound effect (volume based on segment count)
        float volume = Mathf.Clamp01(evt.SegmentCount / 50f);
        AudioSource.PlayClipAtPoint(reconnectionSound, entityView.transform.position, volume);
    }
}
```

### Reconnection Animation

The `ShipView` class handles the visual representation of reconnection:

```csharp
public unsafe class ShipView : MonoBehaviour
{
    public Transform pivot;
    public Transform socket;
    public Transform reconnectTarget;
    
    int? reconnectTick = null;
    
    private void Update()
    {
        if (reconnectTick.HasValue)
        {
            // Animate reconnection
            socket.rotation = Quaternion.RotateTowards(socket.rotation, pivot.rotation, 360 * Time.deltaTime);

            pivot.position = Vector3.MoveTowards(pivot.position, reconnectTarget.position, connectionSmoothSpeed * Time.deltaTime);
            pivot.rotation = Quaternion.RotateTowards(pivot.rotation, reconnectTarget.rotation, 360 * Time.deltaTime);

            return;
        }
        
        // Normal update...
    }
    
    void PlayerDataChangedCallback(EventPlayerDataChanged evt)
    {
        if (evt.Player == PlayerRef)
        {
            reconnectTick = evt.Tick;
            QuantumEvent.UnsubscribeListener<EventPlayerDataChanged>(this);
        }
    }
}
```

This animation:
1. Rotates the socket (start of the trail) to align with the ship's rotation
2. Moves the ship toward the reconnection target position
3. Rotates the ship to align with the reconnection target rotation

## Player Elimination Scoring

Players can earn points by eliminating other players:

```csharp
private void HandleCollision(Frame f, EntityRef entity, EntityRef hitEntity, int segmentIndex, ShipSpec spec)
{
    // Self-collision handling...
    // Ship-to-ship collision handling...
    
    // This must be a ship-to-trail collision
    DestroyShip(f, entity);
    
    // Award points to the owner of the trail
    f.Unsafe.TryGetPointer(entity, out PlayerLink* victimLink);
    f.Unsafe.TryGetPointer(hitEntity, out PlayerLink* killerLink);
    
    if (victimLink != null && killerLink != null && victimLink->Player != killerLink->Player)
    {
        f.Global->playerData.Resolve(f, out var dict);
        dict.TryGetValuePointer(killerLink->Player, out var pd);
        pd->points += 50;
        
        f.Events.PlayerKilled(victimLink->Player, killerLink->Player);
    }
}
```

Key aspects of elimination scoring:
1. **Fixed Value**: Eliminations are worth a fixed number of points (typically 50)
2. **Owner Verification**: Ensures the eliminating player isn't the same as the eliminated player
3. **Event Notification**: Fires an event for UI feedback

## Score Tracking and Display

Scores are displayed in the UI through events:

```csharp
public class ScoreboardUI : MonoBehaviour
{
    [SerializeField] private GameObject scoreEntryPrefab;
    [SerializeField] private Transform scoreboardContainer;
    
    private Dictionary<PlayerRef, ScoreEntry> scoreEntries = new Dictionary<PlayerRef, ScoreEntry>();
    
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventPlayerScoreChanged>(this, OnPlayerScoreChanged);
        QuantumEvent.Subscribe<EventPlayerKilled>(this, OnPlayerKilled);
        QuantumEvent.Subscribe<EventPlayerReconnected>(this, OnPlayerReconnected);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventPlayerScoreChanged>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerKilled>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerReconnected>(this);
    }
    
    private void OnPlayerScoreChanged(EventPlayerScoreChanged evt)
    {
        UpdateScore(evt.Player);
    }
    
    private void OnPlayerKilled(EventPlayerKilled evt)
    {
        UpdateScore(evt.Killer);
    }
    
    private void OnPlayerReconnected(EventPlayerReconnected evt)
    {
        // Find player ref from entity
        QuantumRunner.Default.Game.Frames.Verified.TryGetComponent<PlayerLink>(
            evt.Entity, out var playerLink);
        
        if (playerLink != null)
        {
            UpdateScore(playerLink.Player);
        }
    }
    
    private void UpdateScore(PlayerRef player)
    {
        // Get player score from global dictionary
        var game = QuantumRunner.Default.Game;
        game.Frames.Verified.Global.playerData.TryGetValue(
            player, out var playerData);
        
        // Update UI
        if (scoreEntries.TryGetValue(player, out var entry))
        {
            entry.UpdateScore(playerData.points);
        }
        else
        {
            // Create new score entry
            var newEntry = Instantiate(scoreEntryPrefab, scoreboardContainer).GetComponent<ScoreEntry>();
            newEntry.Initialize(player, playerData.points);
            scoreEntries[player] = newEntry;
        }
        
        // Sort scoreboard by score
        SortScoreboard();
    }
    
    private void SortScoreboard()
    {
        // Sort children by score
        var entries = scoreboardContainer.GetComponentsInChildren<ScoreEntry>()
            .OrderByDescending(e => e.Score)
            .ToList();
            
        // Update sibling indices to reorder
        for (int i = 0; i < entries.Count; i++)
        {
            entries[i].transform.SetSiblingIndex(i);
        }
    }
}
```

## Score Events

The scoring system generates several events for Unity visualization:

```qtn
event PlayerScoreChanged { player_ref Player; Int32 OldScore; Int32 NewScore; }
event PlayerKilled { player_ref Victim; player_ref Killer; }
event PlayerReconnected { entity_ref Entity; Int32 SegmentCount; }
event PlayerDataChanged { player_ref Player; Int32 Tick; }
```

These events enable:
1. **Score Updates**: Updating UI elements with new scores
2. **Kill Feed**: Showing kill notifications in the UI
3. **Reconnection Effects**: Playing visual and audio effects for reconnection
4. **Respawn Animation**: Triggering ship respawn animation

## Postgame Score Summary

When the game ends, scores are summarized in the postgame screen:

```csharp
public unsafe class PostgameSystem : SystemMainThread, IGameState_Postgame
{
    public override bool StartEnabled => false;
    
    public override void OnEnabled(Frame f)
    {
        // Calculate final scores and rankings
        var playerDataDict = f.Global->playerData.Resolve(f, out var dict);
        
        // Sort players by score
        var sortedPlayers = playerDataDict.OrderByDescending(kvp => kvp.Value.points).ToList();
        
        // Send final scores event
        f.Events.GameResults(
            sortedPlayers.Select(kvp => kvp.Key).ToArray(),
            sortedPlayers.Select(kvp => kvp.Value.points).ToArray()
        );
        
        // Start postgame timer
        f.Global->clock = FrameTimer.FromSeconds(f, 10);
    }
    
    public override void Update(Frame f)
    {
        // Check if postgame timer has expired
        if (!f.Global->clock.IsRunning(f))
        {
            // Return to lobby
            GameStateSystem.SetState(f, GameState.Lobby);
        }
    }
}
```

## Best Practices

1. **Square Scaling**: Scale reconnection points quadratically with trail length to reward skilled play
2. **Visual Feedback**: Provide clear visual and audio feedback for scoring events
3. **Skill Requirement**: Use alignment checks to ensure reconnection requires skill
4. **Minimum Thresholds**: Require a minimum trail length for reconnection to prevent abuse
5. **Balanced Values**: Balance point values between different scoring methods
6. **Event Communication**: Use events to communicate score changes to the Unity view
7. **State Tracking**: Store scores in the global state for persistence
8. **Verification**: Verify player ownership before awarding points
9. **Animation Timing**: Use delays to ensure scoring animations can complete

---

# 08-spawning-system.md

# Quantum Motor Dome Spawning System

This document explains the spawning system in Quantum Motor Dome, covering how ships, pickups, and other entities are spawned, respawned, and positioned in the game world.

## Ship Spawning Overview

The spawning system handles several key aspects of entity creation:

1. **Initial Ship Spawning**: Creating ships when players join the game
2. **Ship Respawning**: Repositioning ships after destruction or reconnection
3. **Spawn Protection**: Providing temporary invulnerability after spawning
4. **Random Positioning**: Placing ships at random positions on the sphere
5. **Orientation**: Ensuring ships are properly oriented on the sphere surface

## Ship Spawner System

The `ShipSpawnerSystem` handles ship creation when players join the game:

```csharp
public unsafe class ShipSpawnerSystem : SystemSignalsOnly, ISignalOnPlayerAdded
{
    public void OnPlayerAdded(Frame f, PlayerRef player, bool isRejoining)
    {
        // Don't spawn ships during certain game states
        if (f.Global->CurrentState == GameState.Postgame || 
            f.Global->CurrentState == GameState.Outro)
            return;
        
        // Create ship entity from prototype
        EntityRef shipEntity = f.Create(f.SimulationConfig.shipPrototype);
        
        // Link ship to player
        f.Add<PlayerLink>(shipEntity, new PlayerLink { Player = player });
        
        // Position ship randomly on sphere
        if (f.Unsafe.TryGetPointer<Transform3D>(shipEntity, out var transform))
        {
            PositionRandomlyOnSphere(f, transform);
            
            // Orient ship to face outward from sphere
            MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);
            transform->Rotation = FPQuaternion.LookRotation(
                -transform->Position.Normalized,
                FPVector3.Up
            );
        }
        
        // Add spawn protection
        f.Add<SpawnProtection>(shipEntity, new SpawnProtection { 
            TimeRemaining = FP._3
        });
        
        // Initialize ship components
        if (f.Unsafe.TryGetPointer<Ship>(shipEntity, out var ship))
        {
            ship->Score = 0;
            ship->BoostAmount = 100;
            
            // Allocate lists for segments and queries
            ship->Segments = f.AllocateList<FPVector3>();
            ship->SegmentQueries = f.AllocateList<PhysicsQueryRef>();
        }
        
        // Send event
        f.Events.ShipSpawned(shipEntity, player);
    }
    
    private void PositionRandomlyOnSphere(Frame f, Transform3D* transform)
    {
        MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);
        ShipSpec spec = f.FindAsset<ShipSpec>(f.SimulationConfig.shipSpec.Id);
        
        transform->Position = new FPVector3(
            f.RNG->NextFP(-1, 1),
            f.RNG->NextFP(-1, 1),
            f.RNG->NextFP(-1, 1)
        ).Normalized * (mm.mapRadius - spec.radius) + mm.mapOrigin;
    }
}
```

Key aspects of ship spawning:
1. **Entity Creation**: Creates a ship entity from a prototype
2. **Player Linking**: Links the ship to the player who will control it
3. **Random Positioning**: Places the ship at a random position on the sphere
4. **Orientation**: Orients the ship to face outward from the sphere
5. **Spawn Protection**: Adds temporary invulnerability
6. **Initialization**: Sets initial values for ship components
7. **List Allocation**: Allocates dynamic lists for segments and queries
8. **Event Notification**: Fires an event for Unity visualization

## Ship Respawning

Ships are respawned after destruction or reconnection using the `Delay` component:

```csharp
public unsafe class DelaySystem : SystemMainThreadFilter<DelaySystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Delay* Delay;
    }
    
    public override void Update(Frame f, ref Filter filter)
    {
        filter.Delay->TimeRemaining -= f.DeltaTime;
        
        if (filter.Delay->TimeRemaining <= 0)
        {
            f.Remove<Delay>(filter.Entity);
            
            // Respawn the ship if it was destroyed
            if (f.Has<Destroyer>(filter.Entity))
            {
                f.Remove<Destroyer>(filter.Entity);
                
                // Reposition the ship
                if (f.Unsafe.TryGetPointer(filter.Entity, out Transform3D* transform))
                {
                    PositionRandomlyOnSphere(f, transform);
                }
                
                // Add spawn protection
                f.Add<SpawnProtection>(filter.Entity, new SpawnProtection { 
                    TimeRemaining = FP._3
                });
                
                // Reset the ship's state
                if (f.Unsafe.TryGetPointer(filter.Entity, out Ship* ship))
                {
                    ship->Score = 0;
                    ship->BoostAmount = 100;
                }
                
                // Get player information for event
                if (f.Unsafe.TryGetPointer(filter.Entity, out PlayerLink* link))
                {
                    f.Events.ShipRespawned(filter.Entity, link->Player);
                }
            }
        }
    }
    
    private void PositionRandomlyOnSphere(Frame f, Transform3D* transform)
    {
        // Same implementation as in ShipSpawnerSystem
    }
}
```

Key aspects of ship respawning:
1. **Delay Timing**: Uses a timer to create a delay before respawning
2. **Component Removal**: Removes the Destroyer component when respawning
3. **Repositioning**: Places the ship at a new random position
4. **Spawn Protection**: Adds temporary invulnerability
5. **State Reset**: Resets the ship's score and boost amount
6. **Event Notification**: Fires an event for Unity visualization

## Spawn Protection System

The `SpawnProtection` component provides temporary invulnerability after spawning:

```csharp
public unsafe class SpawnProtectionSystem : SystemMainThreadFilter<SpawnProtectionSystem.Filter>, IGameState_Game
{
    public struct Filter
    {
        public EntityRef Entity;
        public SpawnProtection* Protection;
    }
    
    public override bool StartEnabled => false;
    
    public override void Update(Frame f, ref Filter filter)
    {
        filter.Protection->TimeRemaining -= f.DeltaTime;
        
        if (filter.Protection->TimeRemaining <= 0)
        {
            f.Remove<SpawnProtection>(filter.Entity);
            f.Events.PlayerVulnerable(filter.Entity);
        }
    }
}
```

The `SpawnProtection` component is defined as:

```qtn
component SpawnProtection
{
    FP TimeRemaining;
}
```

Key aspects of spawn protection:
1. **Duration Timer**: Counts down the remaining protection time
2. **Automatic Removal**: Removes the component when the timer expires
3. **Event Notification**: Fires an event when protection ends
4. **Collision Filtering**: Other systems skip collisions with entities that have spawn protection

## Spherical Positioning

A key aspect of the spawning system is positioning entities on a sphere:

```csharp
private void PositionRandomlyOnSphere(Frame f, Transform3D* transform)
{
    MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);
    ShipSpec spec = f.FindAsset<ShipSpec>(f.SimulationConfig.shipSpec.Id);
    
    transform->Position = new FPVector3(
        f.RNG->NextFP(-1, 1),
        f.RNG->NextFP(-1, 1),
        f.RNG->NextFP(-1, 1)
    ).Normalized * (mm.mapRadius - spec.radius) + mm.mapOrigin;
}
```

This method:
1. Gets the map metadata (sphere center and radius)
2. Gets the ship spec (for ship radius)
3. Generates a random direction by normalizing a random 3D vector
4. Scales the direction by the sphere radius minus the ship radius
5. Offsets by the sphere center

## Ship Orientation

After positioning, ships must be oriented correctly on the sphere:

```csharp
// Orient ship to face outward from sphere
MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);
transform->Rotation = FPQuaternion.LookRotation(
    -transform->Position.Normalized,
    FPVector3.Up
);
```

This ensures that:
1. The ship's forward direction is tangent to the sphere
2. The ship's up direction is aligned with the sphere's normal at that point

## Ship Destruction and Cleanup

The `Destroyer` component marks ships for cleanup and respawning:

```qtn
component Destroyer {}
```

This is a marker component with no data. It's added when a ship is destroyed:

```csharp
private void DestroyShip(Frame f, EntityRef entity)
{
    // Send explosion event
    f.Events.ShipExploded(entity);
    
    // Add delay component to prevent respawning immediately
    f.Add<Delay>(entity, new Delay { 
        TimeRemaining = FP._3
    });
    
    // Add destroyer component for cleanup
    f.Add<Destroyer>(entity);
    
    // Reset the ship's state
    Ship* ship = f.Unsafe.GetPointer<Ship>(entity);
    ship->Score = 0;
    ship->BoostAmount = 100;
    
    // Clear segments
    Collections.QList<FPVector3> segments = f.ResolveList(ship->Segments);
    segments.Clear();
    
    // Free segment queries
    Collections.QList<PhysicsQueryRef> queries = f.ResolveList(ship->SegmentQueries);
    foreach (var query in queries)
    {
        f.Physics3D.FreeQuery(query);
    }
    queries.Clear();
}
```

## Pickup Spawning

Pickups are spawned using the generic `PickupSystem`:

```csharp
public static EntityRef SpawnPickup(Frame f)
{
    MapMeta mm = f.FindAsset<MapMeta>(f.Map.UserAsset.Id);

    EntityRef entity = default;
    if (typeof(P) == typeof(TrailPickup))
        entity = f.Create(f.SimulationConfig.trailPickup);
    else if (typeof(P) == typeof(BoostPickup))
        entity = f.Create(f.SimulationConfig.boostPickup);

    if (f.Unsafe.TryGetPointer(entity, out Pickup* p) &&
        f.Unsafe.TryGetPointer(entity, out Transform3D* tf))
    {
        // Position pickup randomly on the sphere surface
        tf->Position = new FPVector3(
            f.RNG->NextInclusive((FP)(-1), (FP)(1)),
            f.RNG->NextInclusive((FP)(-1), (FP)(1)),
            f.RNG->NextInclusive((FP)(-1), (FP)(1))
            ).Normalized * mm.mapRadius
            + mm.mapOrigin;
            
        // Orient pickup to face outward from sphere
        tf->Rotation = FPQuaternion.LookRotation(-tf->Position);
    }

    return entity;
}
```

Key aspects of pickup spawning:
1. **Entity Creation**: Creates a pickup entity from a prototype
2. **Random Positioning**: Places the pickup at a random position on the sphere
3. **Orientation**: Orients the pickup to face outward from the sphere
4. **Type Selection**: Creates different pickup types based on the generic parameter

## Explosion Spawning

When ships are destroyed, explosion entities are spawned:

```csharp
private void DestroyShip(Frame f, EntityRef entity)
{
    // Rest of implementation...
    
    // Get position for explosion effect
    Transform3D* transform = f.Unsafe.GetPointer<Transform3D>(entity);
    
    // Spawn explosion entity
    EntityRef explosion = f.Create(f.SimulationConfig.explosion);
    Transform3D* exTransform = f.Unsafe.GetPointer<Transform3D>(explosion);
    exTransform->Position = transform->Position;
    exTransform->Rotation = transform->Rotation;
    
    // Rest of implementation...
}
```

Explosions typically have a limited lifetime managed by a timer:

```csharp
public unsafe class ExplosionSystem : SystemMainThreadFilter<ExplosionSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Explosion* Explosion;
    }
    
    public override void Update(Frame f, ref Filter filter)
    {
        filter.Explosion->TimeRemaining -= f.DeltaTime;
        
        if (filter.Explosion->TimeRemaining <= 0)
        {
            f.Destroy(filter.Entity);
        }
    }
}
```

## Spawn Events

The spawning system generates several events for Unity visualization:

```qtn
event ShipSpawned { entity_ref Entity; player_ref Player; }
event ShipRespawned { entity_ref Entity; player_ref Player; }
event ShipExploded { entity_ref Entity; }
event PlayerVulnerable { entity_ref Entity; }
```

These events are subscribed to in Unity to provide visual and audio feedback:

```csharp
public class SpawnEffect : MonoBehaviour
{
    [SerializeField] private GameObject spawnVFX;
    [SerializeField] private AudioClip spawnSound;
    
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventShipSpawned>(this, OnShipSpawned);
        QuantumEvent.Subscribe<EventShipRespawned>(this, OnShipRespawned);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventShipSpawned>(this);
        QuantumEvent.UnsubscribeListener<EventShipRespawned>(this);
    }
    
    private void OnShipSpawned(EventShipSpawned evt)
    {
        // Find entity view
        var entityView = QuantumEntityView.FindEntityView(evt.Entity);
        if (entityView == null) return;
        
        // Play spawn effect
        Instantiate(spawnVFX, entityView.transform.position, Quaternion.identity);
        AudioSource.PlayClipAtPoint(spawnSound, entityView.transform.position);
    }
    
    private void OnShipRespawned(EventShipRespawned evt)
    {
        // Same implementation as OnShipSpawned
    }
}
```

## Spawn Protection Visualization

The spawn protection state is visualized in Unity:

```csharp
public class ShipView : MonoBehaviour
{
    public Renderer[] renderers;
    MaterialPropertyBlock prop;
    
    void PlayerVulnerableCallback(EventPlayerVulnerable evt)
    {
        if (evt.Entity == EntityRef)
        {
            // Update ship material to show it's vulnerable
            prop.SetFloat("_Invulnerable", 0);
            foreach (Renderer ren in renderers) ren.SetPropertyBlock(prop);
        }
    }
    
    private void Start()
    {
        // Initialize with invulnerable appearance
        prop = new MaterialPropertyBlock();
        prop.SetFloat("_Invulnerable", 1);
        foreach (Renderer ren in renderers) ren.SetPropertyBlock(prop);
    }
}
```

This uses a material property to create a visual effect (typically a shield or glow) that indicates spawn protection.

## Ship Prototype

Ships are defined as entity prototypes in the Quantum asset database:

```csharp
// In SimulationConfig.User.cs
public AssetRef<EntityPrototype> shipPrototype;

// In the Unity editor
[Serializable]
public class ShipPrototype
{
    public GameObject visualPrefab;
    public Collider triggerCollider;
    public ShipSpec shipSpec;
}
```

A typical ship prototype includes:
1. **Ship Component**: Core component for ship state
2. **Transform3D**: For position and rotation
3. **PhysicsCollider3D**: For collision detection
4. **PlayerLink Component**: Optional, added at runtime for player-controlled ships
5. **Configuration**: Reference to a ShipSpec asset

## Best Practices

1. **Random Distribution**: Use proper spherical distribution for random positioning
2. **Spawn Protection**: Provide temporary invulnerability to prevent spawn killing
3. **State Initialization**: Properly initialize all component state on spawn
4. **Memory Management**: Allocate and free dynamic collections (segments, queries)
5. **Event Notification**: Use events to trigger appropriate visual and audio effects
6. **Component Sequencing**: Use marker components (Destroyer) for delayed cleanup
7. **Orientation**: Ensure entities are properly oriented on the sphere surface
8. **Resource Reset**: Reset resources (boost, score) on respawn
9. **Prototype-Based Creation**: Use entity prototypes for consistent entity creation

---

# 09-unity-integration.md

# Quantum Motor Dome Unity Integration

This document explains how the Quantum simulation is integrated with Unity in the Quantum Motor Dome project, covering entity visualization, event handling, input processing, UI, camera systems, and audio.

## Integration Architecture

Quantum Motor Dome follows Quantum's standard integration pattern:

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

Key integration points:
1. **Entity Views**: Unity GameObjects that represent Quantum entities
2. **Event Handlers**: Unity components that respond to Quantum events
3. **Input Providers**: Unity components that capture input and send it to Quantum
4. **UI Controllers**: Unity components that display game state information
5. **Camera Controller**: Unity component that follows the player's ship

## Entity View System

### QuantumEntityView Component

The base entity view system uses Quantum's `EntityView` component to link Unity GameObjects to Quantum entities:

```csharp
// This is a simplified representation of Quantum's EntityView
public class QuantumEntityView : MonoBehaviour
{
    public EntityRef EntityRef { get; set; }
    private List<IEntityViewComponent> viewComponents = new List<IEntityViewComponent>();

    public void OnEntityInstantiated(EntityRef entityRef)
    {
        EntityRef = entityRef;
        
        // Initialize view components
        foreach (var component in GetComponentsInChildren<IEntityViewComponent>(true))
        {
            viewComponents.Add(component);
            component.Initialize(entityRef);
        }
    }
    
    public void OnEntityDestroyed()
    {
        foreach (var component in viewComponents)
        {
            component.OnEntityDestroyed();
        }
    }
    
    public static QuantumEntityView FindEntityView(EntityRef entityRef)
    {
        // Implementation...
    }
}
```

### ShipView Component

The `ShipView` component handles the visual representation of ships:

```csharp
public unsafe class ShipView : MonoBehaviour
{
    public static ShipView Local { get; private set; }

    public AudioSource boostSrc;
    public GameObject explosionPrefab;

    public Transform pivot;
    public Transform socket;
    public Transform reconnectTarget;
    [SerializeField] LineRenderer ren;
    public Renderer[] renderers;
    public LineRenderer trailRenderer;

    public float oversteerAmount = 10;
    public float rollAmount = 45;
    public float steerVisualRate = 20;
    public float connectionSmoothSpeed = 5f;

    int trailSegs = 0;

    public EntityRef EntityRef { get; private set; }
    public PlayerRef PlayerRef { get; private set; }
    QuantumGame game;

    int? reconnectTick = null;
    bool wasBoosting = false;

    MaterialPropertyBlock prop;

    public void Initialize()
    {
        EntityRef = GetComponentInParent<QuantumEntityView>().EntityRef;
        if (EntityRef.IsValid)
        {
            PlayerRef = QuantumRunner.Default.Game.Frames.Predicted.Unsafe.GetPointer<PlayerLink>(EntityRef)->Player;
            game = QuantumRunner.Default.Game;

            QuantumEvent.Subscribe<EventPlayerDataChanged>(this, PlayerDataChangedCallback);
            QuantumEvent.Subscribe<EventPlayerVulnerable>(this, PlayerVulnerableCallback);

            if (game.PlayerIsLocal(PlayerRef))
            {
                Local = this;
                CameraController.Instance.follow = transform;
                
            }
            else
            {
                // create worldspace UI nickname
                Instantiate(InterfaceManager.Instance.worldCanvasNickname, InterfaceManager.Instance.worldCanvas.transform)
                    .SetNickname(PlayerNicknames.Get(PlayerRef))
                    .SetTarget(transform);
            }

            RuntimePlayer data = game.Frames.Verified.GetPlayerData(PlayerRef);

            prop = new();

            prop.SetFloat("_Invulnerable", 1);

            ColorRGBA c;
            c = data.primaryColor;    prop.SetColor(ResourceManager.Instance.shipMatPrimaryString, new Color32(c.R, c.G, c.B, 255));
            c = data.secondaryColor;  prop.SetColor(ResourceManager.Instance.shipMatSecondaryString, new Color32(c.R, c.G, c.B, 255));
            c = data.trailColor;      prop.SetColor(ResourceManager.Instance.shipMatTrailString, new Color32(c.R, c.G, c.B, 255));

            trailRenderer.colorGradient = new Color32(c.R, c.G, c.B, 255).ToGradient();

            foreach (Renderer ren in renderers) ren.SetPropertyBlock(prop);
        }
    }

    public void EntityDestroyed()
    {
        if (QuantumRunner.Default?.IsRunning == true)
        {
            if (Local == this)
            {
                CameraController.Instance.Effects.IsBoosting = false;
                InterfaceManager.Instance.socketIndicator.indicatorEnabled = false;
                QuantumEvent.UnsubscribeListener<EventPlayerDataChanged>(this);
                QuantumEvent.UnsubscribeListener<EventPlayerVulnerable>(this);
                Local = null;
            }
        }
        Destroy(gameObject);
    }

    private void Update()
    {
        if (reconnectTick.HasValue)
        {
            socket.rotation = Quaternion.RotateTowards(socket.rotation, pivot.rotation, 360 * Time.deltaTime);

            pivot.position = Vector3.MoveTowards(pivot.position, reconnectTarget.position, connectionSmoothSpeed * Time.deltaTime);
            pivot.rotation = Quaternion.RotateTowards(pivot.rotation, reconnectTarget.rotation, 360 * Time.deltaTime);

            return;
        }

        Ship* player = game.Frames.Predicted.Unsafe.GetPointer<Ship>(EntityRef);
        Quantum.Collections.QList<Photon.Deterministic.FPVector3> segs = game.Frames.Predicted.ResolveList(player->Segments);

        if (Local == this)
        {
            CameraController.Instance.Effects.IsBoosting = player->IsBoosting;
            InterfaceManager.Instance.boostBar.fillAmount = player->BoostAmount.AsFloat * 0.01f;
            InterfaceManager.Instance.boostPercentText.text = $"{Mathf.CeilToInt(player->BoostAmount.AsFloat)}%";
        }

        if (player->IsBoosting && !wasBoosting)     boostSrc.Play();
        else if (!player->IsBoosting && wasBoosting)    boostSrc.Stop();

        ren.positionCount = segs.Count;
        for (int i = 0; i < segs.Count; i++)
        {
            Photon.Deterministic.FPVector3* seg = segs.GetPointer(i);
            ren.SetPosition(i, seg->ToUnityVector3());
        }

        if (trailSegs <= 1 && segs.Count > 1)
        {
            // disconnect socket from ship
            socket.SetParent(transform);
        }

        trailSegs = segs.Count;

        if (trailSegs > 1)
        {
            Vector3 end = segs.GetPointer(0)->ToUnityVector3();
            Vector3 next = segs.GetPointer(1)->ToUnityVector3();
            socket.position = end;
            socket.rotation = Quaternion.LookRotation(next - end, -end);
        }
        
        Quaternion rollRot = Quaternion.AngleAxis(player->SteerAmount.AsFloat * -rollAmount, Vector3.forward);
        Quaternion oversteerRot = Quaternion.Euler(0, player->SteerAmount.AsFloat * oversteerAmount, 0);
        Quaternion tgtRot = oversteerRot * rollRot;
        Quaternion srcRot = pivot.localRotation;
        pivot.localRotation = Quaternion.RotateTowards(srcRot, tgtRot, Mathf.Sqrt(Quaternion.Angle(srcRot, tgtRot)) * steerVisualRate * Time.deltaTime);

        wasBoosting = player->IsBoosting;
    }

    void PlayerDataChangedCallback(EventPlayerDataChanged evt)
    {
        if (evt.Player == PlayerRef)
        {
            reconnectTick = evt.Tick;
            QuantumEvent.UnsubscribeListener<EventPlayerDataChanged>(this);
        }
    }

    void PlayerVulnerableCallback(EventPlayerVulnerable evt)
    {
        Debug.Log("Vulnerable", gameObject);
        prop.SetFloat("_Invulnerable", 0);
        foreach (Renderer ren in renderers) ren.SetPropertyBlock(prop);
    }
}
```

Key aspects of the ShipView component:
1. **Initialization**: Sets up colors, effects, and event subscriptions
2. **Update**: Synchronizes visual representation with simulation state
3. **Trail Rendering**: Visualizes the ship's trail using a LineRenderer
4. **Visual Effects**: Applies roll and oversteer based on steering input
5. **Boost Effects**: Manages audio and visual effects for boosting
6. **Reconnection Animation**: Handles the visual animation for trail reconnection
7. **Invulnerability Visualization**: Shows spawn protection state

## Event Handling

### Event Subscription System

The `EventSubscriptions` class centralizes event subscriptions:

```csharp
public class EventSubscriptions : MonoBehaviour
{
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventGameStateChanged>(this, OnGameStateChanged);
        QuantumEvent.Subscribe<EventShipSpawned>(this, OnShipSpawned);
        QuantumEvent.Subscribe<EventShipExploded>(this, OnShipExploded);
        QuantumEvent.Subscribe<EventPickupCollected>(this, OnPickupCollected);
        QuantumEvent.Subscribe<EventPlayerReconnected>(this, OnPlayerReconnected);
        QuantumEvent.Subscribe<EventPlayerKilled>(this, OnPlayerKilled);
        // Additional event subscriptions...
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventGameStateChanged>(this);
        QuantumEvent.UnsubscribeListener<EventShipSpawned>(this);
        QuantumEvent.UnsubscribeListener<EventShipExploded>(this);
        QuantumEvent.UnsubscribeListener<EventPickupCollected>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerReconnected>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerKilled>(this);
        // Additional event unsubscriptions...
    }
    
    private void OnGameStateChanged(EventGameStateChanged evt)
    {
        // Handle game state transitions
        // Implementation...
    }
    
    private void OnShipSpawned(EventShipSpawned evt)
    {
        // Handle ship spawning
        // Implementation...
    }
    
    // Additional event handlers...
}
```

### Game State Bridge

The `GameStateBridge` class handles game state transitions:

```csharp
public class GameStateBridge : MonoBehaviour
{
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventGameStateChanged>(this, OnGameStateChanged);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventGameStateChanged>(this);
    }
    
    private void OnGameStateChanged(EventGameStateChanged evt)
    {
        switch (evt.NewState)
        {
            case GameState.Lobby:
                UIScreen.Focus(InterfaceManager.Instance.lobbyScreen);
                break;
            case GameState.Pregame:
                // Load map and prepare for game
                break;
            case GameState.Intro:
                InterfaceManager.Instance.ShowIntro();
                break;
            case GameState.Countdown:
                UIScreen.Focus(InterfaceManager.Instance.countdownScreen);
                break;
            case GameState.Game:
                UIScreen.Focus(InterfaceManager.Instance.hudScreen);
                break;
            case GameState.Outro:
                InterfaceManager.Instance.ShowOutro();
                break;
            case GameState.Postgame:
                UIScreen.Focus(InterfaceManager.Instance.resultsScreen);
                break;
        }
    }
}
```

## Input Processing

### LocalInput Component

The `LocalInput` component captures Unity input and sends it to Quantum:

```csharp
public class LocalInput : MonoBehaviour
{
    private void OnEnable()
    {
        QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
    }

    private void Update()
    {
        if (UnityEngine.Input.GetKeyDown(KeyCode.P))
        {
            if (UIScreen.activeScreen == InterfaceManager.Instance.hudScreen)
                UIScreen.Focus(InterfaceManager.Instance.pauseScreen);
            else if (UIScreen.ScreenInHierarchy(InterfaceManager.Instance.hudScreen))
                UIScreen.activeScreen.BackTo(InterfaceManager.Instance.hudScreen);
        }
    }

    public void PollInput(CallbackPollInput callback)
    {
        Quantum.Input i = new()
        {
            steer = UnityEngine.Input.GetAxis("Horizontal").ToFP(),
            boost = UnityEngine.Input.GetButton("Boost"),
            brake = UnityEngine.Input.GetButton("Brake")
        };

        callback.SetInput(i, DeterministicInputFlags.Repeatable);
    }
}
```

Key aspects of input processing:
1. **Input Conversion**: Converts Unity input to deterministic Quantum input
2. **Input Mapping**: Maps Unity input axes to Quantum input properties
3. **UI Input Separation**: Handles UI-specific input separately from gameplay input
4. **Determinism Flag**: Uses the Repeatable flag to ensure deterministic behavior

## UI System

### InterfaceManager

The `InterfaceManager` class manages UI screens and elements:

```csharp
public class InterfaceManager : MonoBehaviour
{
    public static InterfaceManager Instance { get; private set; }
    
    [Header("UI Screens")]
    public UIScreen lobbyScreen;
    public UIScreen countdownScreen;
    public UIScreen hudScreen;
    public UIScreen pauseScreen;
    public UIScreen resultsScreen;
    
    [Header("HUD Elements")]
    public Image boostBar;
    public Text boostPercentText;
    public SocketIndicator socketIndicator;
    public GameObject worldCanvas;
    public WorldSpaceNickname worldCanvasNickname;
    
    [Header("Intro/Outro")]
    public IntroSequence introSequence;
    public OutroSequence outroSequence;
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    public void ShowIntro()
    {
        introSequence.Play();
    }
    
    public void ShowOutro()
    {
        outroSequence.Play();
    }
    
    // Additional methods...
}
```

### UIScreen System

The `UIScreen` class handles screen transitions:

```csharp
public class UIScreen : MonoBehaviour
{
    public static UIScreen activeScreen { get; private set; }
    
    [SerializeField] private UIScreen parentScreen;
    [SerializeField] private bool hideOnStart = true;
    
    private void Start()
    {
        if (hideOnStart)
        {
            gameObject.SetActive(false);
        }
    }
    
    public static void Focus(UIScreen screen)
    {
        if (activeScreen != null)
        {
            activeScreen.gameObject.SetActive(false);
        }
        
        screen.gameObject.SetActive(true);
        activeScreen = screen;
    }
    
    public void BackTo(UIScreen targetScreen)
    {
        Focus(targetScreen);
    }
    
    public static bool ScreenInHierarchy(UIScreen screen)
    {
        UIScreen current = activeScreen;
        while (current != null)
        {
            if (current == screen)
            {
                return true;
            }
            current = current.parentScreen;
        }
        return false;
    }
}
```

### Scoreboard UI

The `ScoreboardUI` class displays player scores:

```csharp
public class ScoreboardUI : MonoBehaviour
{
    [SerializeField] private GameObject scoreEntryPrefab;
    [SerializeField] private Transform scoreboardContainer;
    
    private Dictionary<PlayerRef, ScoreEntry> scoreEntries = new Dictionary<PlayerRef, ScoreEntry>();
    
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventPlayerScoreChanged>(this, OnPlayerScoreChanged);
        QuantumEvent.Subscribe<EventPlayerKilled>(this, OnPlayerKilled);
        QuantumEvent.Subscribe<EventPlayerReconnected>(this, OnPlayerReconnected);
        QuantumEvent.Subscribe<EventGameResults>(this, OnGameResults);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventPlayerScoreChanged>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerKilled>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerReconnected>(this);
        QuantumEvent.UnsubscribeListener<EventGameResults>(this);
    }
    
    private void OnPlayerScoreChanged(EventPlayerScoreChanged evt)
    {
        UpdateScore(evt.Player);
    }
    
    private void OnPlayerKilled(EventPlayerKilled evt)
    {
        UpdateScore(evt.Killer);
    }
    
    private void OnPlayerReconnected(EventPlayerReconnected evt)
    {
        // Find player ref from entity
        QuantumRunner.Default.Game.Frames.Verified.TryGetComponent<PlayerLink>(
            evt.Entity, out var playerLink);
        
        if (playerLink != null)
        {
            UpdateScore(playerLink.Player);
        }
    }
    
    private void OnGameResults(EventGameResults evt)
    {
        // Update final results
        // Implementation...
    }
    
    private void UpdateScore(PlayerRef player)
    {
        // Get player score from Quantum
        var game = QuantumRunner.Default.Game;
        game.Frames.Verified.Global.playerData.TryGetValue(
            player, out var playerData);
        
        // Update UI
        if (scoreEntries.TryGetValue(player, out var entry))
        {
            entry.UpdateScore(playerData.points);
        }
        else
        {
            // Create new score entry
            var newEntry = Instantiate(scoreEntryPrefab, scoreboardContainer).GetComponent<ScoreEntry>();
            newEntry.Initialize(player, playerData.points);
            scoreEntries[player] = newEntry;
        }
        
        // Sort scoreboard by score
        SortScoreboard();
    }
    
    private void SortScoreboard()
    {
        // Sort children by score
        var entries = scoreboardContainer.GetComponentsInChildren<ScoreEntry>()
            .OrderByDescending(e => e.Score)
            .ToList();
            
        // Update sibling indices to reorder
        for (int i = 0; i < entries.Count; i++)
        {
            entries[i].transform.SetSiblingIndex(i);
        }
    }
}
```

## Camera System

### CameraController

The `CameraController` class manages the camera's movement and effects:

```csharp
public class CameraController : MonoBehaviour
{
    public static CameraController Instance { get; private set; }
    
    public Transform follow;
    public CameraEffects Effects { get; private set; }
    
    [SerializeField] private Vector3 offset = new Vector3(0, 5, -8);
    [SerializeField] private float followSpeed = 5f;
    [SerializeField] private float rotationSpeed = 2f;
    [SerializeField] private float lookAheadFactor = 0.5f;
    
    private Vector3 velocity;
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            Effects = GetComponent<CameraEffects>();
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    private void LateUpdate()
    {
        if (follow == null) return;
        
        // Get target position with offset
        Vector3 targetPosition = follow.position + follow.TransformDirection(offset);
        
        // Look ahead based on ship velocity
        if (ShipView.Local != null)
        {
            var ship = QuantumRunner.Default.Game.Frames.Predicted.Unsafe.GetPointer<Ship>(ShipView.Local.EntityRef);
            Vector3 velocity = ship->Velocity.ToUnityVector3();
            targetPosition += velocity * lookAheadFactor;
        }
        
        // Smooth follow
        transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, 1f / followSpeed);
        
        // Look at target
        Vector3 lookDirection = follow.position - transform.position;
        Quaternion targetRotation = Quaternion.LookRotation(lookDirection);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);
    }
}
```

### CameraEffects

The `CameraEffects` class handles camera visual effects:

```csharp
public class CameraEffects : MonoBehaviour
{
    [SerializeField] private PostProcessVolume postProcessVolume;
    
    private bool isBoosting;
    public bool IsBoosting
    {
        get => isBoosting;
        set
        {
            if (isBoosting != value)
            {
                isBoosting = value;
                UpdateEffects();
            }
        }
    }
    
    [SerializeField] private float boostFOVIncrease = 10f;
    [SerializeField] private float boostBloomIntensity = 1.5f;
    [SerializeField] private float normalBloomIntensity = 1f;
    
    private Camera cam;
    private float baseFOV;
    private Bloom bloom;
    
    private void Awake()
    {
        cam = GetComponent<Camera>();
        baseFOV = cam.fieldOfView;
        postProcessVolume.profile.TryGetSettings(out bloom);
    }
    
    private void UpdateEffects()
    {
        // Adjust FOV for boost effect
        LeanTween.cancel(gameObject);
        if (isBoosting)
        {
            LeanTween.value(gameObject, cam.fieldOfView, baseFOV + boostFOVIncrease, 0.2f)
                .setOnUpdate((float val) => cam.fieldOfView = val);
            
            LeanTween.value(gameObject, bloom.intensity.value, boostBloomIntensity, 0.2f)
                .setOnUpdate((float val) => bloom.intensity.value = val);
        }
        else
        {
            LeanTween.value(gameObject, cam.fieldOfView, baseFOV, 0.2f)
                .setOnUpdate((float val) => cam.fieldOfView = val);
                
            LeanTween.value(gameObject, bloom.intensity.value, normalBloomIntensity, 0.2f)
                .setOnUpdate((float val) => bloom.intensity.value = val);
        }
    }
    
    public void ShakeCamera(float intensity)
    {
        // Implementation of camera shake effect
        // ...
    }
}
```

## Audio System

### AudioManager

The `AudioManager` class manages game audio:

```csharp
public class AudioManager : MonoBehaviour
{
    public static AudioManager Instance { get; private set; }
    
    [Header("Music")]
    [SerializeField] private AudioClip menuMusic;
    [SerializeField] private AudioClip gameMusic;
    [SerializeField] private AudioClip resultMusic;
    
    [Header("Sound Effects")]
    [SerializeField] private AudioClip countdownSound;
    [SerializeField] private AudioClip explosionSound;
    [SerializeField] private AudioClip reconnectSound;
    [SerializeField] private AudioClip pickupSound;
    
    private AudioSource musicSource;
    private AudioSource sfxSource;
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            
            // Create audio sources
            musicSource = gameObject.AddComponent<AudioSource>();
            musicSource.loop = true;
            
            sfxSource = gameObject.AddComponent<AudioSource>();
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    private void OnEnable()
    {
        QuantumEvent.Subscribe<EventGameStateChanged>(this, OnGameStateChanged);
        QuantumEvent.Subscribe<EventShipExploded>(this, OnShipExploded);
        QuantumEvent.Subscribe<EventPlayerReconnected>(this, OnPlayerReconnected);
        QuantumEvent.Subscribe<EventPickupCollected>(this, OnPickupCollected);
    }
    
    private void OnDisable()
    {
        QuantumEvent.UnsubscribeListener<EventGameStateChanged>(this);
        QuantumEvent.UnsubscribeListener<EventShipExploded>(this);
        QuantumEvent.UnsubscribeListener<EventPlayerReconnected>(this);
        QuantumEvent.UnsubscribeListener<EventPickupCollected>(this);
    }
    
    private void OnGameStateChanged(EventGameStateChanged evt)
    {
        switch (evt.NewState)
        {
            case GameState.Lobby:
            case GameState.Pregame:
                PlayMusic(menuMusic);
                break;
            case GameState.Countdown:
            case GameState.Game:
                PlayMusic(gameMusic);
                break;
            case GameState.Postgame:
                PlayMusic(resultMusic);
                break;
        }
    }
    
    private void OnShipExploded(EventShipExploded evt)
    {
        QuantumEntityView view = QuantumEntityView.FindEntityView(evt.Entity);
        if (view != null)
        {
            PlaySFXAtPosition(explosionSound, view.transform.position);
        }
    }
    
    private void OnPlayerReconnected(EventPlayerReconnected evt)
    {
        QuantumEntityView view = QuantumEntityView.FindEntityView(evt.Entity);
        if (view != null)
        {
            PlaySFXAtPosition(reconnectSound, view.transform.position);
        }
    }
    
    private void OnPickupCollected(EventPickupCollected evt)
    {
        QuantumEntityView view = QuantumEntityView.FindEntityView(evt.Entity);
        if (view != null)
        {
            PlaySFXAtPosition(pickupSound, view.transform.position);
        }
    }
    
    public void PlayMusic(AudioClip clip)
    {
        if (musicSource.clip != clip)
        {
            musicSource.clip = clip;
            musicSource.Play();
        }
    }
    
    public void PlaySFX(AudioClip clip)
    {
        sfxSource.PlayOneShot(clip);
    }
    
    public void PlaySFXAtPosition(AudioClip clip, Vector3 position)
    {
        AudioSource.PlayClipAtPoint(clip, position);
    }
}
```

## Visual Effects System

### PickupView

The `PickupView` component handles pickup visualization:

```csharp
public class PickupView : MonoBehaviour
{
    public float rotationSpeed = 50f;
    public float bounceHeight = 0.3f;
    public float bounceSpeed = 2f;
    
    private Vector3 startPosition;
    
    private void Start()
    {
        startPosition = transform.localPosition;
    }
    
    private void Update()
    {
        // Rotate pickup
        transform.Rotate(Vector3.up, rotationSpeed * Time.deltaTime);
        
        // Bounce pickup
        float bounce = Mathf.Sin(Time.time * bounceSpeed) * bounceHeight;
        transform.localPosition = startPosition + Vector3.up * bounce;
    }
}
```

### ExplosionEffect

The `ExplosionEffect` component manages explosion visuals:

```csharp
public class ExplosionEffect : MonoBehaviour
{
    [SerializeField] private ParticleSystem explosionParticles;
    [SerializeField] private Light explosionLight;
    [SerializeField] private float duration = 2f;
    
    private void Start()
    {
        // Start explosion effect
        explosionParticles.Play();
        
        // Create light pulse effect
        LeanTween.value(gameObject, explosionLight.intensity, 0, duration)
            .setEaseOutExpo()
            .setOnUpdate((float val) => explosionLight.intensity = val)
            .setOnComplete(() => Destroy(gameObject));
    }
}
```

## Resource Management

### ResourceManager

The `ResourceManager` class manages shared resources:

```csharp
public class ResourceManager : MonoBehaviour
{
    public static ResourceManager Instance { get; private set; }
    
    [Header("Ship Materials")]
    public string shipMatPrimaryString = "_PrimaryColor";
    public string shipMatSecondaryString = "_SecondaryColor";
    public string shipMatTrailString = "_TrailColor";
    
    [Header("Prefabs")]
    public GameObject explosionPrefab;
    public GameObject reconnectEffectPrefab;
    public GameObject boostPickupPrefab;
    public GameObject trailPickupPrefab;
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

## Map Loading System

### SceneLoader

The `SceneLoader` class handles Unity scene loading:

```csharp
public class SceneLoader : MonoBehaviour
{
    [SerializeField] private string menuSceneName = "Menu";
    [SerializeField] private string gameSceneName = "Game";
    
    public void LoadMenuScene()
    {
        SceneManager.LoadScene(menuSceneName);
    }
    
    public void LoadGameScene()
    {
        SceneManager.LoadScene(gameSceneName);
    }
}
```

### Map Visualization

The game visualizes the spherical map using a simple sphere mesh with shader effects:

```csharp
public class MapVisualizer : MonoBehaviour
{
    [SerializeField] private MeshRenderer sphereRenderer;
    [SerializeField] private Material mapMaterial;
    [SerializeField] private float rotationSpeed = 1f;
    
    private void Start()
    {
        sphereRenderer.material = mapMaterial;
    }
    
    private void Update()
    {
        // Slowly rotate the map for visual interest
        transform.Rotate(Vector3.up, rotationSpeed * Time.deltaTime);
    }
    
    public void SetMapColors(Color primaryColor, Color secondaryColor)
    {
        mapMaterial.SetColor("_PrimaryColor", primaryColor);
        mapMaterial.SetColor("_SecondaryColor", secondaryColor);
    }
}
```

## Integration with Quantum Runner

The `World` class integrates with Quantum's runner:

```csharp
public class World : MonoBehaviour
{
    [SerializeField] private RuntimeConfigContainer defaultConfig;
    
    private QuantumRunnerCallbacks callbacks;
    
    private void Awake()
    {
        // Create callbacks container
        callbacks = new QuantumRunnerCallbacks();
        
        // Register quantum callbacks
        QuantumCallback.Subscribe(this, (CallbackGameStarted callback) => OnGameStarted());
        QuantumCallback.Subscribe(this, (CallbackGameDestroyed callback) => OnGameDestroyed());
    }
    
    public void StartGame(RuntimeConfigContainer config = null)
    {
        if (QuantumRunner.Default?.IsRunning == true)
        {
            QuantumRunner.ShutdownAll();
        }
        
        if (config == null)
        {
            config = defaultConfig;
        }
        
        var startParams = new QuantumRunner.StartParameters
        {
            GameMode = DeterministicGameMode.Spectator,
            RuntimeConfig = config,
            InitialFrame = null,
            PlayerCount = config.DriverCount,
            LocalPlayer = LocalData.CreateLocalPlayerData()
        };
        
        QuantumRunner.StartGame(startParams);
    }
    
    private void OnGameStarted()
    {
        // Game started initialization
        // Implementation...
    }
    
    private void OnGameDestroyed()
    {
        // Cleanup
        // Implementation...
    }
}
```

## Best Practices

1. **Separation of Concerns**: Keep Unity visualization code separate from Quantum simulation logic
2. **Event-Based Communication**: Use events for clean communication from Quantum to Unity
3. **Local Player Handling**: Identify and handle the local player's ship differently
4. **Resource Management**: Use singleton managers for shared resources
5. **Performance Optimization**: Use object pooling and LOD for better performance
6. **Predictive Visualization**: Use predicted frames for visualization to reduce perceived latency
7. **Visual Feedback**: Provide clear visual feedback for gameplay events
8. **Audio Integration**: Link audio effects to simulation events
9. **Consistent Event Handling**: Subscribe to events systematically and unsubscribe when disabled
10. **Camera Effects**: Use camera effects to enhance gameplay feel

---

# 00-project-overview.md

# Quantum Platform Shooter 2D Project Overview

This document provides a comprehensive overview of the Quantum Platform Shooter 2D sample project for Photon Quantum 3.0.2. The notes in this directory are structured to help you understand how Quantum works in practice through this sample game.

## Project Structure

The Platform Shooter 2D game demonstrates a multiplayer 2D shooter built with Quantum's deterministic networking framework. The project is organized as follows:

### Core Simulation Code (Quantum)
- **Assets/QuantumUser/Simulation**: Contains all the deterministic simulation code
  - `.qtn` files: Quantum DSL files defining the game state (Character, Bullet, Weapon, etc.)
  - Systems: Implement game logic (Movement, Weapons, Bullets, Skills, etc.)
  - Data classes: Define configuration for game objects

### Unity View Code
- **Assets/PlatformShooter2D/Runtime**: Contains Unity-side view code
  - Character views and animations
  - Visual effects and audio
  - UI elements and HUD
  - Input handling

## Key Features Demonstrated

1. **Character Controller**: Deterministic 2D platformer movement
2. **Weapons System**: Multiple weapon types with different behaviors
3. **Skills System**: Character abilities with cooldowns
4. **Combat**: Projectiles, collision detection, and damage
5. **Respawn System**: Player respawning after death
6. **Input Handling**: Player input collection and processing

## Documentation Structure

The following documents provide detailed breakdowns of the different systems in the Platform Shooter 2D sample:

1. [Game State Definition](01-game-state-definition.md): How game state is defined using Quantum DSL
2. [Character System](02-character-system.md): Player character implementation
3. [Movement System](03-movement-system.md): Character movement and physics
4. [Weapons and Combat](04-weapons-and-combat.md): Weapons, bullets, and damage
5. [Skills System](05-skills-system.md): Character abilities implementation
6. [Unity Integration](06-unity-integration.md): How Unity view connects to Quantum
7. [Input Handling](07-input-handling.md): Input processing workflow

Each document contains code examples that demonstrate Quantum patterns and how they're applied in an actual game.

## Architecture Overview

Quantum Platform Shooter 2D follows Quantum's core architecture principles:

### Simulation-View Separation

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

- **Simulation**: Deterministic game logic running in Quantum
- **View**: Visual representation in Unity
- **Events**: One-way communication from simulation to view
- **Input**: Player commands sent from view to simulation

### ECS Implementation

The game uses Quantum's Entity Component System:
- **Entities**: Dynamic game objects (characters, bullets, skills)
- **Components**: Data containers attached to entities
- **Systems**: Logic that processes entities with specific components

### Networking Model

The predict/rollback networking model:
- **Prediction**: Each client predicts game state based on local input
- **Rollback**: When actual input arrives, state is corrected if necessary
- **Determinism**: Same input always produces the same output

## Core Systems Overview

### Player System
- Handles player joining
- Creates character entities
- Links players to characters

### Movement System
- Processes movement input
- Updates character positions
- Manages platformer physics using KCC2D

### Weapon System
- Handles weapon firing
- Manages ammunition and reloading
- Creates bullet entities

### Bullet System
- Updates bullet positions
- Detects collisions using raycasts
- Applies damage on hit

### Skill System
- Handles skill casting
- Creates skill entities
- Applies area effects

### Status System
- Manages character health
- Handles damage application
- Controls death and respawn

## Quantum-Unity Integration

The integration between Quantum and Unity is handled through:
- **Entity Views**: Connect Unity GameObjects to Quantum entities
- **Event Handlers**: Subscribe to Quantum events for visual effects
- **Input Polling**: Capture Unity input for Quantum simulation

## How To Use These Notes

- Start with the Project Overview to understand the game's architecture
- Read through the Game State Definition to see how Quantum DSL is used
- Follow the other documents based on the specific systems you're interested in
- Use the code examples as reference when implementing similar systems

The focus is on presenting accurate, error-free code examples that can be used as templates for your own Quantum projects.

---

# 01-game-state-definition.md

# Game State Definition in Quantum Platform Shooter 2D

This document explains how the game state is defined in the Platform Shooter 2D sample project using Quantum's Domain-Specific Language (DSL).

## Core Game State Components

The Platform Shooter 2D game uses several `.qtn` files to define its game state. These files describe the components, events, and data structures that make up the core gameplay elements.

### Character State

The character state is defined in `Character.qtn`:

```qtn
component PlayerLink
{
    player_ref Player;
}

component Status
{
    asset_ref<StatusData> StatusData;
    FP CurrentHealth;
    Boolean IsDead;
    FrameTimer RespawnTimer;
    FrameTimer RegenTimer;
    FrameTimer InvincibleTimer;
    FrameTimer DisconnectedTimer;
}

event OnPlayerSelectedCharacter
{
    local player_ref PlayerRef;
}

component MovementData
{
    Boolean IsFacingRight;
}
```

Key components:
- **PlayerLink**: Connects an entity to a player index
- **Status**: Contains health and timers for game mechanics
- **MovementData**: Tracks movement state (facing direction)

### Weapon System

The weapon system is defined in `Weapon.qtn`:

```qtn
struct Weapon
{
    Boolean IsRecharging;
    Int32 CurrentAmmo;
    FrameTimer FireRateTimer;
    FrameTimer DelayToStartRechargeTimer;
    FrameTimer RechargeRate;
    FP ChargeTime;
    asset_ref<WeaponData> WeaponData;
}

component WeaponInventory
{
    Int32 CurrentWeaponIndex;
    array<Weapon>[2] Weapons;
}

event OnWeaponShoot
{
    entity_ref Character;
}
```

Key elements:
- **Weapon struct**: Contains weapon state including ammo and timing
- **WeaponInventory**: Component that holds an array of weapons
- **OnWeaponShoot**: Event triggered when a weapon is fired

### Bullet System

The bullet system is defined in `Bullet.qtn`:

```qtn
component BulletFields
{
    entity_ref Source;
    FPVector2 Direction;
    asset_ref<BulletData> BulletData;
}

event OnBulletDestroyed
{
    Int32 BulletRefHashCode;
    entity_ref Owner;
    nothashed FPVector2 BulletPosition;
    nothashed FPVector2 BulletDirection;
    asset_ref<BulletData> BulletData;
}
```

Key elements:
- **BulletFields**: Component containing bullet properties
- **OnBulletDestroyed**: Event triggered when a bullet is destroyed

### Skill System

The skill system is defined in `Skill.qtn`:

```qtn
component SkillFields
{
    FP TimeToActivate;
    entity_ref Source;
    asset_ref<SkillData> SkillData;
}

component SkillInventory
{
    FrameTimer CastRateTimer;
    asset_ref<SkillInventoryData> SkillInventoryData;
}

event OnSkillCasted
{
    entity_ref Skill;
}

event OnSkillActivated
{
    FPVector2 SkillPosition;
}

event OnSkillHitTarget
{
    FPVector2 SkillPosition;
    Int64 SkillDataId;
    entity_ref Target;
}
```

Key elements:
- **SkillFields**: Component containing skill properties
- **SkillInventory**: Holds skills and their cooldowns
- **Events**: Several events for different skill phases (cast, activation, hit)

## Asset References

The game state makes extensive use of `asset_ref<T>` to reference configuration data:

```qtn
asset_ref<StatusData> StatusData;
asset_ref<BulletData> BulletData;
asset_ref<WeaponData> WeaponData;
asset_ref<SkillData> SkillData;
```

These references point to asset classes defined in C# that contain configuration data, such as:

```csharp
// Example from WeaponData.cs
public class WeaponData : AssetObject {
    public string Name;
    public FP FireRate;
    public Int32 MaxAmmo;
    public FP RechargeRate;
    public FP DelayToStartRecharge;
    public AssetRefEntityPrototype BulletPrototype;
    // ...
}
```

## Entity References

The game state uses `entity_ref` to create relationships between entities:

```qtn
entity_ref Source;  // In BulletFields, references the entity that fired the bullet
entity_ref Owner;   // In OnBulletDestroyed, references the bullet's owner
entity_ref Target;  // In OnSkillHitTarget, references the entity hit by a skill
```

## Timers

The Platform Shooter 2D game makes extensive use of `FrameTimer` for time-based mechanics:

```qtn
FrameTimer RespawnTimer;
FrameTimer FireRateTimer;
FrameTimer CastRateTimer;
```

A `FrameTimer` is a Quantum-provided struct that facilitates deterministic timing based on simulation frames rather than real-time seconds.

## Events for View Communication

Events defined in `.qtn` files are used to communicate from simulation to view:

```qtn
event OnWeaponShoot { /* ... */ }
event OnBulletDestroyed { /* ... */ }
event OnSkillCasted { /* ... */ }
```

These events are triggered in the simulation code and can be subscribed to in Unity view code to trigger visual effects, animations, or sounds.

## Best Practices for DSL in Quantum

Based on the Platform Shooter 2D implementation:

1. **Keep components focused**: Each component should have a single responsibility
2. **Use appropriate types**: Use Quantum fixed-point types (`FP`) for all floating-point values to ensure determinism
3. **Leverage FrameTimers**: Use `FrameTimer` for any time-based mechanics
4. **Use asset references**: Store configuration in assets and reference them with `asset_ref<T>`
5. **Define clear events**: Use events to communicate between simulation and view
6. **Use appropriate event modifiers**: Use `nothashed` for position fields in events to prevent minor differences causing duplicate events
7. **Use local/remote modifiers**: Events like `OnPlayerSelectedCharacter` use the `local` modifier to ensure they're only processed on the local player's machine

These practices ensure deterministic behavior across all clients in a networked game.

---

# 02-character-system.md

# Character System in Quantum Platform Shooter 2D

This document explains how the Character System is implemented in the Platform Shooter 2D sample project, covering player creation, state management, and respawning.

## Character Components

The character system is built on several key components defined in the Quantum DSL:

```qtn
// Character.qtn
component PlayerLink
{
    player_ref Player;
}

component Status
{
    asset_ref<StatusData> StatusData;
    FP CurrentHealth;
    Boolean IsDead;
    FrameTimer RespawnTimer;
    FrameTimer RegenTimer;
    FrameTimer InvincibleTimer;
    FrameTimer DisconnectedTimer;
}

component MovementData
{
    Boolean IsFacingRight;
}
```

Additionally, characters use standard Quantum components:
- `Transform2D`: Position and rotation
- `KCC2D`: Kinematic Character Controller for 2D movement
- `PhysicsCollider2D`: For collision detection

## Player System

The `PlayerSystem` handles player joining and character creation:

```csharp
namespace Quantum
{
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class PlayerSystem : SystemSignalsOnly, ISignalOnPlayerAdded
  {
    public void OnPlayerAdded(Frame frame, PlayerRef player, bool firstTime)
    {
      var data = frame.GetPlayerData(player);

      if (data.PlayerAvatar != null)
      {
        SetPlayerCharacter(frame, player, data.PlayerAvatar);
      }
      else
      {
        Log.Warn(
          "Character prototype is null on RuntimePlayer, check QuantumMenuConnectionBehaviourSDK to prevent adding player automatically!");
      }
    }

    private void SetPlayerCharacter(Frame frame, PlayerRef player, AssetRef<EntityPrototype> prototypeAsset)
    {
      // Create the entity from the prototype
      var characterEntity = frame.Create(prototypeAsset);

      // Link the entity to the player
      var playerLink = frame.Unsafe.GetPointer<PlayerLink>(characterEntity);
      playerLink->Player = player;

      // Signal that the character has respawned (initial spawn)
      frame.Signals.OnCharacterRespawn(characterEntity);

      // Trigger events for view notification
      frame.Events.OnCharacterCreated(characterEntity);
      frame.Events.OnPlayerSelectedCharacter(player);
    }
  }
}
```

Key aspects:
1. Implements `ISignalOnPlayerAdded` to receive notifications when players join
2. Creates a character entity from the prototype stored in the player data
3. Links the entity to the player through the `PlayerLink` component
4. Triggers signals and events for respawn handling and view notification

## Respawn System

The `RespawnSystem` handles character death and respawning:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine.Scripting;
  using Collections;

  [Preserve]
  public unsafe class RespawnSystem : SystemMainThread, ISignalOnCharacterRespawn,
    ISignalOnComponentAdded<SpawnIdentifier>
  {
    public void OnAdded(Frame frame, EntityRef entity, SpawnIdentifier* component)
    {
      // Add spawn point to the list
      var spawnPlaces = frame.Unsafe.GetPointerSingleton<SpawnPlaces>();
      if (frame.TryResolveList(spawnPlaces->Spawners, out var spawns) == false)
      {
        spawns = InitSpawns(frame);
      }
      spawns.Add(entity);
    }

    private QList<EntityRef> InitSpawns(Frame frame)
    {
      // Initialize spawn points list if needed
      var spawnPlaces = frame.Unsafe.GetPointerSingleton<SpawnPlaces>();
      frame.AllocateList(out spawnPlaces->Spawners);
      return frame.ResolveList(spawnPlaces->Spawners);
    }

    public override void Update(Frame frame)
    {
      // Check for dead characters that need respawning
      foreach (var (character, characterStatus) in frame.Unsafe.GetComponentBlockIterator<Status>())
      {
        if (characterStatus->IsDead)
        {
          if (characterStatus->RespawnTimer.IsRunning(frame) == false)
          {
            frame.Signals.OnCharacterRespawn(character);
          }
        }
      }
    }

    public void OnCharacterRespawn(Frame frame, EntityRef character)
    {
      // Choose a random spawn position
      var position = FPVector2.One;

      var spawnPlaces = frame.Unsafe.GetPointerSingleton<SpawnPlaces>();
      var spawns = frame.ResolveList(spawnPlaces->Spawners);

      if (spawns.Count != 0)
      {
        int index = frame.RNG->Next(0, spawns.Count);
        position = frame.Get<Transform2D>(spawns[index]).Position;
      }

      // Set character position and enable collisions
      var characterTransform = frame.Unsafe.GetPointer<Transform2D>(character);
      var collider = frame.Unsafe.GetPointer<PhysicsCollider2D>(character);

      characterTransform->Position = position;
      collider->IsTrigger = false;

      // Trigger view event
      frame.Events.OnCharacterRespawn(character);
    }
  }
}
```

Key aspects:
1. Tracks spawn points in the level
2. Checks for dead characters and initiates respawn when timer completes
3. Handles the respawn logic by selecting a random spawn point
4. Resets character state and position
5. Notifies the view system about the respawn

## Status System

The Status System (not shown in full) handles character health and status effects:

```csharp
// Simplified example
public unsafe class StatusSystem : SystemMainThreadFilter<StatusSystem.Filter>
{
  public struct Filter
  {
    public EntityRef Entity;
    public Status* Status;
  }

  public override void Update(Frame frame, ref Filter filter)
  {
    // Health regeneration
    if (filter->Status->RegenTimer.ExpiredOrNotRunning(frame) && 
        !filter->Status->IsDead &&
        filter->Status->CurrentHealth < filter->Status->StatusData.Asset.MaxHealth)
    {
      filter->Status->CurrentHealth += filter->Status->StatusData.Asset.HealthRegen;
      filter->Status->RegenTimer.Restart(frame, filter->Status->StatusData.Asset.RegenRate);
    }

    // ... other status checks and updates
  }

  // Handle damage application
  public void OnDamageTaken(Frame frame, EntityRef entity, FP damage, EntityRef source)
  {
    if (frame.Unsafe.TryGetPointer<Status>(entity, out var status))
    {
      if (status->IsDead || status->InvincibleTimer.IsRunning(frame))
      {
        return;
      }

      // Apply damage
      status->CurrentHealth -= damage;

      // Check for death
      if (status->CurrentHealth <= FP._0)
      {
        status->IsDead = true;
        status->CurrentHealth = FP._0;
        status->RespawnTimer.Restart(frame, status->StatusData.Asset.RespawnTime);

        // Trigger death event
        frame.Events.OnCharacterDied(entity, source);
      }
      else
      {
        // Trigger damage event
        frame.Events.OnCharacterDamaged(entity, damage);
      }
    }
  }
}
```

## Character View Integration

The view side is handled by the `CharacterView` component:

```csharp
namespace PlatformShooter2D
{
  using Quantum;
  using UnityEngine;

  public class CharacterView : QuantumEntityViewComponent<CustomViewContext>
  {
    public Transform Body;
    public Animator CharacterAnimator;
    [HideInInspector] public int LookDirection;

    private readonly Vector3 _rightRotation = Vector3.zero;
    private readonly Vector3 _leftRotation = new(0, 180, 0);
    private static readonly int IsFacingRight = Animator.StringToHash("IsFacingRight");

    public override void OnActivate(Frame frame)
    {
      // Set up local player reference if applicable
      PlayerLink playerLink = VerifiedFrame.Get<PlayerLink>(EntityRef);

      if (Game.PlayerIsLocal(playerLink.Player))
      {
        ViewContext.LocalCharacterView = this;
      }
    }

    public override void OnUpdateView()
    {
      if (CharacterAnimator.GetBool(IsFacingRight))
      {
        // Rotate to face right
        Body.localRotation = Quaternion.Euler(_rightRotation);
        LookDirection = 1;
      }
      else
      {
        // Rotate to face left
        Body.localRotation = Quaternion.Euler(_leftRotation);
        LookDirection = -1;
      }
    }
  }
}
```

Key aspects:
1. Extends `QuantumEntityViewComponent` to link with a Quantum entity
2. Identifies local player's character and stores a reference in the view context
3. Updates character's visual direction based on the simulation state

## Character Events

Events facilitate communication between simulation and view:

```qtn
event OnPlayerSelectedCharacter
{
    local player_ref PlayerRef;
}

// Other events in CharacterEvents.qtn
event OnCharacterCreated
{
    entity_ref Character;
}

event OnCharacterRespawn
{
    entity_ref Character;
}

event OnCharacterDied
{
    entity_ref Character;
    entity_ref Killer;
}

event OnCharacterDamaged
{
    entity_ref Character;
    FP Damage;
}
```

## Character Signals

Signals handle inter-system communication within the simulation:

```qtn
// CharacterSignals.qtn
signal OnCharacterRespawn(entity_ref character);
signal OnDamageTaken(entity_ref entity, FP damage, entity_ref source);
```

## Best Practices for Character Implementation

1. **Separate concerns**: Split character functionality across focused components and systems
2. **Use signals for internal communication**: Signals connect systems without creating tight coupling
3. **Use events for view communication**: Events notify the view layer about game state changes
4. **Leverage entity prototypes**: Store character configurations in entity prototypes for easy setup
5. **Handle unsafe pointers carefully**: When using unsafe pointers, always check for valid entities
6. **Use FrameTimers for time-based mechanics**: Respawn and regeneration use FrameTimers for deterministic timing
7. **Keep view logic separate**: Character view code should only observe and visualize state changes

These practices ensure deterministic behavior while keeping the code maintainable and modular.

---

# 03-movement-system.md

# Movement System in Quantum Platform Shooter 2D

This document explains the implementation of the Movement System in the Platform Shooter 2D sample project, focusing on the 2D platformer controls and character movement.

## Movement Components

The movement system relies on several components:

```qtn
// Character.qtn
component MovementData
{
    Boolean IsFacingRight;
}
```

Additionally, the movement system uses built-in Quantum components:
- `Transform2D`: Handles position and rotation
- `KCC2D`: Kinematic Character Controller for 2D movement, manages platformer physics
- `PhysicsCollider2D`: For collision detection

## Movement System Implementation

The `MovementSystem` handles character movement based on player input:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine.Scripting;
  
  [Preserve]
  public unsafe class MovementSystem : SystemMainThreadFilter<MovementSystem.Filter>
  {
    public struct Filter
    {
      public EntityRef Entity;
      public Transform2D* Transform;
      public PlayerLink* PlayerLink;
      public Status* Status;
      public MovementData* MovementData;
      public KCC2D* KCC;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
      // Skip movement for dead characters
      if (filter.Status->IsDead == true)
      {
        return;
      }

      // Get player input
      QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);
      
      // Get KCC configuration
      var config = frame.FindAsset(filter.KCC->Config);
      
      // Apply input to the KCC
      filter.KCC->Input = input;
      
      // Process movement through KCC system
      config.Move(frame, filter.Entity, filter.Transform, filter.KCC);
      
      // Update facing direction
      UpdateIsFacingRight(frame, ref filter, input);
    }

    private void UpdateIsFacingRight(Frame frame, ref Filter filter, QuantumDemoInputPlatformer2D input)
    {
      // Update facing direction based on aim
      filter.MovementData->IsFacingRight = input.AimDirection.X > FP._0;
    }
  }
}
```

Key aspects:
1. Filter selects entities with all required components
2. Retrieve player input for the associated player
3. Pass input to the KCC2D component
4. Call the KCC's Move method to handle the actual movement
5. Update the facing direction based on aim input

## KCC2D Configuration

The KCC2D (Kinematic Character Controller) is configured through an asset:

```csharp
// Simplified KCC2D configuration
public class KCCSettings2D : AssetObject
{
    // Movement parameters
    public FP AccelerationGround;
    public FP AccelerationAir;
    public FP MaxSpeedGround;
    public FP MaxSpeedAir;
    
    // Jump parameters
    public FP JumpVelocity;
    public int MaxJumpCount;
    public FP JumpCooldown;
    
    // Gravity parameters
    public FP GravityFallMultiplier;
    public FP GravityMultiplier;
    
    // Physics parameters
    public FP GroundedTolerance;
    public FP SkinWidth;
    
    // Additional parameters
    public LayerMask GroundLayers;
    public Boolean AllowJumpingWhenSliding;
    public Boolean ResetJumpCountOnGround;
    
    public void Move(Frame frame, EntityRef entity, Transform2D* transform, KCC2D* kcc) {
        // Implementation handles the actual movement logic
        // ...
    }
}
```

## Input Structure

The movement system uses a specialized input structure:

```csharp
// Defined in Input.User.cs
public struct QuantumDemoInputPlatformer2D
{
    public Boolean Left;
    public Boolean Right;
    public Boolean Jump;
    public Boolean Fire;
    public Boolean AltFire;
    public Boolean Use;
    public FPVector2 AimDirection;
}
```

## Input Handling

The input is collected from the Unity side using the `LocalQuantumInputPoller` component:

```csharp
namespace PlatformShooter2D
{
  using Photon.Deterministic;
  using UnityEngine;
  using QuantumMobileInputTools;
  using Quantum;

  public class LocalQuantumInputPoller : QuantumEntityViewComponent<CustomViewContext>
  {
    // ... other fields
    
    public void PollInput(CallbackPollInput callback)
    {
      QuantumDemoInputPlatformer2D input = default;

      if (callback.Game.GetLocalPlayers().Count == 0)
      {
        return;
      }
      
      var control = QuantumLocalInputValuesControl.Instance;

      // Get input from UI controls
      input.Fire = control.GetControlValue(ControlMap.Fire).BoolValue;
      
      // Handle mobile-specific input
#if UNITY_MOBILE || UNITY_ANDROID
      var aimDirection = control.GetControlValue(ControlMap.Aim).Vector2Value;
      input.Fire = (aimDirection.magnitude >= 0.5f);
#endif

      // Get horizontal movement
      var movement = GetMovement();
      input.Left = movement < 0;
      input.Right = movement > 0;

      // Get other inputs
      input.Jump = control.GetControlValue(ControlMap.Jump).BoolValue;
      input.AimDirection = GetAimDirection();
      input.Use = control.GetControlValue(ControlMap.ChangeWeapon).BoolValue;
      input.AltFire = control.GetControlValue(ControlMap.CastSkill).BoolValue;

      // Send input to Quantum
      callback.SetInput(input, DeterministicInputFlags.Repeatable);
    }

    private FP GetMovement()
    {
      var control = QuantumLocalInputValuesControl.Instance;
      FPVector2 directional = control.GetControlValue(ControlMap.Move).Vector2Value.ToFPVector2();
      return directional.X;
    }

    // ... other methods including GetAimDirection()
  }
}
```

The input polling process:
1. Subscribes to Quantum's `CallbackPollInput` event
2. Collects input from Unity's input system
3. Handles platform-specific input differences (mobile vs. desktop)
4. Converts Unity vectors to Quantum's fixed point vectors
5. Sends the input to Quantum with the `Repeatable` flag to ensure determinism

## Character View Integration

The view side updates the character's visual representation based on the movement state:

```csharp
public class CharacterView : QuantumEntityViewComponent<CustomViewContext>
{
  // ... other fields and methods
  
  public override void OnUpdateView()
  {
    // Get the facing direction from animator parameter
    if (CharacterAnimator.GetBool(IsFacingRight))
    {
      // Rotate to face right
      Body.localRotation = Quaternion.Euler(_rightRotation);
      LookDirection = 1;
    }
    else
    {
      // Rotate to face left
      Body.localRotation = Quaternion.Euler(_leftRotation);
      LookDirection = -1;
    }
  }
}
```

## Animation Control

The character's animations are driven by the `CharacterAnimatorObserver`:

```csharp
// Simplified CharacterAnimatorObserver
public class CharacterAnimatorObserver : QuantumEntityViewComponent
{
  public Animator Animator;
  private static readonly int IsGrounded = Animator.StringToHash("IsGrounded");
  private static readonly int IsFacingRight = Animator.StringToHash("IsFacingRight");
  private static readonly int IsMoving = Animator.StringToHash("IsMoving");
  private static readonly int IsJumping = Animator.StringToHash("IsJumping");
  private static readonly int IsDead = Animator.StringToHash("IsDead");

  public override void OnUpdateView()
  {
    // Get components from the simulation
    KCC2D kcc = VerifiedFrame.Get<KCC2D>(EntityRef);
    Status status = VerifiedFrame.Get<Status>(EntityRef);
    MovementData movementData = VerifiedFrame.Get<MovementData>(EntityRef);
    
    // Update animator parameters based on simulation state
    Animator.SetBool(IsGrounded, kcc.Grounded);
    Animator.SetBool(IsFacingRight, movementData.IsFacingRight);
    Animator.SetBool(IsMoving, Mathf.Abs(kcc.Velocity.X.AsFloat) > 0.1f);
    Animator.SetBool(IsJumping, kcc.Velocity.Y.AsFloat > 0);
    Animator.SetBool(IsDead, status.IsDead);
  }
}
```

## Physics Integration

The movement system leverages Quantum's deterministic physics engine:
- The `KCC2D` component handles platformer movement
- `PhysicsCollider2D` defines the collision shape
- Quantum's physics engine ensures deterministic collision detection and response

The KCC2D component handles advanced platformer features:
- Ground detection and slopes
- Jump mechanics including double jump
- Air control
- Variable jump height
- Collision resolution and sliding

## Best Practices for Movement Implementation

1. **Use KCC components**: Leverage Quantum's built-in Kinematic Character Controller
2. **Keep input simple**: Convert complex inputs to simple boolean and vector values
3. **Use fixed point math**: All calculations use Quantum's deterministic fixed point types
4. **Separate movement from visuals**: Keep movement logic in the simulation, visual representation in Unity
5. **Use asset references for configuration**: Store movement parameters in assets for easy tuning
6. **Handle platform-specific inputs**: Account for different input methods (keyboard/mouse vs. touch)
7. **Use filters for efficiency**: Only process entities that have all required components

These practices ensure deterministic movement behavior across all clients while maintaining flexibility and performance.

---

# 04-weapons-and-combat.md

# Weapons and Combat in Quantum Platform Shooter 2D

This document explains the implementation of the Weapons and Combat systems in the Platform Shooter 2D sample project, covering weapons, bullets, and damage handling.

## Weapon Components

The weapon system is built on these components defined in the Quantum DSL:

```qtn
// Weapon.qtn
struct Weapon
{
    Boolean IsRecharging;
    Int32 CurrentAmmo;
    FrameTimer FireRateTimer;
    FrameTimer DelayToStartRechargeTimer;
    FrameTimer RechargeRate;
    FP ChargeTime;
    asset_ref<WeaponData> WeaponData;
}

component WeaponInventory
{
    Int32 CurrentWeaponIndex;
    array<Weapon>[2] Weapons;
}

event OnWeaponShoot
{
    entity_ref Character;
}
```

## Bullet Components

The bullet system is built on these components:

```qtn
// Bullet.qtn
component BulletFields
{
    entity_ref Source;
    FPVector2 Direction;
    asset_ref<BulletData> BulletData;
}

event OnBulletDestroyed
{
    Int32 BulletRefHashCode;
    entity_ref Owner;
    nothashed FPVector2 BulletPosition;
    nothashed FPVector2 BulletDirection;
    asset_ref<BulletData> BulletData;
}
```

## Weapon System Implementation

The `WeaponSystem` handles weapon firing, recharging, and ammunition management:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class WeaponSystem : SystemMainThreadFilter<WeaponSystem.Filter>, ISignalOnCharacterRespawn
  {
    public struct Filter
    {
      public EntityRef Entity;
      public PlayerLink* PlayerLink;
      public Status* Status;
      public WeaponInventory* WeaponInventory;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
      if (filter.Status->IsDead) return;

      UpdateWeaponRecharge(frame, ref filter);
      UpdateWeaponFire(frame, ref filter);
    }

    private void UpdateWeaponRecharge(Frame frame, ref Filter filter)
    {
      var currentWeaponIndex = filter.WeaponInventory->CurrentWeaponIndex;
      var currentWeapon = filter.WeaponInventory->Weapons.GetPointer(currentWeaponIndex);

      var weaponData = frame.FindAsset(currentWeapon->WeaponData);
      if (currentWeapon->DelayToStartRechargeTimer.IsRunning(frame) == false
          && currentWeapon->RechargeRate.IsRunning(frame) == false
          && currentWeapon->CurrentAmmo < weaponData.MaxAmmo)
      {
        currentWeapon->RechargeRate = FrameTimer.FromSeconds(frame, weaponData.RechargeTimer / (FP)weaponData.MaxAmmo);
        currentWeapon->CurrentAmmo++;

        if (currentWeapon->CurrentAmmo == weaponData.MaxAmmo)
        {
          currentWeapon->IsRecharging = false;
        }
      }
    }

    private void UpdateWeaponFire(Frame frame, ref Filter filter)
    {
      var currentWeaponIndex = filter.WeaponInventory->CurrentWeaponIndex;
      var currentWeapon = filter.WeaponInventory->Weapons.GetPointer(currentWeaponIndex);
      var weaponData = frame.FindAsset(currentWeapon->WeaponData);

      QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);
      if (input.Fire)
      {
        // Checks if the weapon is ready to fire
        if (currentWeapon->FireRateTimer.IsRunning(frame) == false 
            && !currentWeapon->IsRecharging 
            && currentWeapon->CurrentAmmo > 0)
        {
          SpawnBullet(frame, filter.Entity, currentWeapon, input.AimDirection);
          currentWeapon->FireRateTimer = FrameTimer.FromSeconds(frame, FP._1 / weaponData.FireRate);
          currentWeapon->ChargeTime = FP._0;
        }
      }
    }

    private static void SpawnBullet(Frame frame, EntityRef character, Weapon* weapon, FPVector2 direction)
    {
      // Reduce ammo count
      weapon->CurrentAmmo -= 1;
      if (weapon->CurrentAmmo == 0)
      {
        weapon->IsRecharging = true;
      }

      var weaponData = frame.FindAsset(weapon->WeaponData);
      var bulletData = frame.FindAsset(weaponData.BulletData);
      var prototypeAsset = frame.FindAsset(bulletData.BulletPrototype);

      // Create the bullet entity
      var bullet = frame.Create(prototypeAsset);
      var bulletFields = frame.Unsafe.GetPointer<BulletFields>(bullet);
      var bulletTransform = frame.Unsafe.GetPointer<Transform2D>(bullet);
      
      // Configure bullet properties
      var characterTransform = frame.Unsafe.GetPointer<Transform2D>(character);
      var fireSpotWorldOffset = WeaponHelper.GetFireSpotWorldOffset(frame.FindAsset(weapon->WeaponData), direction);
      bulletTransform->Position = characterTransform->Position + fireSpotWorldOffset;
      bulletFields->Direction = direction * weaponData.ShootForce;
      bulletFields->Source = character;
      bulletFields->BulletData = bulletData;

      // Restart recharge timer
      weapon->DelayToStartRechargeTimer = FrameTimer.FromSeconds(frame, weaponData.TimeToRecharge);
      
      // Trigger view event
      frame.Events.OnWeaponShoot(character);
    }

    public void OnCharacterRespawn(Frame frame, EntityRef character)
    {
      // Reset weapon state on respawn
      WeaponInventory* weaponInventory = frame.Unsafe.GetPointer<WeaponInventory>(character);

      for (var i = 0; i < weaponInventory->Weapons.Length; i++)
      {
        var weapon = weaponInventory->Weapons.GetPointer(i);
        var weaponData = frame.FindAsset(weapon->WeaponData);

        weapon->IsRecharging = false;
        weapon->CurrentAmmo = weaponData.MaxAmmo;
        weapon->FireRateTimer = FrameTimer.FromFrames(frame, 0);
        weapon->DelayToStartRechargeTimer = FrameTimer.FromFrames(frame, 0);
        weapon->RechargeRate = FrameTimer.FromFrames(frame, 0);
      }
    }
  }
}
```

Key aspects:
1. Filter selects entities with required components (PlayerLink, Status, WeaponInventory)
2. Handles weapon firing based on player input
3. Manages ammo consumption and recharging
4. Spawns bullet entities when firing
5. Resets weapons on character respawn

## Bullet System Implementation

The `BulletSystem` handles bullet movement, collision detection, and impact effects:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class BulletSystem : SystemMainThreadFilter<BulletSystem.Filter>
  {
    public struct Filter
    {
      public EntityRef Entity;
      public Transform2D* Transform;
      public BulletFields* BulletFields;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
      // Check for collisions first
      if (CheckRaycastCollision(frame, ref filter))
      {
        return;
      }
      
      // Destroy bullet if source entity no longer exists
      if (frame.Exists(filter.BulletFields->Source) == false)
      {
        frame.Destroy(filter.Entity);
        return;
      }
      
      // Update bullet position
      UpdateBulletPosition(frame, ref filter);
      
      // Check if bullet has traveled too far
      CheckBulletDistance(frame, ref filter);
    }

    private void CheckBulletDistance(Frame frame, ref Filter filter)
    {
      var bulletFields = filter.BulletFields;
      var sourcePosition = frame.Unsafe.GetPointer<Transform2D>(bulletFields->Source)->Position;
      var distanceSquared = FPVector2.DistanceSquared(filter.Transform->Position, sourcePosition);
      
      var bulletData = frame.FindAsset(bulletFields->BulletData);
      bool bulletIsTooFar = FPMath.Sqrt(distanceSquared) > bulletData.Range;

      if (bulletIsTooFar)
      {
        // Apply bullet action when range is exceeded
        bulletData.BulletAction(frame, filter.Entity, EntityRef.None);
      }
    }

    private void UpdateBulletPosition(Frame frame, ref Filter filter)
    {
      // Move the bullet based on its direction and delta time
      filter.Transform->Position += filter.BulletFields->Direction * frame.DeltaTime;
    }

    private bool CheckRaycastCollision(Frame frame, ref Filter filter)
    {
      var bulletFields = filter.BulletFields;
      var bulletTransform = filter.Transform;
      
      if (bulletFields->Direction.Magnitude <= FP._0)
      {
        return false;
      }

      // Calculate future position for raycast
      var futurePosition = bulletTransform->Position + bulletFields->Direction * frame.DeltaTime;
      var bulletData = frame.FindAsset(bulletFields->BulletData);

      var futurePositionDistance = FPVector2.DistanceSquared(bulletTransform->Position, futurePosition);
      if (futurePositionDistance <= bulletData.CollisionCheckThreshold)
      {
        return false;
      }

      // Perform raycast to check for collisions
      Physics2D.HitCollection hits = frame.Physics2D.LinecastAll(
        bulletTransform->Position, 
        futurePosition, 
        -1, 
        QueryOptions.HitAll | QueryOptions.ComputeDetailedInfo);
        
      for (int i = 0; i < hits.Count; i++)
      {
        var entity = hits[i].Entity;
        // Check for character hit (avoiding source entity and dead characters)
        if (entity != EntityRef.None && frame.Has<Status>(entity) && entity != bulletFields->Source)
        {
          if (frame.Get<Status>(entity).IsDead)
          {
            continue;
          }

          // Update bullet position to hit point
          bulletTransform->Position = hits[i].Point;

          // Apply bullet action on character hit
          bulletData.BulletAction(frame, filter.Entity, entity);
          return true;
        }

        // Check for environment hit
        if (entity == EntityRef.None)
        {
          bulletTransform->Position = hits[i].Point;

          // Apply bullet action on environment hit
          bulletData.BulletAction(frame, filter.Entity, EntityRef.None);
          return true;
        }
      }
      return false;
    }
  }
}
```

Key aspects:
1. Filter selects entities with required components (Transform2D, BulletFields)
2. Updates bullet position based on direction and delta time
3. Uses raycast to detect collisions with characters and environment
4. Checks if bullet has exceeded its maximum range
5. Applies bullet actions through polymorphic behavior

## Bullet Data and Actions

The game uses a polymorphic approach to bullet behavior through the `BulletData` base class:

```csharp
// BulletData.cs (base class)
public abstract class BulletData : AssetObject
{
    public FP Range = 15;
    public FP Damage = 10;
    public FP CollisionCheckThreshold = FP._0_01;
    public AssetRefEntityPrototype BulletPrototype;
    
    // Polymorphic action method
    public abstract void BulletAction(Frame frame, EntityRef bullet, EntityRef targetCharacter);
}

// BulletDataCommon.cs (implementation)
public class BulletDataCommon : BulletData
{
    public override unsafe void BulletAction(Frame frame, EntityRef bullet, EntityRef targetCharacter)
    {
        if (targetCharacter != EntityRef.None)
        {
            // Apply damage to character
            frame.Signals.OnCharacterHit(bullet, targetCharacter, Damage);
        }

        // Trigger view event
        var fields = frame.Get<BulletFields>(bullet);
        var position = frame.Get<Transform2D>(bullet).Position;
        frame.Events.OnBulletDestroyed(
            bullet.GetHashCode(), 
            fields.Source, 
            position, 
            fields.Direction, 
            fields.BulletData);
            
        // Destroy the bullet
        frame.Destroy(bullet);
    }
}

// Other implementations can provide different behaviors
public class BulletDataExplosive : BulletData 
{
    public FP ExplosionRadius = 3;
    
    public override unsafe void BulletAction(Frame frame, EntityRef bullet, EntityRef targetCharacter)
    {
        // Create explosion effect
        // Apply area damage
        // ...
    }
}
```

## Weapon Inventory System

The `WeaponInventorySystem` handles weapon switching:

```csharp
// Simplified WeaponInventorySystem
public unsafe class WeaponInventorySystem : SystemMainThreadFilter<WeaponInventorySystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public PlayerLink* PlayerLink;
        public Status* Status;
        public WeaponInventory* WeaponInventory;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        if (filter.Status->IsDead) return;

        QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);
        if (input.Use)
        {
            // Toggle between weapons (0 and 1)
            filter.WeaponInventory->CurrentWeaponIndex = 
                filter.WeaponInventory->CurrentWeaponIndex == 0 ? 1 : 0;
                
            // Trigger view event
            frame.Events.OnWeaponChanged(filter.Entity, filter.WeaponInventory->CurrentWeaponIndex);
        }
    }
}
```

## Damage System

Damage is handled through signals to promote loose coupling between systems:

```csharp
// In a signal implementation class
public void OnCharacterHit(Frame frame, EntityRef bullet, EntityRef character, FP damage)
{
    // Apply damage to the character
    if (frame.Unsafe.TryGetPointer<Status>(character, out var status))
    {
        // Skip for invincible or dead characters
        if (status->IsDead || status->InvincibleTimer.IsRunning(frame))
        {
            return;
        }

        // Get bullet source
        var bulletFields = frame.Get<BulletFields>(bullet);
        
        // Apply damage
        status->CurrentHealth -= damage;
        status->RegenTimer.Restart(frame, status->StatusData.Asset.RegenStartDelay);
        
        // Check for death
        if (status->CurrentHealth <= FP._0)
        {
            status->IsDead = true;
            status->CurrentHealth = FP._0;
            status->RespawnTimer.Restart(frame, status->StatusData.Asset.RespawnTime);
            
            // Trigger death event
            frame.Events.OnCharacterDied(character, bulletFields.Source);
        }
        else
        {
            // Trigger damage event
            frame.Events.OnCharacterDamaged(character, damage);
        }
    }
}
```

## Weapon View Integration

The Unity-side view code uses event subscriptions to visualize weapon actions:

```csharp
// Simplified WeaponView implementation
public class WeaponView : QuantumEntityViewComponent
{
    // Visual elements
    public ParticleSystem MuzzleFlash;
    public Transform WeaponRoot;
    
    public override void OnActivate(Frame frame)
    {
        // Subscribe to weapon events
        QuantumEvent.Subscribe<EventOnWeaponShoot>(this, OnWeaponShoot);
        QuantumEvent.Subscribe<EventOnWeaponChanged>(this, OnWeaponChanged);
    }
    
    private void OnWeaponShoot(EventOnWeaponShoot e)
    {
        if (e.Character == EntityRef)
        {
            // Play muzzle flash effect
            MuzzleFlash.Play();
            
            // Play sound effect
            SfxController.Instance.PlaySound(SoundType.Shoot);
        }
    }
    
    private void OnWeaponChanged(EventOnWeaponChanged e)
    {
        if (e.Character == EntityRef)
        {
            // Update weapon model
            UpdateWeaponVisuals(e.WeaponIndex);
        }
    }
}
```

## Bullet View Integration

Bullet visualization is handled by dedicated view components:

```csharp
// Simplified BulletFxController
public class BulletFxController : QuantumCallbacks
{
    public GameObject BulletHitPrefab;
    
    public override void OnEnable()
    {
        QuantumEvent.Subscribe<EventOnBulletDestroyed>(this, OnBulletDestroyed);
    }
    
    private void OnBulletDestroyed(EventOnBulletDestroyed e)
    {
        // Create hit effect at bullet position
        var hitEffect = Instantiate(BulletHitPrefab, e.BulletPosition.ToUnityVector3(), Quaternion.identity);
        
        // Set up effect based on bullet type
        ConfigureHitEffect(hitEffect, e.BulletData);
        
        // Play sound effect
        SfxController.Instance.PlaySound(SoundType.BulletHit);
    }
}
```

## Best Practices for Weapons and Combat Implementation

1. **Use polymorphic bullet behavior**: The `BulletData` base class with specific implementations allows for diverse weapon types
2. **Decouple systems with signals**: Damage handling uses signals to avoid tight coupling between bullet and character systems
3. **Use raycasting for collision detection**: Deterministic physics raycasts ensure accurate hit detection
4. **Separate visual effects from simulation**: Events notify the view layer about weapon actions without affecting determinism
5. **Use asset references for configuration**: Weapon and bullet properties are defined in assets for easy tuning
6. **Leverage entity prototypes**: Bullets are spawned from entity prototypes to ensure consistency
7. **Handle resource management**: Ammo and recharge timers use deterministic time tracking with FrameTimer
8. **Use events for significant actions**: Events like OnWeaponShoot and OnBulletDestroyed communicate to the view layer

These practices ensure deterministic combat behavior across all clients while providing visual feedback appropriate to each player's view.

---

# 05-skills-system.md

# Skills System in Quantum Platform Shooter 2D

This document explains the implementation of the Skills System in the Platform Shooter 2D sample project, covering skill casting, activation, and effects.

## Skill Components

The skill system is built on these components defined in the Quantum DSL:

```qtn
// Skill.qtn
component SkillFields
{
    FP TimeToActivate;
    entity_ref Source;
    asset_ref<SkillData> SkillData;
}

component SkillInventory
{
    FrameTimer CastRateTimer;
    asset_ref<SkillInventoryData> SkillInventoryData;
}

event OnSkillCasted
{
    entity_ref Skill;
}

event OnSkillActivated
{
    FPVector2 SkillPosition;
}

event OnSkillHitTarget
{
    FPVector2 SkillPosition;
    Int64 SkillDataId;
    entity_ref Target;
}
```

## Skill Inventory System

The `SkillInventorySystem` handles skill casting based on player input:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine.Scripting;

  [Preserve]
  public unsafe class SkillInventorySystem : SystemMainThreadFilter<SkillInventorySystem.Filter>
  {
    public struct Filter
    {
      public EntityRef Entity;
      public Transform2D* Transform;
      public PlayerLink* PlayerLink;
      public SkillInventory* SkillInventory;
      public Status* Status;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
      if (filter.Status->IsDead)
      {
        return;
      }

      QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);

      // Check if skill cooldown has expired
      if (filter.SkillInventory->CastRateTimer.IsRunning(frame) == false)
      {
        if (input.AltFire.WasPressed)
        {
          CastSkill(frame, ref filter, input.AimDirection);
        }
      }
    }

    private void CastSkill(Frame frame, ref Filter filter, FPVector2 direction)
    {
      // Get skill configuration data
      var skillInventoryData = frame.FindAsset(filter.SkillInventory->SkillInventoryData);
      var skillData = frame.FindAsset(skillInventoryData.SkillData);

      // Create skill entity from prototype
      var skillPrototype = frame.FindAsset(skillData.SkillPrototype);
      var skill = frame.Create(skillPrototype);

      // Configure skill fields
      var skillFields = frame.Unsafe.GetPointer<SkillFields>(skill);
      skillFields->SkillData = skillData;
      skillFields->Source = filter.Entity;
      skillFields->TimeToActivate = skillData.ActivationDelay;

      // Set skill position
      var skillTransform = frame.Unsafe.GetPointer<Transform2D>(skill);
      skillTransform->Position = filter.Transform->Position;
      
      // Apply physics velocity
      var skillPhysics = frame.Unsafe.GetPointer<PhysicsBody2D>(skill);
      skillPhysics->Velocity = direction * skillInventoryData.CastForce;
      
      // Start cooldown timer
      filter.SkillInventory->CastRateTimer = FrameTimer.FromSeconds(frame, skillInventoryData.CastRate);
      
      // Trigger skill cast event
      frame.Events.OnSkillCasted(skill);
    }
  }
}
```

Key aspects:
1. Filter selects entities with required components (Transform2D, PlayerLink, SkillInventory, Status)
2. Handles skill casting based on player input (AltFire button)
3. Creates a skill entity from a prototype
4. Configures the skill with source, position, and activation delay
5. Applies physics velocity based on aim direction
6. Manages cooldown timer between casts
7. Triggers events for view notification

## Skill System

The `SkillSystem` handles skill movement, activation, and effect application:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine.Scripting;
  
  [Preserve]
  public unsafe class SkillSystem : SystemMainThreadFilter<SkillSystem.Filter>
  {
    public struct Filter
    {
      public EntityRef Entity;
      public Transform2D* Transform;
      public SkillFields* SkillFields;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
      // Check if it's time to activate the skill
      if (filter.SkillFields->TimeToActivate <= FP._0)
      {
        DealAreaDamage(frame, ref filter);
        frame.Destroy(filter.Entity);
      }
      else
      {
        // Otherwise, count down activation timer
        filter.SkillFields->TimeToActivate -= frame.DeltaTime;
      }
    }

    private static void DealAreaDamage(Frame frame, ref Filter filter)
    {
      var skillData = frame.FindAsset(frame.Get<SkillFields>(filter.Entity).SkillData);
      
      // Trigger activation event
      frame.Events.OnSkillActivated(filter.Transform->Position);

      // Find all entities in the skill's area of effect
      Physics2D.HitCollection hits =
        frame.Physics2D.OverlapShape(*filter.Transform, skillData.ShapeConfig.CreateShape(frame));
        
      for (int i = 0; i < hits.Count; i++)
      {
        var targetEntity = hits[i].Entity;
        
        // Skip self
        if (targetEntity == filter.Entity)
        {
          continue;
        }

        var skillFields = frame.Get<SkillFields>(filter.Entity);
        
        // Don't hit the caster character
        if (targetEntity == skillFields.Source)
        {
          continue;
        }

        // Only consider character entities for damage
        if (targetEntity == EntityRef.None || frame.Has<Status>(targetEntity) == false)
        {
          continue;
        }

        // Line of sight check to prevent hitting through walls
        var characterPosition = frame.Get<Transform2D>(targetEntity).Position;
        if (LineOfSightHelper.HasLineOfSight(frame, filter.Transform->Position, characterPosition) == false)
        {
          continue;
        }

        // Apply skill effect
        frame.Signals.OnCharacterSkillHit(filter.Entity, targetEntity);
        
        // Trigger hit event for view notification
        frame.Events.OnSkillHitTarget(filter.Transform->Position, skillFields.SkillData.Id.Value, targetEntity);
      }
    }
  }
}
```

Key aspects:
1. Filter selects entities with required components (Transform2D, SkillFields)
2. Counts down the activation timer for the skill
3. When the timer expires, applies area damage
4. Uses Physics2D.OverlapShape to find entities in the skill's area of effect
5. Performs line of sight check to prevent hitting through walls
6. Signals hit targets for damage application
7. Triggers events for view notification

## Skill Data Configuration

Skills are configured through two types of assets:

### SkillInventoryData

This asset configures how a character manages skills:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine;
  
  public class SkillInventoryData : AssetObject
  {
    [Tooltip("Time delay between skill casting.")]
    public FP CastRate;
    
    [Tooltip("The physics force applied to the skill casted.")]
    public FP CastForce;
    
    [Tooltip("The asset reference to the SkillData.")]
    public AssetRef<SkillData> SkillData;
  }
}
```

### SkillData

This asset defines the skill's behavior and effects:

```csharp
namespace Quantum
{
  using Photon.Deterministic;
  using UnityEngine;
  
  public class SkillData : AssetObject
  {
    [Tooltip("Prototype reference to spawn bullet projectiles")]
    public AssetRef<EntityPrototype> SkillPrototype;
    
    [Tooltip("Time delay until the skill activation.")]
    public FP ActivationDelay;
    
    [Tooltip("Damage applied in the target character.")]
    public FP Damage;
    
    [Tooltip("Shape to apply skill affect.")]
    public Shape2DConfig ShapeConfig;
  }
}
```

## Line of Sight Checking

The skills system uses a helper class for line of sight checking:

```csharp
// Simplified LineOfSightHelper
public static class LineOfSightHelper
{
    public static bool HasLineOfSight(Frame frame, FPVector2 from, FPVector2 to)
    {
        // Perform a raycast from source to target
        var hits = frame.Physics2D.LinecastAll(from, to, -1, QueryOptions.HitAll);
        
        for (int i = 0; i < hits.Count; i++)
        {
            var hit = hits[i];
            
            // If we hit a solid object (not a character), line of sight is blocked
            if (hit.Entity == EntityRef.None || !frame.Has<Status>(hit.Entity))
            {
                return false;
            }
        }
        
        return true;
    }
}
```

## Skill Visualization

The skill visualization is handled through event subscriptions:

```csharp
// Simplified SkillView
public class SkillView : QuantumEntityViewComponent
{
    public ParticleSystem CastEffect;
    public ParticleSystem ActivationEffect;
    
    public override void OnEnable()
    {
        QuantumEvent.Subscribe<EventOnSkillCasted>(this, OnSkillCasted);
        QuantumEvent.Subscribe<EventOnSkillActivated>(this, OnSkillActivated);
        QuantumEvent.Subscribe<EventOnSkillHitTarget>(this, OnSkillHitTarget);
    }
    
    private void OnSkillCasted(EventOnSkillCasted e)
    {
        if (e.Skill == EntityRef)
        {
            // Play cast effect
            CastEffect.Play();
            
            // Play sound effect
            SfxController.Instance.PlaySound(SoundType.SkillCast);
        }
    }
    
    private void OnSkillActivated(EventOnSkillActivated e)
    {
        if (transform.position.ToFPVector2().DistanceSquared(e.SkillPosition) < FP._0_50)
        {
            // Play activation effect
            ActivationEffect.Play();
            
            // Play sound effect
            SfxController.Instance.PlaySound(SoundType.SkillActivate);
        }
    }
    
    private void OnSkillHitTarget(EventOnSkillHitTarget e)
    {
        // Handle hit effects
        if (e.Target.IsValid)
        {
            // Create hit effect at target position
            // ...
        }
    }
}
```

## Character Skill Hit Signal

The damage from skills is applied through a signal:

```csharp
// In a signal implementation class (like StatusSystem)
public void OnCharacterSkillHit(Frame frame, EntityRef skill, EntityRef character)
{
    var skillFields = frame.Get<SkillFields>(skill);
    var skillData = frame.FindAsset(skillFields.SkillData);
    
    // Apply damage signal to the character
    frame.Signals.OnDamageTaken(character, skillData.Damage, skillFields.Source);
}
```

## Best Practices for Skills Implementation

1. **Separate casting from activation**: The skill system separates the creation of the skill entity from its activation
2. **Use configurable areas of effect**: Skills use shape configurations to define their area of effect
3. **Perform line of sight checks**: Skills use raycasts to ensure they can't hit through walls
4. **Use cooldown timers**: FrameTimers manage skill cooldowns deterministically
5. **Use asset references for configuration**: Skill properties are defined in assets for easy tuning
6. **Leverage entity prototypes**: Skills are spawned from entity prototypes to ensure consistency
7. **Use events for significant actions**: Events like OnSkillCasted and OnSkillActivated communicate to the view layer
8. **Use signals for internal communication**: Signals like OnCharacterSkillHit connect systems without tight coupling

These practices ensure deterministic skill behavior across all clients while providing visual feedback appropriate to each player's view.

---

# 06-unity-integration.md

# Unity Integration in Quantum Platform Shooter 2D

This document explains how the Platform Shooter 2D sample project integrates Quantum simulation with Unity for visualization and input handling.

## View-Simulation Separation

Quantum's architecture strictly separates the simulation (Quantum) from the view (Unity):

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

This separation ensures:
- Deterministic simulation across all clients
- No Unity-specific code in the simulation
- Clear communication paths between layers

## View Context

The Platform Shooter 2D uses a custom view context to store shared view-side information:

```csharp
namespace PlatformShooter2D
{
  using Quantum;
  using UnityEngine;

  // Custom context available to all EntityViews
  public class CustomViewContext : QuantumContext
  {
    // Reference to the local player's character view
    public CharacterView LocalCharacterView;
    
    // Last known aim direction of the local player
    public Vector2 LocalCharacterLastDirection;
  }
}
```

The view context allows sharing information between different view components, such as providing the local character's view to the camera system.

## Entity View Components

The game uses Quantum's entity view system to connect entities with Unity GameObjects:

### Base QuantumEntityViewComponent

All view components inherit from `QuantumEntityViewComponent<CustomViewContext>`:

```csharp
namespace PlatformShooter2D
{
  using Quantum;
  using UnityEngine;

  public class CharacterView : QuantumEntityViewComponent<CustomViewContext>
  {
    public Transform Body;
    public Animator CharacterAnimator;
    [HideInInspector] public int LookDirection;

    private readonly Vector3 _rightRotation = Vector3.zero;
    private readonly Vector3 _leftRotation = new(0, 180, 0);
    private static readonly int IsFacingRight = Animator.StringToHash("IsFacingRight");

    public override void OnActivate(Frame frame)
    {
      // Set up local player reference if applicable
      PlayerLink playerLink = VerifiedFrame.Get<PlayerLink>(EntityRef);

      if (Game.PlayerIsLocal(playerLink.Player))
      {
        ViewContext.LocalCharacterView = this;
      }
    }

    public override void OnUpdateView()
    {
      if (CharacterAnimator.GetBool(IsFacingRight))
      {
        // Rotate to face right
        Body.localRotation = Quaternion.Euler(_rightRotation);
        LookDirection = 1;
      }
      else
      {
        // Rotate to face left
        Body.localRotation = Quaternion.Euler(_leftRotation);
        LookDirection = -1;
      }
    }
  }
}
```

Key methods in entity view components:
- `OnActivate(Frame frame)`: Called when the entity view is first linked to a Quantum entity
- `OnUpdateView()`: Called every frame to update the visual representation
- `OnEntityDestroyed()`: Called when the linked entity is destroyed

### Component Access

View components can access Quantum component data in these ways:

```csharp
// Safe access with explicit frame reference
Transform2D transform = frame.Get<Transform2D>(EntityRef);

// Safe access using VerifiedFrame (ensures we have a valid frame)
Status status = VerifiedFrame.Get<Status>(EntityRef);

// Unsafe direct pointer access (for performance-critical code)
var kcc = frame.Unsafe.GetPointer<KCC2D>(EntityRef);
```

## Event Subscriptions

View components use Quantum's event system to receive notifications from the simulation:

```csharp
public class WeaponView : QuantumEntityViewComponent
{
    public ParticleSystem MuzzleFlash;
    
    public override void OnEnable()
    {
        // Subscribe to events
        QuantumEvent.Subscribe<EventOnWeaponShoot>(this, OnWeaponShoot);
    }
    
    private void OnWeaponShoot(EventOnWeaponShoot e)
    {
        if (e.Character == EntityRef)
        {
            // Play muzzle flash effect
            MuzzleFlash.Play();
        }
    }
    
    public override void OnDisable()
    {
        // Unsubscribe from events (automatic, but explicit here for clarity)
        QuantumEvent.UnsubscribeListener(this);
    }
}
```

Event subscription options:
- `once`: Event is received only once, then unsubscribed
- `onlyIfActiveAndEnabled`: Only received if the GameObject is active
- `runnerId`: Only for a specific runner instance
- `filter`: Custom filter function for event reception

## Character Animation

The `CharacterAnimatorObserver` bridges Quantum state to Unity's animation system:

```csharp
public class CharacterAnimatorObserver : QuantumEntityViewComponent
{
  public Animator Animator;
  
  private static readonly int IsGrounded = Animator.StringToHash("IsGrounded");
  private static readonly int IsFacingRight = Animator.StringToHash("IsFacingRight");
  private static readonly int IsMoving = Animator.StringToHash("IsMoving");
  private static readonly int IsJumping = Animator.StringToHash("IsJumping");
  private static readonly int IsDead = Animator.StringToHash("IsDead");

  public override void OnUpdateView()
  {
    // Get components from the simulation
    KCC2D kcc = VerifiedFrame.Get<KCC2D>(EntityRef);
    Status status = VerifiedFrame.Get<Status>(EntityRef);
    MovementData movementData = VerifiedFrame.Get<MovementData>(EntityRef);
    
    // Update animator parameters based on simulation state
    Animator.SetBool(IsGrounded, kcc.Grounded);
    Animator.SetBool(IsFacingRight, movementData.IsFacingRight);
    Animator.SetBool(IsMoving, Mathf.Abs(kcc.Velocity.X.AsFloat) > 0.1f);
    Animator.SetBool(IsJumping, kcc.Velocity.Y.AsFloat > 0);
    Animator.SetBool(IsDead, status.IsDead);
  }
}
```

## Camera Integration

The `LocalPlayerCameraFollow` component controls the camera to follow the local player:

```csharp
public class LocalPlayerCameraFollow : MonoBehaviour
{
    public float SmoothTime = 0.3f;
    
    private Transform _target;
    private Vector3 _velocity = Vector3.zero;
    
    void Update()
    {
        if (CustomViewContext.Instance?.LocalCharacterView != null)
        {
            if (_target == null)
            {
                _target = CustomViewContext.Instance.LocalCharacterView.transform;
            }
            
            if (_target != null)
            {
                // Follow the target with smooth damping
                Vector3 targetPosition = new Vector3(
                    _target.position.x, 
                    _target.position.y, 
                    transform.position.z);
                    
                transform.position = Vector3.SmoothDamp(
                    transform.position, 
                    targetPosition, 
                    ref _velocity, 
                    SmoothTime);
            }
        }
    }
}
```

## Visual Effects

Visual effects are triggered through event handlers:

```csharp
// Simplified BulletFxController
public class BulletFxController : QuantumCallbacks
{
    public GameObject BulletHitPrefab;
    
    public override void OnEnable()
    {
        QuantumEvent.Subscribe<EventOnBulletDestroyed>(this, OnBulletDestroyed);
    }
    
    private void OnBulletDestroyed(EventOnBulletDestroyed e)
    {
        // Create hit effect at bullet position
        var hitEffect = Instantiate(
            BulletHitPrefab, 
            e.BulletPosition.ToUnityVector3(), 
            Quaternion.identity);
            
        // Destroy after delay
        Destroy(hitEffect, 2f);
    }
}
```

## Audio Integration

Audio is handled through a centralized `SfxController`:

```csharp
// Simplified SfxController
public class SfxController : MonoBehaviour
{
    public static SfxController Instance { get; private set; }
    
    public AudioClip ShootSound;
    public AudioClip HitSound;
    public AudioClip JumpSound;
    
    private AudioSource _audioSource;
    
    void Awake()
    {
        Instance = this;
        _audioSource = GetComponent<AudioSource>();
    }
    
    public void PlaySound(SoundType type)
    {
        switch (type)
        {
            case SoundType.Shoot:
                _audioSource.PlayOneShot(ShootSound);
                break;
            case SoundType.Hit:
                _audioSource.PlayOneShot(HitSound);
                break;
            case SoundType.Jump:
                _audioSource.PlayOneShot(JumpSound);
                break;
        }
    }
}
```

Character-specific audio is handled by dedicated components:

```csharp
public class CharacterAudioController : QuantumEntityViewComponent
{
    public AudioSource AudioSource;
    
    public AudioClip DamageSound;
    public AudioClip DeathSound;
    
    public override void OnEnable()
    {
        QuantumEvent.Subscribe<EventOnCharacterDamaged>(this, OnCharacterDamaged);
        QuantumEvent.Subscribe<EventOnCharacterDied>(this, OnCharacterDied);
    }
    
    private void OnCharacterDamaged(EventOnCharacterDamaged e)
    {
        if (e.Character == EntityRef)
        {
            AudioSource.PlayOneShot(DamageSound);
        }
    }
    
    private void OnCharacterDied(EventOnCharacterDied e)
    {
        if (e.Character == EntityRef)
        {
            AudioSource.PlayOneShot(DeathSound);
        }
    }
}
```

## UI Integration

The game includes various UI components that observe Quantum state:

### Player UI

```csharp
public class PlayerUI : QuantumEntityViewComponent
{
    public Image HealthBar;
    
    public override void OnUpdateView()
    {
        if (EntityRef.IsValid)
        {
            Status status = VerifiedFrame.Get<Status>(EntityRef);
            var statusData = frame.FindAsset(status.StatusData);
            
            // Update health bar
            float healthPercent = status.CurrentHealth.AsFloat / statusData.MaxHealth.AsFloat;
            HealthBar.fillAmount = healthPercent;
        }
    }
}
```

### Weapon HUD

```csharp
public class ChangeWeaponHud : QuantumEntityViewComponent
{
    public Image[] WeaponIcons;
    
    public override void OnEnable()
    {
        QuantumEvent.Subscribe<EventOnWeaponChanged>(this, OnWeaponChanged);
    }
    
    private void OnWeaponChanged(EventOnWeaponChanged e)
    {
        if (e.Character == EntityRef)
        {
            // Update weapon icons
            for (int i = 0; i < WeaponIcons.Length; i++)
            {
                WeaponIcons[i].color = (i == e.WeaponIndex) ? Color.white : Color.gray;
            }
        }
    }
}
```

## Entity Prototype Integration

Entity prototypes are defined in Unity and used by Quantum:

1. Create a GameObject with desired components
2. Add `QuantumEntityPrototype` component
3. Configure Quantum components in the Inspector
4. Create a prefab from the GameObject
5. Reference the prefab in simulation code

The `EntityPrototypeLinker` automatically links Unity prefabs to Quantum entities during instantiation.

## Unity Utils Extensions

The project includes utility extension methods to convert between Unity and Quantum types:

```csharp
// Extension methods
public static class QuantumUnityExtensions
{
    public static Vector2 ToUnityVector2(this FPVector2 vector)
    {
        return new Vector2(vector.X.AsFloat, vector.Y.AsFloat);
    }
    
    public static Vector3 ToUnityVector3(this FPVector2 vector)
    {
        return new Vector3(vector.X.AsFloat, vector.Y.AsFloat, 0);
    }
    
    public static FPVector2 ToFPVector2(this Vector2 vector)
    {
        return new FPVector2(FP.FromFloat_UNSAFE(vector.x), FP.FromFloat_UNSAFE(vector.y));
    }
    
    public static FPVector2 ToFPVector2(this Vector3 vector)
    {
        return new FPVector2(FP.FromFloat_UNSAFE(vector.x), FP.FromFloat_UNSAFE(vector.y));
    }
}
```

## Best Practices for Unity Integration

1. **Keep simulation and view separate**: Never reference Unity types in simulation code
2. **Use events for communication**: Use events to notify the view about simulation changes
3. **Use entity view components**: Extend `QuantumEntityViewComponent` for entity-linked behavior
4. **Centralize common functionality**: Use a custom ViewContext to share information
5. **Use safe access patterns**: Use `VerifiedFrame` for component access
6. **Handle entity destruction**: Properly clean up resources in `OnEntityDestroyed`
7. **Pool frequently created objects**: Use object pooling for effects and projectiles
8. **Use extension methods**: Create extensions for type conversion between Unity and Quantum
9. **Access components efficiently**: Use appropriate access patterns based on performance requirements
10. **Use entity prototype linker**: Automatically link Unity prefabs to Quantum entities

These practices ensure clean separation between simulation and view while maintaining visual fidelity and performance.

---

# 07-input-handling.md

# Input Handling in Quantum Platform Shooter 2D

This document explains how player input is captured in Unity, transformed into Quantum's deterministic format, and processed in the simulation.

## Input Definition

The Platform Shooter 2D game uses a custom input structure defined in `Input.User.cs`:

```csharp
// Partial extension of the Quantum.Input struct
public partial struct QuantumDemoInputPlatformer2D
{
    public Boolean Left;
    public Boolean Right;
    public Boolean Jump;
    public Boolean Fire;
    public Boolean AltFire;
    public Boolean Use;
    public FPVector2 AimDirection;
}
```

This structure is automatically generated from the DSL definition and extended with additional methods.

## Input Polling in Unity

The input is captured on the Unity side through the `LocalQuantumInputPoller` component:

```csharp
namespace PlatformShooter2D
{
  using Photon.Deterministic;
  using UnityEngine;
  using QuantumMobileInputTools;
  using Quantum;

  public class LocalQuantumInputPoller : QuantumEntityViewComponent<CustomViewContext>
  {
    public float AimAssist = 20;
    public float AimSpeed = 2;
    private Vector2 _lastPlayerDirection;

    public override void OnInitialize()
    {
      _lastPlayerDirection = Vector2.left;
    }

    public override void OnActivate(Frame frame)
    {
      var playerLink = VerifiedFrame.Get<PlayerLink>(EntityRef);

      // Only subscribe to input polling for local player
      if (Game.PlayerIsLocal(playerLink.Player))
      {
        QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback),
          onlyIfActiveAndEnabled: true);
      }
    }

    public override void OnUpdateView()
    {
      var playerLink = VerifiedFrame.Get<PlayerLink>(EntityRef);
      if (Game.PlayerIsLocal(playerLink.Player))
      {
        // Store aim direction in view context for other view components
        ViewContext.LocalCharacterLastDirection = GetAimDirection();
      }
    }

    public void PollInput(CallbackPollInput callback)
    {
      QuantumDemoInputPlatformer2D input = default;

      if (callback.Game.GetLocalPlayers().Count == 0)
      {
        return;
      }
      
      var control = QuantumLocalInputValuesControl.Instance;

      // Get fire input
      input.Fire = control.GetControlValue(ControlMap.Fire).BoolValue;

      // Handle mobile-specific input
#if UNITY_MOBILE || UNITY_ANDROID
      var aimDirection = control.GetControlValue(ControlMap.Aim).Vector2Value;
      input.Fire = (aimDirection.magnitude >= 0.5f);
#endif

      // Get movement input
      var movement = GetMovement();
      input.Left = movement < 0;
      input.Right = movement > 0;

      // Get other inputs
      input.Jump = control.GetControlValue(ControlMap.Jump).BoolValue;
      input.AimDirection = GetAimDirection();
      input.Use = control.GetControlValue(ControlMap.ChangeWeapon).BoolValue;
      input.AltFire = control.GetControlValue(ControlMap.CastSkill).BoolValue;

      // Send input to Quantum with the Repeatable flag for determinism
      callback.SetInput(input, DeterministicInputFlags.Repeatable);
    }

    private FP GetMovement()
    {
      var control = QuantumLocalInputValuesControl.Instance;
      FPVector2 directional = control.GetControlValue(ControlMap.Move).Vector2Value.ToFPVector2();
      return directional.X;
    }

    private FPVector2 GetAimDirection()
    {
      var control = QuantumLocalInputValuesControl.Instance;
      Vector2 direction = Vector2.zero;
      Frame frame = PredictedFrame;
      var isMobile = false;

#if !UNITY_STANDALONE && !UNITY_WEBGL
      isMobile = true;
#endif
      if (frame.TryGet<Transform2D>(EntityRef, out var characterTransform))
      {
        if (isMobile)
        {
          // Mobile aim handling with touch controls
          Vector2 directional = control.GetControlValue(ControlMap.Aim).Vector2Value;
          var controlDir = new Vector2(directional.x, directional.y);
          if (controlDir.sqrMagnitude > 0.1f)
          {
            direction = controlDir;
          }
          else if (Mathf.Abs(GetMovement().AsFloat) > 0.1f)
          {
            direction = new Vector2(GetMovement().AsFloat, 0);
          }
          else
          {
            direction = _lastPlayerDirection;
          }

          _lastPlayerDirection = direction;

          // Apply aim assist
          var minorAngle = AimAssist;
          var position = frame.Get<Transform2D>(EntityRef).Position;
          var targetDirection = position - characterTransform.Position;

          if (Vector2.Angle(direction, targetDirection.ToUnityVector2()) <= minorAngle)
          {
            direction = Vector2.Lerp(direction, targetDirection.ToUnityVector2(), Time.deltaTime * AimSpeed);
          }
        }
        else
        {
          // Desktop aim handling with mouse
          var localCharacterPosition = characterTransform.Position.ToUnityVector3();
          var localCharacterScreenPosition = Camera.main.WorldToScreenPoint(localCharacterPosition);
          var mousePos = control.GetControlValue(ControlMap.MousePosition).Vector2Value;
          if (!Application.isFocused)
          {
            mousePos = Vector2.zero;
          }

          direction = mousePos - new Vector2(localCharacterScreenPosition.x, localCharacterScreenPosition.y);
        }

        // Convert to Quantum's fixed point format
        return new FPVector2(FP.FromFloat_UNSAFE(direction.x), FP.FromFloat_UNSAFE(direction.y));
      }

      return FPVector2.Zero;
    }
  }
}
```

Key aspects:
1. Subscribes to Quantum's `CallbackPollInput` for the local player only
2. Collects input from Unity's input system via the `QuantumLocalInputValuesControl`
3. Handles platform-specific input differences (mobile vs. desktop)
4. Processes aim direction based on touch or mouse input
5. Provides aim assist for mobile players
6. Converts Unity vectors to Quantum's fixed point vectors
7. Sets input with the `Repeatable` flag to ensure determinism

## Input Controls Mapping

The game uses a control mapping system to abstract input sources:

```csharp
// Control mapping constants
public static class ControlMap
{
    public const string Jump = "Jump";
    public const string Fire = "Fire";
    public const string CastSkill = "CastSkill";
    public const string ChangeWeapon = "ChangeWeapon";
    public const string Move = "Move";
    public const string Aim = "Aim";
    public const string MousePosition = "MousePosition";
}
```

This allows for different input implementations while maintaining the same control interface.

## Standalone Input Implementation

For desktop platforms, the game uses a standalone input implementation:

```csharp
public class LocalGameplayInputStandalone : MonoBehaviour, ILocalInputValuesProvider
{
    // Input values cache
    private Dictionary<string, ControlValue> _controls = new Dictionary<string, ControlValue>();
    
    private void Awake()
    {
        // Register as input provider
        QuantumLocalInputValuesControl.Instance.RegisterProvider(this);
    }
    
    private void OnDestroy()
    {
        // Unregister on destruction
        QuantumLocalInputValuesControl.Instance.UnregisterProvider(this);
    }
    
    private void Update()
    {
        // Poll keyboard/mouse input
        _controls[ControlMap.Jump] = new ControlValue(Input.GetKey(KeyCode.Space));
        _controls[ControlMap.Fire] = new ControlValue(Input.GetMouseButton(0));
        _controls[ControlMap.CastSkill] = new ControlValue(Input.GetMouseButton(1));
        _controls[ControlMap.ChangeWeapon] = new ControlValue(Input.GetKeyDown(KeyCode.Q));
        
        // Movement
        float horizontal = Input.GetAxisRaw("Horizontal");
        _controls[ControlMap.Move] = new ControlValue(new Vector2(horizontal, 0));
        
        // Mouse position
        _controls[ControlMap.MousePosition] = new ControlValue(Input.mousePosition);
    }
    
    public ControlValue GetControlValue(string control)
    {
        if (_controls.TryGetValue(control, out var value))
        {
            return value;
        }
        return default;
    }
}
```

## Mobile Input Implementation

For mobile platforms, the game uses touch-based input with virtual controls:

```csharp
// Mobile input handling (simplified)
public class MobileInputHandler : MonoBehaviour, ILocalInputValuesProvider
{
    public Joystick MovementJoystick;
    public Joystick AimJoystick;
    public Button JumpButton;
    public Button FireButton;
    public Button SkillButton;
    public Button WeaponButton;
    
    private Dictionary<string, ControlValue> _controls = new Dictionary<string, ControlValue>();
    
    private void Awake()
    {
        QuantumLocalInputValuesControl.Instance.RegisterProvider(this);
    }
    
    private void Update()
    {
        // Update controls from UI elements
        _controls[ControlMap.Jump] = new ControlValue(JumpButton.IsPressed);
        _controls[ControlMap.Fire] = new ControlValue(FireButton.IsPressed);
        _controls[ControlMap.CastSkill] = new ControlValue(SkillButton.IsPressed);
        _controls[ControlMap.ChangeWeapon] = new ControlValue(WeaponButton.IsPressed);
        
        // Joystick values
        _controls[ControlMap.Move] = new ControlValue(new Vector2(MovementJoystick.Horizontal, 0));
        _controls[ControlMap.Aim] = new ControlValue(new Vector2(AimJoystick.Horizontal, AimJoystick.Vertical));
    }
    
    public ControlValue GetControlValue(string control)
    {
        if (_controls.TryGetValue(control, out var value))
        {
            return value;
        }
        return default;
    }
}
```

## Input Abstraction Layer

The `QuantumLocalInputValuesControl` serves as an abstraction layer between input providers and consumers:

```csharp
// Simplified QuantumLocalInputValuesControl
public class QuantumLocalInputValuesControl : MonoBehaviour
{
    public static QuantumLocalInputValuesControl Instance { get; private set; }
    
    private List<ILocalInputValuesProvider> _providers = new List<ILocalInputValuesProvider>();
    
    private void Awake()
    {
        Instance = this;
    }
    
    public void RegisterProvider(ILocalInputValuesProvider provider)
    {
        _providers.Add(provider);
    }
    
    public void UnregisterProvider(ILocalInputValuesProvider provider)
    {
        _providers.Remove(provider);
    }
    
    public ControlValue GetControlValue(string control)
    {
        // Query all providers, prioritizing the last registered one
        for (int i = _providers.Count - 1; i >= 0; i--)
        {
            var value = _providers[i].GetControlValue(control);
            if (value.IsSet)
            {
                return value;
            }
        }
        return default;
    }
}

public interface ILocalInputValuesProvider
{
    ControlValue GetControlValue(string control);
}

public struct ControlValue
{
    public bool IsSet;
    public bool BoolValue;
    public Vector2 Vector2Value;
    
    // Constructors for different value types
    public ControlValue(bool value) { ... }
    public ControlValue(Vector2 value) { ... }
}
```

This abstraction allows:
- Multiple input providers (keyboard/mouse, touch, gamepad, etc.)
- Seamless switching between different input methods
- Consistent interface for input consumers

## Simulation Input Processing

On the simulation side, the input is processed by various systems:

### Movement System

```csharp
public override void Update(Frame frame, ref Filter filter)
{
  if (filter.Status->IsDead) return;

  // Get player input
  QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);
  
  // Apply input to KCC
  var config = frame.FindAsset(filter.KCC->Config);
  filter.KCC->Input = input;
  config.Move(frame, filter.Entity, filter.Transform, filter.KCC);
  
  // Update facing direction
  filter.MovementData->IsFacingRight = input.AimDirection.X > FP._0;
}
```

### Weapon System

```csharp
private void UpdateWeaponFire(Frame frame, ref Filter filter)
{
  // Get current weapon data
  var currentWeaponIndex = filter.WeaponInventory->CurrentWeaponIndex;
  var currentWeapon = filter.WeaponInventory->Weapons.GetPointer(currentWeaponIndex);
  var weaponData = frame.FindAsset(currentWeapon->WeaponData);

  // Get player input
  QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);
  
  // Process fire input
  if (input.Fire)
  {
    // Check if weapon can fire
    if (currentWeapon->FireRateTimer.IsRunning(frame) == false 
        && !currentWeapon->IsRecharging 
        && currentWeapon->CurrentAmmo > 0)
    {
      SpawnBullet(frame, filter.Entity, currentWeapon, input.AimDirection);
      currentWeapon->FireRateTimer = FrameTimer.FromSeconds(frame, FP._1 / weaponData.FireRate);
    }
  }
}
```

### Weapon Inventory System

```csharp
public override void Update(Frame frame, ref Filter filter)
{
  if (filter.Status->IsDead) return;

  // Get player input
  QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);
  
  // Process weapon switch input
  if (input.Use.WasPressed)
  {
    // Toggle between weapons
    filter.WeaponInventory->CurrentWeaponIndex = 
      filter.WeaponInventory->CurrentWeaponIndex == 0 ? 1 : 0;
    
    // Trigger event
    frame.Events.OnWeaponChanged(filter.Entity, filter.WeaponInventory->CurrentWeaponIndex);
  }
}
```

### Skill Inventory System

```csharp
public override void Update(Frame frame, ref Filter filter)
{
  if (filter.Status->IsDead) return;

  // Get player input
  QuantumDemoInputPlatformer2D input = *frame.GetPlayerInput(filter.PlayerLink->Player);

  // Process skill cast input
  if (filter.SkillInventory->CastRateTimer.IsRunning(frame) == false)
  {
    if (input.AltFire.WasPressed)
    {
      CastSkill(frame, ref filter, input.AimDirection);
    }
  }
}
```

## Button Extension Methods

The game adds button state checking extension methods to the input struct:

```csharp
public partial struct QuantumDemoInputPlatformer2D
{
    // Button state properties
    public bool WasPressed => IsDown && !WasDown;
    public bool WasReleased => !IsDown && WasDown;
    
    private bool IsDown;
    private bool WasDown;
    
    // Update button state
    public void Update(Frame frame, bool value)
    {
        WasDown = IsDown;
        IsDown = value;
    }
}
```

These extension methods allow detecting button press and release events.

## Best Practices for Input Handling

1. **Use abstraction layers**: Separate input providers from input consumers
2. **Handle platform differences**: Provide different input implementations for different platforms
3. **Convert to fixed point early**: Convert Unity floating-point values to Quantum fixed point as soon as possible
4. **Use deterministic flags**: Always set input with the `Repeatable` flag
5. **Process input in systems**: Keep input processing in Quantum systems, not in Unity scripts
6. **Add convenience methods**: Add extension methods to make input state checking easier
7. **Use button state properties**: Add properties like `WasPressed` and `WasReleased` for event detection
8. **Keep input structures small**: Minimize the size of input structures for bandwidth efficiency
9. **Provide aim assistance**: Help mobile players with aim assistance without breaking determinism
10. **Update local state**: Store input state in the view context for access by other view components

These practices ensure consistent, deterministic input handling across all platforms while providing a good user experience.

---

# README.md

# Quantum Platform Shooter 2D Documentation

This repository contains comprehensive documentation for the Quantum Platform Shooter 2D sample project. The documentation is designed to help you understand how to implement multiplayer games using Photon Quantum's deterministic networking framework.

## Overview

Quantum Platform Shooter 2D is a sample game built with Photon Quantum 3.0.2 that demonstrates a multiplayer 2D platformer shooter. It showcases key features of Quantum, including:

- Deterministic ECS (Entity Component System) architecture
- Predict/rollback networking
- Character movement and combat
- Weapons and skills systems
- Unity integration for visualization

The documentation in this repository explains in detail how these systems are implemented, with code examples and best practices.

## Documentation Structure

1. [**Project Overview**](00-project-overview.md) - High-level overview of the Quantum Platform Shooter 2D project
2. [**Game State Definition**](01-game-state-definition.md) - How game state is defined using Quantum DSL
3. [**Character System**](02-character-system.md) - Character implementation and management
4. [**Movement System**](03-movement-system.md) - Character movement and physics
5. [**Weapons and Combat**](04-weapons-and-combat.md) - Weapons, bullets, and damage systems
6. [**Skills System**](05-skills-system.md) - Character abilities implementation
7. [**Unity Integration**](06-unity-integration.md) - Connecting Unity view to Quantum simulation
8. [**Input Handling**](07-input-handling.md) - Input collection and processing

Each document is structured to provide clear explanations and accurate code examples that can be used as reference when implementing similar systems.

## How to Use This Documentation

- **For learning Quantum**: Start with the Project Overview, then read through the documents in order to understand the fundamental concepts of Quantum.
- **For implementing specific features**: Go directly to the relevant system document.
- **For reference**: Use the code examples as templates for your own implementation.

The code examples are extracted directly from the Quantum Platform Shooter 2D sample project and represent actual working implementations of the various systems.

## Additional Resources

For more information about Photon Quantum:

- [Quantum Documentation](https://doc.photonengine.com/quantum/current/getting-started/quantum-intro)
- [Photon Quantum Discord](https://discord.gg/photonengine)
- [Quantum Forum](https://forum.photonengine.com/categories/quantum-showcase-discussion)

## LLM Optimization Note

These notes have been specifically crafted for optimal use by Large Language Models. The documentation:

- Uses precise code examples with accurate syntax
- Provides contextual explanations of code functionality
- Follows consistent formatting and structure
- Includes best practices and implementation patterns
- Provides clear descriptions of interfaces between systems

This makes the documentation ideal for generating accurate code when queried about Quantum implementation patterns.

---

# 01_Overview.md

# Quantum Racer 2.5D Overview

## Game Description
Quantum Racer 2.5D is a multiplayer racing game built with Photon Quantum, supporting up to 99 players. It's a retro-style racer with arcade physics, featuring:

- Different vehicle types with unique stats
- Varied surface types with different driving conditions
- AI drivers with adjustable difficulty
- Full race loop: Ready check, Countdown, Race, Scoreboard
- Lap tracking, timing, and position systems
- Joystick support

## Technical Information
- Built with Unity 2021.3.37f1
- Platforms: PC (Windows/Mac)
- Version: 3.0.2 (Build 604)
- Release Date: March 19, 2025

## Key Controls
- **W**: Accelerate
- **S**: Brake
- **A/D**: Turn left/right
- **J/L**: Lean sideways
- **I/K**: Lean front/back during flights

## Project Structure
The game is organized into several key directories:

1. **Assets/QuantumUser/Simulation**: Core game logic
   - **Racer**: Main game-specific code
   - **Modifiers**: Special effects like boosters, jumps, etc.

2. **Assets/QuantumUser/View**: Client-side visualization
   - **Racer**: UI and camera systems
   
3. **Assets/QuantumUser/Resources**: Game configurations
   - **Racer/CarSpecs**: Vehicle configurations
   - **Racer/Modifiers**: Effect assets
   - **Racer/Bots**: AI configuration

4. **Assets/Photon**: Quantum networking framework

## Core Game Concepts
- **Racer Component**: Main vehicle component
- **RaceManager**: Singleton managing race state
- **Bot System**: AI implementation
- **Checkpoint System**: Track progress tracking
- **Modifiers**: Special effects on the track

## Multiplayer Features
- Full online multiplayer using Photon Quantum
- Support for up to 99 players
- Deterministic physics simulation
- Bot players to fill empty slots

## Game Highlights
- Arcade racing physics
- Different vehicles with unique stats
- Lap and time tracking
- Position in race grid
- Various modifiers affecting gameplay

---

# 02_QTN_Schema.md

# Quantum Typescripts (.qtn) Schema Reference

Quantum Racer uses QTN (Quantum TypeScript) files to define the core structure of the game's entities, components, and systems. This file documents the schema used in Racer.qtn.

## Player Limit Configuration
```csharp
#pragma max_players 99
```

## Core Components

### RacerPlayerLink Component
Links a player reference to an entity.
```csharp
component RacerPlayerLink {
    PlayerRef Player;
}
```

### Racer Component
The main component for racer vehicles.
```csharp
component Racer {
    AssetRef<RacerConfig> Config;
    [ExcludeFromPrototype] AssetRef<RacerModifier> Modifier;
    [ExcludeFromPrototype] Int16 Lean;
    [ExcludeFromPrototype] FP Pitch;
    [ExcludeFromPrototype] FP VerticalSpeed;
    [ExcludeFromPrototype] Modifier ModifierValues;
    [ExcludeFromPrototype] EntityRef NextCheckpoint;
    [ExcludeFromPrototype] FPVector2 LastCheckpointPosition;
    [ExcludeFromPrototype] LapData LapData;
    FP Energy;
    [ExcludeFromPrototype] FP ResetTimer;
    EntityRef CarAhead;
    EntityRef CarBehind;
    int Position;
    bool Finished;
}
```

### Bot Component
AI bot configuration and state.
```csharp
component Bot {
    EntityRef RacingLineCheckpoint;
    EntityRef RacingLineReset;
    AssetRef<BotConfig> Config;
    Input Input;
    int NickIndex;
    FP StartTimer;
    int RacelineIndex;
    int RacelineIndexReset;
    AssetRef<CheckpointData> Raceline;
    FP MaxSpeed;
    FP CurrentSpeed;
}
```

### Checkpoint Component
Track checkpoints that racers must pass through.
```csharp
component Checkpoint {
    EntityRef Next;
    EntityRef RacelineRef;
    Boolean Finish;
    [ExcludeFromPrototype] FPVector2 DirectionToNext;
}
```

### RaceManager Singleton
Manages the overall race state.
```csharp
singleton component RaceManager {
    EntityRef StartCheckpoint;
    EntityRef StartBotCheckpoint;
    FP RaceTime;
    RaceState State;
    list<EntityRef> Vehicles;
    int FinishedCount;
}
```

## Input Definition
```csharp
input {
    button RacerAccel;
    button RacerBrake;
    button RacerLeft;
    button RacerRight;
    button RacerLeanLeft;
    button RacerLeanRight;
    button RacerPitchUp;
    button RacerPitchDown;
}
```

## Structs

### Modifier
Modifies racer characteristics.
```csharp
struct Modifier {
    FP AccelMultiplier;
    FP FrictionMultiplier;
    FP MaxSpeedMultiplier;
}
```

### LapData
Tracks lap and checkpoint information.
```csharp
struct LapData {
    [ExcludeFromPrototype] Int32 Laps;
    [ExcludeFromPrototype] Int32 Checkpoints;
    [ExcludeFromPrototype] FP TotalDistance;
    [ExcludeFromPrototype] FP LapTime;
    [ExcludeFromPrototype] FP LastLapTime;
    [ExcludeFromPrototype] FP BestLap;
}
```

### RacelineEntry
Racing line guidance for AI bots.
```csharp
[Serializable]
struct RacelineEntry {
    FP DesiredSpeed;
    FPVector2 Position;
}
```

## Enums

### RaceState
Represents the current state of the race.
```csharp
enum RaceState {
    Start, Running, Finished
}
```

## Signals
Trigger special gameplay events.
```csharp
signal Spawn(PlayerRef player, BotConfig botConfig);
signal Respawn(EntityRef entity, Racer* racer, bool revertPosition);
signal Reset(EntityRef entity, Racer* racer);
```

## Events
Notify about specific gameplay events.
```csharp
event Bump {
    EntityRef Entity;
    Int32 Static;
}

event VehicleBump {
    EntityRef Entity;
    EntityRef Other;
    nothashed FPVector2 Point;
}

event Jump {
    EntityRef Entity;
}

event JumpLand {
    EntityRef Entity;
}

event Death {
    EntityRef Entity;
}

event Respawn {
    EntityRef Entity;
}
```

## Usage Notes
- `[ExcludeFromPrototype]` fields are runtime values not serialized in entity prototypes
- `FP` represents fixed-point numbers for deterministic physics
- `EntityRef` is a reference to another entity in the game
- `AssetRef<T>` is a reference to a configured asset

---

# 03_RacerSystem.md

# Racer System Implementation

The `RacerSystem` is the core system that handles vehicle physics, collision responses, and checkpoint tracking in Quantum Racer 2.5D.

## System Definition

```csharp
[Preserve]
public unsafe class RacerSystem : SystemMainThreadFilter<RacerSystem.Filter>,
    ISignalOnPlayerAdded,
    ISignalOnTriggerEnter2D,
    ISignalOnTriggerExit2D,
    ISignalOnCollisionEnter2D,
    ISignalRespawn,
    ISignalReset
{
    // Implementation details follow
}
```

## Key Interfaces
- `SystemMainThreadFilter<RacerSystem.Filter>`: Base class for systems with a filter
- `ISignalOnPlayerAdded`: Handles player joins
- `ISignalOnTriggerEnter2D`: Detects entering trigger areas (checkpoints, modifiers)
- `ISignalOnTriggerExit2D`: Detects leaving trigger areas
- `ISignalOnCollisionEnter2D`: Handles collisions with other vehicles or walls
- `ISignalRespawn`: Handles vehicle respawning
- `ISignalReset`: Handles vehicle resetting

## Component Filter
```csharp
public struct Filter
{
    public EntityRef Entity;
    public Transform2D* Transform;
    public Transform2DVertical* Vertical;
    public PhysicsBody2D* Body;
    public Racer* Vehicle;
}
```

## Key Methods

### Update
Processes vehicle updates each frame, calling the vehicle config's update method.
```csharp
public override void Update(Frame f, ref Filter filter)
{
    if (f.Unsafe.TryGetPointerSingleton<RaceManager>(out var manager))
    {
        if (manager->State != RaceState.Running) return;
    }

    var config = f.FindAsset(filter.Vehicle->Config);
    config.UpdateRacer(f, ref filter);
}
```

### OnPlayerAdded
Spawns a vehicle when a player joins.
```csharp
public void OnPlayerAdded(Frame f, PlayerRef player, bool firstTime)
{
    if (firstTime == false) return;
    f.Signals.Spawn(player, null);
}
```

### OnTriggerEnter2D
Handles vehicle entering trigger areas like modifiers or death zones.
```csharp
public void OnTriggerEnter2D(Frame f, TriggerInfo2D info)
{
    if (info.IsStatic && f.Unsafe.TryGetPointer(info.Entity, out Racer* racer))
    {
        if (racer->Finished) return;
        var modifier = f.FindAsset<RacerModifier>(info.StaticData.Asset);
        if (modifier != null)
        {
            racer->Modifier = modifier.Guid;
        }
        else
        {
            // death
            Death(f, info.Entity, racer);
        }
    }
}
```

### OnTriggerExit2D
Removes modifier effects when leaving a trigger area.
```csharp
public void OnTriggerExit2D(Frame f, ExitInfo2D info)
{
    if (info.IsStatic && f.Unsafe.TryGetPointer(info.Entity, out Racer* racer))
    {
        racer->Modifier = default;
    }
}
```

### OnCollisionEnter2D
Handles collisions with walls or other vehicles.
```csharp
public void OnCollisionEnter2D(Frame f, CollisionInfo2D info)
{
    // Skip if we can't get the physics body or racer component
    if (!f.Unsafe.TryGetPointer(info.Entity, out PhysicsBody2D* body) ||
        !f.Unsafe.TryGetPointer<Racer>(info.Entity, out var racer))
    {
        return;
    }

    if (racer->Finished) return;

    var raceConfig = f.FindAsset(f.RuntimeConfig.RaceConfig);
    
    // Wall collision handling
    if (info.IsStatic)
    {
        body->Velocity *= raceConfig.WallBumpSpeedFactor;
        body->AddLinearImpulse(info.ContactNormal * raceConfig.WallBumpForce);
        f.Events.Bump(info.Entity, 0);

        racer->Energy -= raceConfig.WallBumpDamage;
        if (racer->Energy <= FP._0)
        {
            Death(f, info.Entity, racer);
        }
    }
    // Other vehicle collision
    else if (f.Has<Racer>(info.Other))
    {
        body->AddLinearImpulse(info.ContactNormal * raceConfig.CarBumpForce);
        f.Events.VehicleBump(info.Entity, info.Other, info.ContactPoints.Average);
    }
}
```

### Respawn
Respawns a vehicle after death, resets its energy and position.
```csharp
public void Respawn(Frame f, EntityRef entity, Racer* racer, QBoolean revertPosition)
{
    var config = f.FindAsset(racer->Config);
    racer->Energy = config.InitialEnergy;
    racer->ResetTimer = default;

    if (revertPosition && f.Unsafe.TryGetPointer<Transform2D>(entity, out var transform))
    {
        transform->Teleport(f, racer->LastCheckpointPosition);

        if (f.TryGet<Transform2D>(racer->NextCheckpoint, out var checkpointTransform))
        {
            var direction = checkpointTransform.Position - transform->Position;
            var radians = FPVector2.RadiansSignedSkipNormalize(direction.Normalized, FPVector2.Up);
            transform->Rotation = -radians;

            if (f.Unsafe.TryGetPointer<Bot>(entity, out var bot))
            {
                bot->RacingLineCheckpoint = bot->RacingLineReset;
                bot->RacelineIndex = bot->RacelineIndexReset;
            }
        }
    }

    if (f.Unsafe.TryGetPointer<PhysicsBody2D>(entity, out var body))
    {
        body->IsKinematic = false;
    }

    f.Events.Respawn(entity);
}
```

### Reset
Resets a vehicle's physics state.
```csharp
public void Reset(Frame f, EntityRef entity, Racer* racer)
{
    if (f.Unsafe.TryGetPointer<Transform2DVertical>(entity, out var vertical))
    {
        vertical->Position = default;
    }

    racer->Lean = default;
    racer->Pitch = default;
    racer->VerticalSpeed = default;
    racer->Modifier = default;
    
    if (f.Unsafe.TryGetPointer<PhysicsBody2D>(entity, out var body))
    {
        body->Velocity = default;
        body->AngularVelocity = default;
        body->IsKinematic = true;
    }
}
```

### Death (Private Helper)
Handles vehicle death, setting up respawn.
```csharp
private static void Death(Frame f, EntityRef entity, Racer* racer)
{
    var raceConfig = f.FindAsset(f.RuntimeConfig.RaceConfig);
    racer->Energy = default;
    racer->ResetTimer = raceConfig.RespawnCooldown;
    f.Signals.Reset(entity, racer);
    f.Events.Death(entity);
}
```

## Implementation Notes
- Uses unsafe C# pointer access for performance
- Leverages Quantum's deterministic physics
- Handles race state checks before processing updates
- Provides response to collisions based on configuration parameters
- Sets up vehicle states based on RacerConfig assets

---

# 04_RacerConfig.md

# Racer Config Implementation

The `RacerConfig` class defines the physics and handling characteristics of vehicles in Quantum Racer 2.5D. Each vehicle type has its own configuration with unique handling characteristics.

## Class Definition

```csharp
public unsafe class RacerConfig : AssetObject
{
    // Properties and methods...
}
```

## Physics Properties

```csharp
// Vehicle identification
public string CarName = "car_name";

// Basic movement parameters
public FP Acceleration = 15;
public FP Mass = 2;
public FP Braking = 5;
public FP GroundDrag = 1;
public FP LeanDrag = FP._0_10;
public FP MaxSpeed = 10;

// Steering and handling
public FPAnimationCurve SteeringResponseCurve;
public FP RotationSpeed = 10;
public FP LeanBuff = 5;

// Vertical movement parameters
public FP PitchSpeed = 30;
public FP MaxPitch = 15;
public FP BaseGravity = -10;
public FP PitchGravityBoost = 10;

// Physics tuning
public FP FrictionCoeficient = 2;
public FP ThrottleFrictionReductor = FP._0_50;

// Gameplay parameters
public FP InitialEnergy = 10;
public FP CheckpointDetectionDistance = 12;
```

## Key Methods

### ClampRacerSpeed
Limits the vehicle's speed to the configured maximum speed.

```csharp
public void ClampRacerSpeed(Frame f, ref RacerVelocityClampSystem.Filter filter)
{
    var maxSpeed = MaxSpeed * filter.Vehicle->ModifierValues.MaxSpeedMultiplier;

    var speed = filter.Body->Velocity.Magnitude;
    if (speed > maxSpeed)
    {
        filter.Body->Velocity = filter.Body->Velocity.Normalized * maxSpeed;
    }
}
```

### UpdateRacer
The main update method called each frame to process vehicle movement and state.

```csharp
public void UpdateRacer(Frame f, ref RacerSystem.Filter filter)
{
    // Get input from player or bot
    Input input = default;
    if (f.TryGet(filter.Entity, out RacerPlayerLink link) && link.Player.IsValid)
    {
        input = *f.GetPlayerInput(link.Player);
    }

    if (f.TryGet(filter.Entity, out Bot bot))
    {
        input = bot.Input;
    }

    // Update checkpoint progress
    UpdateCheckpoints(f, ref filter);

    // Disable control if finished
    if (filter.Vehicle->Finished) input = default;

    // Reset modifier values
    filter.Vehicle->ModifierValues.Reset();

    // Handle respawn timer if dead
    if (filter.Vehicle->Energy <= 0)
    {
        if (filter.Vehicle->ResetTimer <= 0)
        {
            f.Signals.Respawn(filter.Entity, filter.Vehicle, true);
        }
        else
        {
            filter.Vehicle->ResetTimer -= f.DeltaTime;
            filter.Body->Velocity = default;
            filter.Body->AngularVelocity = default;
            return;
        }
    }
    
    // Apply modifiers
    var modifier = f.FindAsset(filter.Vehicle->Modifier);
    if (modifier != null)
    {
        modifier.UpdateRacer(f, ref filter);
    }

    // Process vehicle physics
    UpdateSteering(f, ref filter, ref input);
    UpdateFriction(ref filter, ref input);
    
    // Handle jumping/aerial state
    if (UpdateVertical(f, ref filter, ref input)) return;
    
    // Apply acceleration
    UpdateAccel(f, ref filter, ref input);
}
```

## Helper Methods

### UpdateCheckpoints
Tracks checkpoint progress and lap information.

```csharp
private void UpdateCheckpoints(Frame frame, ref RacerSystem.Filter filter)
{
    if (frame.Unsafe.TryGetPointer<Transform2D>(filter.Vehicle->NextCheckpoint, out var checkpointTransform))
    {
        // Update lap timer
        filter.Vehicle->LapData.LapTime += frame.DeltaTime;
        
        // Check if we've reached the checkpoint
        var distance = (checkpointTransform->Position - filter.Transform->Position).Magnitude;
        if (distance < CheckpointDetectionDistance && frame.TryGet<Checkpoint>(filter.Vehicle->NextCheckpoint, out var checkpoint))
        {
            // Move to next checkpoint
            filter.Vehicle->NextCheckpoint = checkpoint.Next;
            filter.Vehicle->LastCheckpointPosition = checkpointTransform->Position;
            filter.Vehicle->LapData.Checkpoints++;

            // Update bot raceline reference
            if (frame.Unsafe.TryGetPointer<Bot>(filter.Entity, out var bot))
            {
                bot->RacingLineReset = checkpoint.RacelineRef;
                bot->RacelineIndexReset = bot->RacelineIndex;
            }
            
            // Handle finish line
            if (checkpoint.Finish)
            {
                // Process lap completion
                filter.Vehicle->LapData.Checkpoints = 0;
                filter.Vehicle->LapData.Laps++;
                filter.Vehicle->LapData.LastLapTime = filter.Vehicle->LapData.LapTime;
                
                // Update best lap time
                if (filter.Vehicle->LapData.LapTime < filter.Vehicle->LapData.BestLap ||
                    filter.Vehicle->LapData.BestLap == 0) 
                    filter.Vehicle->LapData.BestLap = filter.Vehicle->LapData.LapTime;
                
                filter.Vehicle->LapData.LapTime = 0;

                // Update bot raceline for next lap
                if (bot != null)
                {
                    var spawnConfig = frame.FindAsset<SpawnConfig>(frame.Map.UserAsset);
                    var racelineToPick = frame.Global->RngSession.Next(0, spawnConfig.AvailableRacelines.Length);
                    bot->Raceline = spawnConfig.AvailableRacelines[racelineToPick];
                }
                
                // Check if race is finished
                var raceConfig = frame.FindAsset(frame.RuntimeConfig.RaceConfig);
                if (filter.Vehicle->LapData.Laps == raceConfig.Laps)
                {
                    filter.Vehicle->Finished = true;
                    if (frame.Unsafe.TryGetPointerSingleton<RaceManager>(out var manager))
                    {
                        manager->FinishedCount++;
                    }
                }
            }
        }

        // Update total distance for position calculation
        filter.Vehicle->LapData.TotalDistance = filter.Vehicle->LapData.Laps * 100;
        filter.Vehicle->LapData.TotalDistance += filter.Vehicle->LapData.Checkpoints * 10;

        var traveled = (filter.Transform->Position - filter.Vehicle->LastCheckpointPosition);
        var forwardCheckpointDirection = (checkpointTransform->Position - filter.Vehicle->LastCheckpointPosition).Normalized;
        var distanceElapsed = FPVector2.Dot(traveled, forwardCheckpointDirection);
        filter.Vehicle->LapData.TotalDistance += distanceElapsed / 1000;
    }
}
```

### UpdatePitch
Handles the pitch control for aerial movement.

```csharp
private void UpdatePitch(Frame frame, ref RacerSystem.Filter filter, ref Input input)
{
    FP pitchSpeed = 0;
    if (input.RacerPitchUp) pitchSpeed -= PitchSpeed;
    if (input.RacerPitchDown) pitchSpeed += PitchSpeed;

    filter.Vehicle->Pitch += pitchSpeed * frame.DeltaTime;
    filter.Vehicle->Pitch = FPMath.Clamp(filter.Vehicle->Pitch, -MaxPitch, MaxPitch);
}
```

### UpdateVertical
Handles jumping and aerial movement.

```csharp
private bool UpdateVertical(Frame frame, ref RacerSystem.Filter filter, ref Input input)
{
    var pitchFactor = -filter.Vehicle->Pitch / MaxPitch;
    var gravity = BaseGravity;
    var wasJumping = filter.Vertical->Position != 0;
    
    if (filter.Vehicle->VerticalSpeed < 0)
        gravity += pitchFactor * PitchGravityBoost;

    filter.Vertical->Position += filter.Vehicle->VerticalSpeed * frame.DeltaTime;
    filter.Vehicle->VerticalSpeed += gravity * frame.DeltaTime;
    
    if (filter.Vertical->Position <= 0)
    {
        filter.Vertical->Position = 0;
        filter.Vehicle->VerticalSpeed = 0;
    }

    if (filter.Vertical->Position != 0)
    {
        UpdatePitch(frame, ref filter, ref input);
        return true;
    }
    else if (wasJumping)
    {
        frame.Events.JumpLand(filter.Entity);
    }

    filter.Vehicle->Pitch = 0;
    return false;
}
```

### UpdateFriction
Applies lateral friction to limit drifting.

```csharp
private void UpdateFriction(ref RacerSystem.Filter filter, ref Input input)
{
    var dot = FPVector2.Dot(filter.Transform->Right, filter.Body->Velocity);
    var friction = FrictionCoeficient * filter.Vehicle->ModifierValues.FrictionMultiplier * filter.Body->Mass;
    filter.Body->AddForce(filter.Transform->Right * -dot * friction);
}
```

### UpdateSteering
Handles steering controls and lean mechanics.

```csharp
private void UpdateSteering(Frame frame, ref RacerSystem.Filter filter, ref Input input)
{
    FP rotationSpeed = 0;
    if (input.RacerLeft.IsDown) rotationSpeed += RotationSpeed;
    if (input.RacerRight.IsDown) rotationSpeed -= RotationSpeed;

    filter.Vehicle->Lean = 0;
    if (input.RacerLeanLeft.IsDown)
    {
        rotationSpeed += LeanBuff;
        filter.Vehicle->Lean += 1;
    }

    if (input.RacerLeanRight.IsDown)
    {
        rotationSpeed -= LeanBuff;
        filter.Vehicle->Lean -= 1;
    }

    // Calibrate with speed (animation curve)
    var mult = SteeringResponseCurve.Evaluate(filter.Body->Velocity.Magnitude);

    if (input.RacerAccel.IsDown) mult *= ThrottleFrictionReductor;
    
    rotationSpeed *= mult;

    filter.Transform->Rotation += rotationSpeed * frame.DeltaTime * FP.Deg2Rad;
}
```

### UpdateAccel
Handles acceleration, braking, and drag.

```csharp
private void UpdateAccel(Frame frame, ref RacerSystem.Filter filter, ref Input input)
{
    var accel = Acceleration * filter.Vehicle->ModifierValues.AccelMultiplier * filter.Body->Mass;
    if (input.RacerAccel.IsDown) filter.Body->AddForce(filter.Transform->Up * accel);
    if (input.RacerBrake.IsDown) filter.Body->AddForce(filter.Transform->Down * Braking);
    
    var drag = GroundDrag;
    if (input.RacerLeanLeft.IsDown || input.RacerLeanRight.IsDown) drag += LeanDrag;

    filter.Body->Velocity -= filter.Body->Velocity * drag * frame.DeltaTime;
}
```

## Implementation Notes
- Uses fixed-point math (FP) for deterministic physics
- Leverages animation curves to tune steering response by speed
- Modular approach with separate physics handling methods
- Supports various vehicle stats through configuration values
- Handles vertical movement for jumps and pitch control

---

# 05_BotSystem.md

# Bot System Implementation

The `BotSystem` and `BotConfig` classes handle the AI implementation for computer-controlled racers in Quantum Racer 2.5D.

## Bot System

The `BotSystem` class is a simple wrapper that processes all bot entities each frame:

```csharp
[Preserve]
public unsafe class BotSystem : SystemMainThreadFilter<BotSystem.Filter> {
    public override void Update(Frame f, ref Filter filter)
    {
        var botConfig = f.FindAsset(filter.Bot->Config);
        botConfig.UpdateBot(f, ref filter);
    }

    public struct Filter {
        public EntityRef Entity;
        public Transform2D* Transform;
        public Bot* Bot;
        public PhysicsBody2D* Body;
        public Racer* Racer;
    }
}
```

## Bot Config

The `BotConfig` class contains the AI behavior parameters and update logic for bot-controlled vehicles.

### Configuration Parameters

```csharp
public FP MaxSpeed = 10;
public FPVector2 OverlapRelativeOffset = new FPVector2(0, 0);
public FP OverlapDistance = 3;
public FP CheckpointDetectionDistance = 5;
public FP CheckpointDetectionDotThreshold = FP._0_50;
public bool Debug = true;
public FP RacelineSpeedFactor = 1;
public FP LookAhead = FP._0_50;
public bool SmoothLookAhead = false;
public bool UseDirectionToNext;
public FP RadiansSlowdownThreshold = FP.PiOver4;
public FP SlowdownFactor = FP._0_50;
```

### UpdateBot Method

The main AI update method that handles bot driving behavior:

```csharp
public void UpdateBot(Frame f, ref BotSystem.Filter filter)
{
    // Reset input
    filter.Bot->Input = default;

    // Delay start if needed
    if (filter.Bot->StartTimer > 0)
    {
        filter.Bot->StartTimer -= f.DeltaTime;
        return;
    }

    // Get raceline and checkpoint data
    GetCheckpointData(f, ref filter, out var checkpointPosition, out var referencePosition, 
                      out var directionToFollow, out var maxSpeed, out var directionToNext, 
                      out var referenceSpeed);
    
    var directionToCheckpoint = (checkpointPosition - filter.Transform->Position);

    // Check if we've reached the checkpoint
    var normalizedDirection = directionToCheckpoint.Normalized;
    var passed = FPVector2.Dot(-normalizedDirection, directionToNext) > CheckpointDetectionDotThreshold;
    if (directionToCheckpoint.Magnitude < CheckpointDetectionDistance || passed)
    {
        UpdateCheckpoint(f, ref filter);
        return;
    }

    // Avoid cars ahead
    if (filter.Racer->CarAhead.IsValid)
    {
        var other = f.Get<Transform2D>(filter.Racer->CarAhead);
        var offset = OverlapRelativeOffset;
        if (filter.Entity.Index % 2 == 0) offset.X = -offset.X;
        var desired = other.TransformPoint(offset);
        var avoidDirection = (desired - filter.Transform->Position);
        if (avoidDirection.Magnitude < OverlapDistance) directionToFollow += avoidDirection.Normalized;
    }

    // Calculate steering
    var radians = FPVector2.RadiansSignedSkipNormalize(directionToFollow, filter.Transform->Up);
    var absRadians = FPMath.Abs(radians);

    // Slow down for sharp turns
    if (absRadians > RadiansSlowdownThreshold)
        maxSpeed *= SlowdownFactor;
    
    filter.Bot->MaxSpeed = maxSpeed;
    filter.Bot->CurrentSpeed = filter.Body->Velocity.Magnitude;
    
    // Accelerate or brake based on speed
    if (filter.Body->Velocity.Magnitude < maxSpeed) 
        filter.Bot->Input.RacerAccel.Update(f.Number, true);
    else 
        filter.Bot->Input.RacerBrake = true;
    
    // Visualize debug information
    if (Debug)
    {
        ColorRGBA speedColor = ColorRGBA.Green;
        if (maxSpeed / referenceSpeed <= FP._0_50)
        {
            speedColor = ColorRGBA.Red;
        }
        else if (maxSpeed / referenceSpeed <= FP._0_75)
        {
            speedColor = ColorRGBA.Yellow;
        }
        Draw.Ray(filter.Transform->Position, directionToFollow.Normalized * 5, speedColor);
        Draw.Circle(referencePosition, FP._0_25, ColorRGBA.Red);
    }
    
    // Apply steering if needed
    if (absRadians < FP.EN2) return;

    if (radians < 0) filter.Bot->Input.RacerLeft.Update(f.Number, true);
    if (radians > 0) filter.Bot->Input.RacerRight.Update(f.Number, true);
}
```

### Helper Methods

#### UpdateCheckpoint
Moves to the next raceline checkpoint:

```csharp
private void UpdateCheckpoint(Frame f, ref BotSystem.Filter filter)
{
    var raceline = f.FindAsset(filter.Bot->Raceline);
    filter.Bot->RacelineIndex = (filter.Bot->RacelineIndex + 1) % raceline.Raceline.Count;
}
```

#### GetCheckpointData
Gets the current racing line data for the bot to follow:

```csharp
private void GetCheckpointData(Frame f, ref BotSystem.Filter filter, 
                              out FPVector2 checkpointPosition, 
                              out FPVector2 referencePosition, 
                              out FPVector2 directionToFollow, 
                              out FP maxSpeed,
                              out FPVector2 directionToNext, 
                              out FP referenceSpeed)
{
    // Get raceline data
    var raceline = f.FindAsset(filter.Bot->Raceline);
    var currentCheckpointData = raceline.Raceline[filter.Bot->RacelineIndex];
    checkpointPosition = currentCheckpointData.Position;
    referencePosition = checkpointPosition;

    // Set speed based on configuration
    maxSpeed = MaxSpeed;
    if (currentCheckpointData.DesiredSpeed < maxSpeed)
        maxSpeed = currentCheckpointData.DesiredSpeed;

    referenceSpeed = maxSpeed;

    // Adjust speed based on vehicle handling
    var carConfig = f.FindAsset(filter.Racer->Config);
    FP handlingFactor = 1;
    if (carConfig.RotationSpeed < raceline.ReferenceRotationSpeed)
    {
        handlingFactor = carConfig.RotationSpeed / raceline.ReferenceRotationSpeed;
    }
    // if my car handles worse, be conservative when turning
    maxSpeed *= handlingFactor * RacelineSpeedFactor;

    // Calculate direction to next checkpoint
    var nextIndex = (filter.Bot->RacelineIndex + 1) % raceline.Raceline.Count;
    var next = raceline.Raceline[nextIndex];
    directionToNext = (next.Position - checkpointPosition).Normalized;

    // Look ahead based on current speed
    var distanceBetweenMarks = raceline.DistanceBetweenMarks;
    var readAheadCount = ((filter.Bot->CurrentSpeed * LookAhead) / distanceBetweenMarks);
    if (readAheadCount > 0)
    {
        var actualIndex = (filter.Bot->RacelineIndex + readAheadCount.AsInt) % raceline.Raceline.Count;
        var readAheadPosition = raceline.Raceline[actualIndex].Position;
        if (SmoothLookAhead)
        {
            var distance = (filter.Transform->Position - checkpointPosition).Magnitude;
            var alpha = 1 - distance / distanceBetweenMarks;
            if (readAheadCount > 0)
            {
                alpha += readAheadCount;
                alpha /= (readAheadCount + 1);
            }
            referencePosition = FPVector2.Lerp(checkpointPosition, readAheadPosition, alpha);
        }
        else
        {
            referencePosition = readAheadPosition;
        }
    }

    // Calculate steering direction
    directionToFollow = (referencePosition - filter.Transform->Position).Normalized;
    if (UseDirectionToNext)
        directionToFollow = directionToNext;
}
```

## Racing Line System

Bots navigate using predefined racing lines, which are sequences of points with recommended speeds:

```csharp
[Serializable]
struct RacelineEntry {
    FP DesiredSpeed;
    FPVector2 Position;
}
```

The `CheckpointData` asset contains these racing lines, which bots follow for optimal paths around the track.

## Bot Difficulty Levels

Bots can have different difficulty levels through configuration, controlled via the `BotConfigContainer`:

```csharp
public class BotConfigContainer : AssetObject
{
    public AssetRef<BotConfig>[] Configs;
    public string[] Nicknames;
    public int MaxBots = 10;
    public FP BotStartInterval = 0;
    
    public void GetBot(Frame frame, PlayerRef player, out AssetRef<EntityPrototype> prototype)
    {
        var data = frame.GetPlayerData(player);
        var carIndex = 0;
        if (data != null)
        {
            carIndex = data.PlayerCar;
        }
        else
        {
            carIndex = frame.Global->RngSession.Next(0, 4);
        }
        
        var spawnConfig = frame.FindAsset<SpawnConfig>(frame.Map.UserAsset);
        prototype = spawnConfig.AvailableCars[carIndex];
    }
}
```

## Implementation Notes
- Uses racing lines for optimal pathfinding
- Includes obstacle avoidance for other vehicles
- Adjusts speed based on turn sharpness
- Supports look-ahead behavior for anticipating future turns
- Scales difficulty based on handling capabilities
- Uses debug visualization to help with tuning

---

# 06_RaceManagerSystem.md

# Race Manager System Implementation

The `RaceManagerSystem` controls the overall race loop, spawning vehicles, tracking race state, and determining vehicle positions.

## Class Definition

```csharp
[Preserve]
public unsafe class RaceManagerSystem : SystemMainThread, ISignalSpawn
{
    private Comparer _comparer = new Comparer();
    
    // Implementation follows...
}
```

## Race States

The race goes through several states defined in the `RaceState` enum:
```csharp
enum RaceState {
    Start,    // Pre-race countdown
    Running,  // Race in progress
    Finished  // Race completed
}
```

## Key Methods

### OnInit

Initializes the race when a game session starts:

```csharp
public override void OnInit(Frame f)
{
    // Create race manager singleton
    f.GetOrAddSingleton<RaceManager>();
    var raceConfig = f.FindAsset(f.RuntimeConfig.RaceConfig);
    
    if (f.Unsafe.TryGetPointerSingleton<RaceManager>(out var manager))
    {
        // Initialize vehicle list
        manager->Vehicles = f.AllocateList<EntityRef>();
        // Set countdown timer
        manager->RaceTime = raceConfig.StartCountDown;
        // Set initial state
        manager->State = RaceState.Start;
    }

    // Calculate directions between checkpoints
    var checkpoints = f.Filter<Transform2D, Checkpoint>();
    while (checkpoints.NextUnsafe(out var e, out var t, out var c))
    {
        var otherTransform = f.Get<Transform2D>(c->Next);
        c->DirectionToNext = (otherTransform.Position - t->Position).Normalized;
        Log.Info("computed direction: " + c->DirectionToNext);
    }
}
```

### Update

The main update method that handles the race state progression:

```csharp
public override void Update(Frame f)
{
    if (f.Unsafe.TryGetPointerSingleton<RaceManager>(out var manager))
    {
        switch (manager->State)
        {
            case RaceState.Start:
                // Countdown timer
                manager->RaceTime -= f.DeltaTime;
                if (manager->RaceTime <= 0)
                {
                    // Start race
                    manager->State = RaceState.Running;
                    manager->RaceTime = 0;
                    // Fill empty slots with bots
                    FillWithBots(f);
                }
                break;
                
            case RaceState.Running:
                // Update race timer
                manager->RaceTime += f.DeltaTime;
                
                // Sort vehicles by position
                var vehicles = f.ResolveList(manager->Vehicles);
                _comparer.SetFrame(f);
                vehicles.Sort(_comparer);
                
                // Update position info for each vehicle
                int count = 0;
                foreach (var car in vehicles)
                {
                    if (f.Unsafe.TryGetPointer<Racer>(car, out var racer))
                    {
                        racer->Position = count + 1;
                        
                        // Track cars ahead and behind
                        if (count > 0) 
                            racer->CarAhead = vehicles[count - 1];
                        else 
                            racer->CarAhead = default;
                            
                        if (count < vehicles.Count - 1) 
                            racer->CarBehind = vehicles[count + 1];
                        else 
                            racer->CarBehind = default;
                            
                        count++;
                    }
                }
                break;
                
            case RaceState.Finished:
                // Race is over, no active updates
                break;
        }
    }
}
```

### FillWithBots

Adds bot players to empty player slots in the race:

```csharp
private void FillWithBots(Frame frame)
{
    var botsConfig = frame.FindAsset(frame.RuntimeConfig.Bots);
    int count = 0;
    
    // Check each player slot
    for (int i = 0; i < frame.PlayerCount; i++)
    {
        // If slot is empty
        if ((frame.GetPlayerInputFlags(i) & DeterministicInputFlags.PlayerNotPresent) != 0)
        {
            count++;
            // Select bot difficulty based on count
            var botConfigRef = botsConfig.Configs[0];
            if (count > botsConfig.MaxBots / 3)
                botConfigRef = botsConfig.Configs[1];
            if (count > (2 * botsConfig.MaxBots) / 3)
                botConfigRef = botsConfig.Configs[2];
                
            // Spawn bot in this slot
            frame.Signals.Spawn(i, frame.FindAsset(botConfigRef));
        }

        // Stop if we've reached max bots
        if (count >= botsConfig.MaxBots) break;
    }
}
```

### ISignalSpawn.Spawn

Handles spawning a new player or bot vehicle:

```csharp
public void Spawn(Frame f, PlayerRef player, BotConfig botConfig)
{
    // Get bot configuration
    var bots = f.FindAsset<BotConfigContainer>(f.RuntimeConfig.Bots);
    bots.GetBot(f, player, out var prototype);
    
    // If not a bot, use player's selected vehicle
    if (botConfig == null)
    {
        var data = f.GetPlayerData(player);
        prototype = data.PlayerAvatar;
    }

    // Create the entity from prototype
    var e = f.Create(prototype);

    // If it's a bot, add the Bot component
    if (botConfig != null)
    {
        f.Add<Bot>(e);
    }

    // Link to player
    if (f.Unsafe.TryGetPointer(e, out RacerPlayerLink* link))
    {
        link->Player = player;
    }

    // Position the vehicle in the starting grid
    if (f.Unsafe.TryGetPointer(e, out Transform2D* t))
    {
        var spawnConfig = f.FindAsset<SpawnConfig>(f.Map.UserAsset);
        var playersPerRow = spawnConfig.PlayersPerRow;
        
        // Calculate grid position
        FP x = (player % playersPerRow) * spawnConfig.SpawnLateralSeparation;
        FP y = (player / playersPerRow) * spawnConfig.SpawnForwardSeparation;
        y += spawnConfig.SpawnForwardSeparation * (player % playersPerRow) / playersPerRow;

        t->Position = spawnConfig.BaseSpawn + new FPVector2(x, y);
        
        // Setup racer component
        if (f.Unsafe.TryGetPointer(e, out Racer* racer))
        {
            var config = f.FindAsset(racer->Config);
            
            if (f.Unsafe.TryGetPointerSingleton<RaceManager>(out var manager))
            {
                // Set initial checkpoint
                racer->NextCheckpoint = manager->StartCheckpoint;
                racer->LastCheckpointPosition = t->Position;
                racer->Energy = config.InitialEnergy;
                
                // Add to vehicle list
                var vehicles = f.ResolveList(manager->Vehicles);
                vehicles.Add(e);

                // Configure bot-specific properties
                if (f.Unsafe.TryGetPointer<Bot>(e, out var bot))
                {
                    bot->Config = botConfig;
                    bot->NickIndex = player;
                    bot->RacingLineCheckpoint = manager->StartBotCheckpoint;
                    bot->RacingLineReset = manager->StartBotCheckpoint;
                    bot->StartTimer = bots.BotStartInterval * player;
                    
                    // Select a random raceline
                    var racelineToPick = f.Global->RngSession.Next(0, spawnConfig.AvailableRacelines.Length);
                    bot->Raceline = spawnConfig.AvailableRacelines[racelineToPick];
                }
            }

            // Set physics body mass
            if (f.Unsafe.TryGetPointer(e, out PhysicsBody2D* body))
            {
                body->Mass = config.Mass;
            }
        }
    }
}
```

## Position Calculation and Sorting

The `Comparer` private class handles sorting vehicles by their race position:

```csharp
private class Comparer : IComparer<EntityRef>
{
    private Frame _frame;

    public void SetFrame(Frame f)
    {
        _frame = f;
    }

    public int Compare(EntityRef x, EntityRef y)
    {
        if (_frame.Unsafe.TryGetPointer<Racer>(x, out var xRacer) &&
            _frame.Unsafe.TryGetPointer<Racer>(y, out var yRacer))
        {
            // Calculate total distance for sorting
            var xTotal = xRacer->LapData.TotalDistance != 0 ? xRacer->LapData.TotalDistance : -x.Index;
            var yTotal = yRacer->LapData.TotalDistance != 0 ? yRacer->LapData.TotalDistance : -y.Index;
            
            // Add a bonus to finished vehicles
            if (xRacer->Finished) xTotal += (_frame.PlayerCount - xRacer->Position) * 100;
            if (yRacer->Finished) yTotal += (_frame.PlayerCount - yRacer->Position) * 100;
            
            // Compare distances
            if (xTotal > yTotal)
                return -1;
            if (xTotal < yTotal)
                return 1;
        }
        return 0;
    }
}
```

## Implementation Notes

- Uses a state machine for race progression
- Manages race countdown and runtime timers
- Spawns vehicles in a grid formation
- Tracks race positions in real-time
- Uses dynamic bot difficulty based on quantity
- Maintains vehicle proximity awareness (ahead/behind)
- Tracks race position using lap count, checkpoints, and distance traveled

---

# 07_Modifiers.md

# Modifiers System Implementation

Modifiers in Quantum Racer 2.5D are special effects that can be applied to vehicles when they enter trigger zones on the track. Each modifier alters the vehicle's behavior in unique ways.

## Base RacerModifier Class

All modifiers inherit from the abstract `RacerModifier` class:

```csharp
public abstract class RacerModifier : AssetObject
{
    public AssetRef<RacerModifier>[] Children;
    private RacerModifier[] _children;

#if QUANTUM_UNITY
    public UnityEngine.AudioClip ModifierSFX;
#endif
    
    public void UpdateRacer(Frame f, ref RacerSystem.Filter filter)
    {
        InnerUpdate(f, ref filter);
        if (_children != null)
        {
            foreach (var child in _children)
            {
                child.UpdateRacer(f, ref filter);
            }
        }
    }

    public override void Loaded(IResourceManager resourceManager, Native.Allocator allocator)
    {
        if (Children != null && Children.Length > 0)
        {
            _children = new RacerModifier[Children.Length];
            for (int i = 0; i < Children.Length; i++)
            {
                _children[i] = resourceManager.GetAsset(Children[i].Id) as RacerModifier;
            }
        }
    }

    protected abstract void InnerUpdate(Frame f, ref RacerSystem.Filter filter);
}
```

The abstract design allows for:
- Composition of modifiers through the Children array
- Audio SFX for Unity rendering
- Hooks into the core update loop with `InnerUpdate`

## ModifierValues

The `Modifier` struct is used to store active modifier effects:

```csharp
struct Modifier {
    FP AccelMultiplier;
    FP FrictionMultiplier;
    FP MaxSpeedMultiplier;
}
```

This struct has a custom `Reset()` extension method:

```csharp
public static void Reset(ref this Modifier modifier)
{
    modifier.AccelMultiplier = FP._1;
    modifier.FrictionMultiplier = FP._1;
    modifier.MaxSpeedMultiplier = FP._1;
}
```

## Specific Modifier Types

### BoosterModifier

Increases acceleration and maximum speed:

```csharp
[Serializable]
public unsafe class BoosterModifier : RacerModifier
{
    public FP AccelMultiplier = 2;
    public FP MaxSpeedMultiplier = 2;

    protected override void InnerUpdate(Frame f, ref RacerSystem.Filter filter)
    {
        filter.Vehicle->ModifierValues.AccelMultiplier = AccelMultiplier;
        filter.Vehicle->ModifierValues.MaxSpeedMultiplier = MaxSpeedMultiplier;
    }
}
```

### FrictionModifier

Alters the vehicle's friction coefficient:

```csharp
[Serializable]
public unsafe class FrictionModifier : RacerModifier
{
    public FP FrictionMultiplier = 2;

    protected override void InnerUpdate(Frame f, ref RacerSystem.Filter filter)
    {
        filter.Vehicle->ModifierValues.FrictionMultiplier = FrictionMultiplier;
    }
}
```

### JumpPadModifier

Launches the vehicle into the air:

```csharp
[Serializable]
public unsafe class JumpPadModifier : RacerModifier
{
    public FP JumpImpulse = 0;

    protected override void InnerUpdate(Frame f, ref RacerSystem.Filter filter)
    {
        filter.Vehicle->VerticalSpeed = JumpImpulse;
        f.Events.Jump(filter.Entity);
    }
}
```

### HealthModifier

Restores vehicle energy:

```csharp
[Serializable]
public unsafe class HealthModifier : RacerModifier
{
    public FP HealthRestored = 1;

    protected override void InnerUpdate(Frame f, ref RacerSystem.Filter filter)
    {
        var config = f.FindAsset(filter.Vehicle->Config);
        filter.Vehicle->Energy = FPMath.Min(filter.Vehicle->Energy + HealthRestored, config.InitialEnergy);
    }
}
```

### ForceFieldModifier

Applies a directional force to the vehicle:

```csharp
[Serializable]
public unsafe class ForceFieldModifier : RacerModifier
{
    public FPVector2 ForceDirection = FPVector2.Up;
    public FP ForceMagnitude = 20;

    protected override void InnerUpdate(Frame f, ref RacerSystem.Filter filter)
    {
        filter.Body->AddForce(ForceDirection.Normalized * ForceMagnitude * filter.Body->Mass);
    }
}
```

## Modifier Application

Modifiers are applied to vehicles when they enter trigger areas in the game world. This happens in the `RacerSystem.OnTriggerEnter2D` method:

```csharp
public void OnTriggerEnter2D(Frame f, TriggerInfo2D info)
{
    if (info.IsStatic && f.Unsafe.TryGetPointer(info.Entity, out Racer* racer))
    {
        if (racer->Finished) return;
        var modifier = f.FindAsset<RacerModifier>(info.StaticData.Asset);
        if (modifier != null)
        {
            racer->Modifier = modifier.Guid;
        }
        else
        {
            // death
            Death(f, info.Entity, racer);
        }
    }
}
```

And removed when they exit:

```csharp
public void OnTriggerExit2D(Frame f, ExitInfo2D info)
{
    if (info.IsStatic && f.Unsafe.TryGetPointer(info.Entity, out Racer* racer))
    {
        racer->Modifier = default;
    }
}
```

## Available Modifier Assets

The following modifier assets are defined in the project:
- `BoosterPatch`: Provides a speed boost
- `HealthPatch`: Restores vehicle energy
- `JumpPad`: Launches vehicles into the air
- `MagnetPatchNegZ`: Applies force in the negative Z direction
- `MagnetPatchPosX`: Applies force in the positive X direction
- `OilPatch`: Reduces friction
- `RoughtPatch`: Increases friction

## Implementation Notes

- Modifiers can be composed together using the Children array
- Values take effect immediately when entering trigger areas
- Effects are applied every frame until the vehicle leaves the area
- Audio feedback is provided for Unity rendering
- Effects stack multiplicatively with vehicle base stats
- The modifier system is extensible for adding new effect types

---

# 08_UI_and_View.md

# UI and View Implementation

Quantum Racer 2.5D uses Quantum's view system to display game state to players. The view layer is responsible for visualizing the deterministic simulation on the client side.

## Core View Components

### RacerCameraView

The `RacerCameraView` class handles camera positioning and following the player's vehicle:

```csharp
public class RacerCameraView : QuantumEntityViewComponent<RacerCameraContext>
{
    public Vector3 Offset = new Vector3(0, 2, -4);
    public float LerpSpeed = 4;
    public bool Follow = false;
    public RacerLapUI LapUI;
    
    public override void OnActivate(Frame frame)
    {
        LapUI = GetComponent<RacerLapUI>();
        if (frame.TryGet(EntityRef, out RacerPlayerLink link) && Game.PlayerIsLocal(link.Player))
        {
            Follow = true;
            ViewContext.CurrentCameraController = this;
        }
    }

    public override void OnUpdateView()
    {
        if (Follow == false) return;
        var t = transform;
        
        // Set prediction area for optimal network performance
        Game.SetPredictionArea(transform.position.ToFPVector3(), 20);
        
        // Smoothly follow the vehicle
        var desired = t.TransformPoint(Offset);
        ViewContext.CameraHandle.position =
            Vector3.Lerp(ViewContext.CameraHandle.position, desired, Time.deltaTime * LerpSpeed);
        ViewContext.CameraHandle.LookAt(t);

        // Update speed display
        var body = PredictedFrame.Get<PhysicsBody2D>(EntityRef);
        var speed = body.Velocity.Magnitude.AsFloat * 20;
        ViewContext.SpeedLabel.text = $"{speed:0} Kmh";
    }
}
```

### RacerLapUI

The `RacerLapUI` class displays lap times and race information:

```csharp
public class RacerLapUI : QuantumEntityViewComponent<RacerCameraContext> {
    
    public bool Follow = false;
    
    public override void OnActivate(Frame frame)
    {
        if (frame.TryGet(EntityRef, out RacerPlayerLink link) && Game.PlayerIsLocal(link.Player)) 
            Follow = true;
    }
    
    public override void OnUpdateView()
    {
        if (Follow == false) return;
        
        // Display race start countdown or "Go!"
        if (PredictedFrame.TryGetSingleton<RaceManager>(out var manager))
        {
            if (manager.State == RaceState.Start)
            {
                var time = manager.RaceTime + 1;
                ViewContext.Info.text = "" + time.AsInt;
            }
            else if (manager.RaceTime < 3)
            {
                ViewContext.Info.text = "Go!";
            }
            else
            {
                ViewContext.Info.text = "";
            }
        }
        
        // Display vehicle race information
        var vehicle = PredictedFrame.Get<Racer>(EntityRef);
        var raceConfig = PredictedFrame.FindAsset<RaceConfig>(PredictedFrame.RuntimeConfig.RaceConfig);

        ViewContext.Laps.text = "" + vehicle.LapData.Laps + "/" + raceConfig.Laps;
        ViewContext.LapTime.text = "" + FormatTime(vehicle.LapData.LapTime.AsFloat);
        ViewContext.BestLap.text = "" + FormatTime(vehicle.LapData.BestLap.AsFloat);
        ViewContext.LastLap.text = "" + FormatTime(vehicle.LapData.LastLapTime.AsFloat);
        ViewContext.Position.text = "" + vehicle.Position;
    }

    private string FormatTime(float seconds)
    {
        int secondsInt = (int)seconds;
        int minutes = secondsInt / 60;
        float remainder = seconds - secondsInt;
        secondsInt = secondsInt % 60;
        return $"{minutes:00}:{secondsInt:00}:{remainder*1000:000}";
    }
}
```

### RaceUI

The `RaceUI` class displays overall race information including player positions:

```csharp
public class RaceUI : QuantumSceneViewComponent<RacerCameraContext> {
    public override void OnUpdateView()
    {
        string positions = "";
        var manager = PredictedFrame.GetOrAddSingleton<RaceManager>();
        var vehicles = PredictedFrame.ResolveList(manager.Vehicles);
        var bots = PredictedFrame.FindAsset(PredictedFrame.RuntimeConfig.Bots);

        foreach (var vehicle in vehicles)
        {
            var racer = PredictedFrame.Get<Racer>(vehicle);
            var link = PredictedFrame.Get<RacerPlayerLink>(vehicle);
            
            // Get player nickname
            string nickname = bots.Nicknames[link.Player];
            var data = PredictedFrame.GetPlayerData(link.Player);
            if (data != null)
                nickname = data.PlayerNickname;
                
            // Format display text
            if (racer.Finished)
            {
                positions += nickname + " (finished " + racer.Position + ")\n";
            }
            else
            {
                positions += nickname + " (laps: " + racer.LapData.Laps + ")\n";
            }
        }
        
        ViewContext.Positions.text = positions;
    }
}
```

### RacerLeanView

The `RacerLeanView` class visualizes vehicle lean:

```csharp
public class RacerLeanView : QuantumEntityViewComponent {
    
    public float LeanAngle = 15;
    public float LerpSpeed = 5;
    
    public override void OnUpdateView()
    {
        var racer = PredictedFrame.Get<Racer>(EntityRef);
        var leanAmount = racer.Lean;
        transform.localRotation = Quaternion.Slerp(transform.localRotation, 
                                                  Quaternion.Euler(0, 0, -leanAmount * LeanAngle), 
                                                  Time.deltaTime * LerpSpeed);
    }
}
```

## Racer Camera Context

The `RacerCameraContext` class provides shared access to UI elements:

```csharp
public class RacerCameraContext : QuantumSceneViewContext {
    public Transform CameraHandle;
    public RacerCameraView CurrentCameraController;
    
    // UI elements
    public TextMeshProUGUI LapTime;
    public TextMeshProUGUI BestLap;
    public TextMeshProUGUI LastLap;
    public TextMeshProUGUI Laps;
    public TextMeshProUGUI Position;
    public TextMeshProUGUI SpeedLabel;
    public TextMeshProUGUI Info;
    public TextMeshProUGUI Positions;
    
    // Other visual elements
    public Image HealthUI;
}
```

## Other View Components

### CarSelectorButton

Allows players to select their vehicle:

```csharp
public class CarSelectorButton : MonoBehaviour {
    public int CarIndex = 0;
    public Button Button;
    
    private void Start() {
        Button.onClick.AddListener(OnClick);
    }
    
    private void OnClick() {
        var data = QuantumRunner.Default.Game.GetPlayerData(QuantumRunner.Default.Game.LocalPlayerIndex);
        data.PlayerCar = CarIndex;
    }
}
```

### RacerSFX

Handles sound effects for the vehicle:

```csharp
public class RacerSFX : QuantumEntityViewComponent, ISignalOnJump, ISignalOnJumpLand, ISignalOnDeath, ISignalOnRespawn, ISignalOnBump, ISignalOnVehicleBump {
    
    public AudioSource EngineSound;
    public AudioSource EffectsSource;
    
    public AudioClip JumpSound;
    public AudioClip LandSound;
    public AudioClip DeathSound;
    public AudioClip RespawnSound;
    public AudioClip BumpSound;
    public AudioClip CarBumpSound;
    
    public override void OnUpdateView() {
        if (EngineSound != null) {
            var racer = PredictedFrame.Get<Racer>(EntityRef);
            var body = PredictedFrame.Get<PhysicsBody2D>(EntityRef);
            
            // Engine sound pitch based on speed
            var speed = body.Velocity.Magnitude.AsFloat;
            var normalizedSpeed = Mathf.Clamp01(speed / 10f);
            EngineSound.pitch = Mathf.Lerp(0.8f, 1.5f, normalizedSpeed);
            EngineSound.volume = Mathf.Lerp(0.2f, 1.0f, normalizedSpeed);
        }
    }
    
    public void OnJump(Frame frame, Jump e) {
        if (e.Entity == EntityRef && EffectsSource != null && JumpSound != null) {
            EffectsSource.PlayOneShot(JumpSound);
        }
    }
    
    public void OnJumpLand(Frame frame, JumpLand e) {
        if (e.Entity == EntityRef && EffectsSource != null && LandSound != null) {
            EffectsSource.PlayOneShot(LandSound);
        }
    }
    
    public void OnDeath(Frame frame, Death e) {
        if (e.Entity == EntityRef && EffectsSource != null && DeathSound != null) {
            EffectsSource.PlayOneShot(DeathSound);
        }
    }
    
    public void OnRespawn(Frame frame, Respawn e) {
        if (e.Entity == EntityRef && EffectsSource != null && RespawnSound != null) {
            EffectsSource.PlayOneShot(RespawnSound);
        }
    }
    
    public void OnBump(Frame frame, Bump e) {
        if (e.Entity == EntityRef && EffectsSource != null && BumpSound != null) {
            EffectsSource.PlayOneShot(BumpSound);
        }
    }
    
    public void OnVehicleBump(Frame frame, VehicleBump e) {
        if (e.Entity == EntityRef && EffectsSource != null && CarBumpSound != null) {
            EffectsSource.PlayOneShot(CarBumpSound);
        }
    }
}
```

### SpectateSwitcher

Allows spectating different vehicles:

```csharp
public class SpectateSwitcher : QuantumSceneViewComponent<RacerCameraContext> {
    public int CurrentSpectateIndex = 0;
    
    private void Update() {
        if (Input.GetKeyDown(KeyCode.Tab)) {
            SwitchSpectateTarget();
        }
    }
    
    private void SwitchSpectateTarget() {
        if (!PredictedFrame.TryGetSingleton<RaceManager>(out var manager)) return;
        
        var vehicles = PredictedFrame.ResolveList(manager.Vehicles);
        if (vehicles.Count == 0) return;
        
        CurrentSpectateIndex = (CurrentSpectateIndex + 1) % vehicles.Count;
        var entityView = QuantumRunner.Default.Game.GetEntityView(vehicles[CurrentSpectateIndex]);
        
        if (entityView != null) {
            var cameraView = entityView.GetComponent<RacerCameraView>();
            if (cameraView != null) {
                if (ViewContext.CurrentCameraController != null) {
                    ViewContext.CurrentCameraController.Follow = false;
                }
                
                cameraView.Follow = true;
                ViewContext.CurrentCameraController = cameraView;
                ViewContext.CurrentCameraController.LapUI.Follow = true;
            }
        }
    }
}
```

## Implementation Notes

- Uses Quantum's view component system for frame interpolation
- Separates game logic (simulation) from presentation
- Uses predicted frames for smoother experience
- Supports local and networked play
- Compatible with Unity's UI system
- Provides visual feedback for game events
- Supports spectator mode for watching other players

---

# 09_Networking.md

# Quantum Networking Implementation

Quantum Racer 2.5D leverages Photon Quantum's networking capabilities to provide deterministic multiplayer racing. This document explains the key networking concepts and implementation details.

## PhotonServerSettings

The PhotonServerSettings asset contains the configuration for connecting to Photon servers:

```csharp
// Located in Assets/QuantumUser/Resources/PhotonServerSettings.asset
public class PhotonServerSettings : ScriptableObject
{
    public string AppID;        // Photon application ID from dashboard
    public string AppVersion;   // Application version for matchmaking
    public string Region;       // Default region (e.g., "eu", "us", "asia")
    public bool EnableLobby;    // Whether to join a lobby on connect
    public ServerType ServerType = ServerType.Quantum;  // Using Quantum servers
    public RuntimeConfig DefaultRuntimeConfig;          // Default quantum config
}
```

## Core Quantum Networking

Quantum provides a deterministic networking framework with:

1. Input collection and synchronization
2. Deterministic physics simulation
3. Frame rollback and prediction
4. Client-side reconciliation

## Session Config

The SessionConfig asset defines the network session parameters:

```csharp
// Located in Assets/QuantumUser/Resources/SessionConfig.asset
public class SessionConfig : ScriptableObject
{
    public RuntimeConfig RuntimeConfig;
    public DeterministicSessionConfig SessionConfig;
    
    // Network settings
    public int TickRate = 60;                // Physics updates per second
    public int UpdateFPS = 60;               // Visual update rate
    public int InputDelayFrames = 2;         // Delay for input processing
    public int PredictionFrames = 2;         // Number of frames to predict ahead
    public int RollbackFrames = 12;          // Maximum rollback frames on correction
    public int SnapshotSendRate = 30;        // State snapshots per second
    public int InputSendRate = 60;           // Input send rate per second
    
    // Game settings
    public int MaxSlotsOnServer = 99;        // Maximum players in a session 
    public bool ClientSideVerification = false;
}
```

## Multiplayer Integration

### Player Connection

The Quantum runner manages player connections and game session:

```csharp
public class MultiplayerManager : MonoBehaviour
{
    private QuantumRunner _runner;
    
    public async void JoinGame()
    {
        // Load server settings
        var serverSettings = Resources.Load<PhotonServerSettings>("PhotonServerSettings");
        var sessionConfig = Resources.Load<SessionConfig>("SessionConfig");
        
        // Connect to Photon Cloud
        await Photon.Realtime.PhotonNetwork.ConnectUsingSettingsAsync(serverSettings);
        
        // Join or create room
        var roomOptions = new Photon.Realtime.RoomOptions {
            MaxPlayers = sessionConfig.MaxSlotsOnServer,
            IsVisible = true
        };
        
        await Photon.Realtime.PhotonNetwork.JoinOrCreateRoomAsync(
            "RacerRoom", roomOptions, Photon.Realtime.TypedLobby.Default);
        
        // Start Quantum session
        var callbackHandler = new QuantumCallbacks();
        _runner = QuantumRunner.StartGame(
            "RacerRoom", 
            PhotonNetwork.LocalPlayer.ActorNumber, 
            PhotonNetwork.CurrentRoom.Players.Count,
            sessionConfig,
            callbackHandler);
    }
}
```

### Input Handling

The Quantum input system collects and synchronizes player inputs:

```csharp
public class InputHandler : MonoBehaviour, ISignalInputConfirmed, ISignalInputSubmitted
{
    public void Update()
    {
        if (QuantumRunner.Default == null) return;
        
        // Get current input
        var input = new Quantum.Input();
        
        // Keyboard controls
        input.RacerAccel.Set(UnityEngine.Input.GetKey(KeyCode.W));
        input.RacerBrake.Set(UnityEngine.Input.GetKey(KeyCode.S));
        input.RacerLeft.Set(UnityEngine.Input.GetKey(KeyCode.A));
        input.RacerRight.Set(UnityEngine.Input.GetKey(KeyCode.D));
        input.RacerLeanLeft.Set(UnityEngine.Input.GetKey(KeyCode.J));
        input.RacerLeanRight.Set(UnityEngine.Input.GetKey(KeyCode.L));
        input.RacerPitchUp.Set(UnityEngine.Input.GetKey(KeyCode.I));
        input.RacerPitchDown.Set(UnityEngine.Input.GetKey(KeyCode.K));
        
        // Submit to Quantum
        QuantumRunner.Default.Game.SendInput(input);
    }
    
    public void OnInputConfirmed(Frame frame, InputInfo inputInfo)
    {
        // Called when the server confirms our input
        Debug.Log($"Input confirmed for frame {inputInfo.Frame}");
    }
    
    public void OnInputSubmitted(Frame frame, PlayerRef player, Input input)
    {
        // Called when any player submits input
        if (player == frame.Runner.LocalPlayerRef)
        {
            Debug.Log($"Local input submitted for frame {frame.Number}");
        }
    }
}
```

## Network Synchronization

### Player Data Synchronization

```csharp
public class NetworkPlayerData
{
    // Synchronized player data
    public string PlayerNickname;
    public int PlayerCar;
    public AssetRef<EntityPrototype> PlayerAvatar;
    
    // Local setup
    public static void SetupLocalPlayer(string nickname, int carIndex)
    {
        if (QuantumRunner.Default == null) return;
        
        var data = QuantumRunner.Default.Game.GetPlayerData(QuantumRunner.Default.Game.LocalPlayerIndex);
        data.PlayerNickname = nickname;
        data.PlayerCar = carIndex;
        
        // Set avatar based on car selection
        var map = QuantumRunner.Default.Game.Frames.Predicted.Map;
        var spawnConfig = QuantumRunner.Default.Game.Frames.Predicted.FindAsset<SpawnConfig>(map.UserAsset);
        data.PlayerAvatar = spawnConfig.AvailableCars[carIndex];
    }
}
```

### Deterministic Random

Quantum uses a deterministic random number generator to ensure all clients calculate the same results:

```csharp
// In RaceManagerSystem.Spawn
var racelineToPick = f.Global->RngSession.Next(0, spawnConfig.AvailableRacelines.Length);
bot->Raceline = spawnConfig.AvailableRacelines[racelineToPick];
```

## Frame Prediction and Rollback

Quantum uses frame prediction for smooth gameplay and rollback for corrections:

```csharp
public class QuantumCallbacks : QuantumCallbackHandler
{
    public override void OnUpdateView(QuantumGame game)
    {
        // Called after the prediction is complete
        // View components use this to update visuals
    }
    
    public override void OnSimulateFinished(QuantumGame game, Frame frame)
    {
        // Called after each frame simulation
        if (frame.IsVerified)
        {
            // Frame has been verified by the server
        }
    }
    
    public override void OnRollback(QuantumGame game)
    {
        // Called when a client needs to rollback due to a correction
        Debug.Log($"Rollback occurred at frame {game.Frames.Predicted.Number}");
    }
}
```

## Handling Networked Events

Events are used to synchronize important game events across the network:

```csharp
// Signal interfaces
public unsafe class RacerSystem : SystemMainThreadFilter<RacerSystem.Filter>,
    ISignalOnPlayerAdded,
    ISignalOnTriggerEnter2D,
    ISignalOnTriggerExit2D,
    ISignalOnCollisionEnter2D,
    ISignalRespawn,
    ISignalReset
{
    // Implementation...
}

// Event emission in code
f.Events.Jump(entity);
f.Events.Death(entity);
f.Events.VehicleBump(info.Entity, info.Other, info.ContactPoints.Average);

// Event handling via interfaces
public class RacerSFX : QuantumEntityViewComponent, 
    ISignalOnJump, 
    ISignalOnJumpLand, 
    ISignalOnDeath, 
    ISignalOnRespawn, 
    ISignalOnBump, 
    ISignalOnVehicleBump
{
    public void OnJump(Frame frame, Jump e) 
    {
        if (e.Entity == EntityRef && EffectsSource != null && JumpSound != null) 
        {
            EffectsSource.PlayOneShot(JumpSound);
        }
    }
    
    // Other handlers...
}
```

## Photon Room and Matchmaking

The game uses Photon's room system for matchmaking:

```csharp
public class MatchmakingUI : MonoBehaviour
{
    public async void CreateRoom()
    {
        var roomOptions = new Photon.Realtime.RoomOptions
        {
            MaxPlayers = 16,
            IsVisible = true,
            CustomRoomProperties = new ExitGames.Client.Photon.Hashtable
            {
                { "map", "Circuit1" },
                { "laps", 3 }
            },
            CustomRoomPropertiesForLobby = new string[] { "map", "laps" }
        };
        
        await PhotonNetwork.CreateRoomAsync(null, roomOptions);
    }
    
    public async void JoinRandomRoom()
    {
        try 
        {
            await PhotonNetwork.JoinRandomRoomAsync();
        }
        catch (Photon.Realtime.ClientOutgoingOperationFailedException)
        {
            // No rooms available, create one
            await CreateRoom();
        }
    }
}
```

## Implementation Notes

- Uses Photon Quantum's deterministic networking
- Supports up to 99 players in a race
- Input delay and prediction settings are configurable
- Requires AppID from Photon Dashboard
- Uses deterministic random for consistent results
- Events propagate synchronized game events
- Matchmaking uses Photon's room system
- Frame rollback handles network corrections

---

# 10_Code_Generation_Guide.md

# Quantum Racer 2.5D Code Generation Guide

This guide provides reference patterns for generating code for the Quantum Racer 2.5D game using an LLM. The examples below illustrate the proper structure and syntax for key components of the game.

## Creating a New Modifier

```csharp
// New modifier that applies a speed boost for a limited time
using Photon.Deterministic;
using System;

namespace Quantum 
{
    [Serializable]
    public unsafe class TimedBoostModifier : RacerModifier
    {
        public FP BoostDuration = 3;      // Duration in seconds
        public FP AccelMultiplier = 2;     // Acceleration multiplier
        public FP MaxSpeedMultiplier = 2;  // Speed multiplier
        
        protected override void InnerUpdate(Frame f, ref RacerSystem.Filter filter)
        {
            if (filter.Vehicle->ModifierValues.BoostTimer <= 0)
            {
                // First application - set timer
                filter.Vehicle->ModifierValues.BoostTimer = BoostDuration;
            }
            
            // Apply boost effects
            filter.Vehicle->ModifierValues.AccelMultiplier = AccelMultiplier;
            filter.Vehicle->ModifierValues.MaxSpeedMultiplier = MaxSpeedMultiplier;
            
            // Decrease timer
            filter.Vehicle->ModifierValues.BoostTimer -= f.DeltaTime;
            
            // Remove modifier when timer expires
            if (filter.Vehicle->ModifierValues.BoostTimer <= 0)
            {
                filter.Vehicle->Modifier = default;
            }
        }
    }
}
```

## Creating a New Vehicle Config

```csharp
// Assets/QuantumUser/Resources/Racer/CarSpecs/SuperCarConfig.asset
using Photon.Deterministic;
using UnityEngine;

namespace Quantum 
{
    [CreateAssetMenu(menuName = "Quantum/Racer/Vehicle/SuperCar Config")]
    public class SuperCarConfig : RacerConfig
    {
        private void OnValidate()
        {
            // Set specific vehicle characteristics
            CarName = "Super Car";
            Acceleration = 20;
            Mass = 1.5f;
            Braking = 8;
            GroundDrag = 0.8f;
            MaxSpeed = 12;
            RotationSpeed = 12;
            LeanBuff = 6;
            FrictionCoeficient = 1.8f;
            ThrottleFrictionReductor = 0.4f;
            InitialEnergy = 15;
            
            // Create steering response curve
            if (SteeringResponseCurve == null || SteeringResponseCurve.Points.Length == 0)
            {
                SteeringResponseCurve = new FPAnimationCurve(new [] {
                    new FPAnimationCurve.KeyFrame(0, 1),
                    new FPAnimationCurve.KeyFrame(5, 0.75f),
                    new FPAnimationCurve.KeyFrame(10, 0.5f),
                    new FPAnimationCurve.KeyFrame(15, 0.25f)
                });
            }
        }
    }
}
```

## Adding a New Track Feature

```csharp
// New teleporter system that moves vehicles to a target position
using Photon.Deterministic;
using UnityEngine.Scripting;

namespace Quantum
{
    [Preserve]
    public unsafe class TeleporterSystem : SystemMainThreadFilter<TeleporterSystem.Filter>, 
        ISignalOnTriggerEnter2D
    {
        public struct Filter
        {
            public EntityRef Entity;
            public Teleporter* Teleporter;
            public Transform2D* Transform;
        }
        
        public override void Update(Frame f, ref Filter filter)
        {
            // Optional: Teleporter effects/animations
            filter.Teleporter->EffectTimer += f.DeltaTime;
            if (filter.Teleporter->EffectTimer > filter.Teleporter->EffectInterval)
            {
                filter.Teleporter->EffectTimer = FP._0;
                // Trigger effect here
            }
        }
        
        public void OnTriggerEnter2D(Frame f, TriggerInfo2D info)
        {
            // Check if trigger is a teleporter
            if (f.Unsafe.TryGetPointer(info.Static, out Teleporter* teleporter))
            {
                // Check if entering entity is a racer
                if (f.Unsafe.TryGetPointer(info.Entity, out Racer* racer) &&
                    f.Unsafe.TryGetPointer(info.Entity, out Transform2D* transform) &&
                    f.Unsafe.TryGetPointer(info.Entity, out PhysicsBody2D* body))
                {
                    // Don't teleport finished racers
                    if (racer->Finished) return;
                    
                    // Get destination coordinates
                    var destination = teleporter->Destination;
                    
                    // Store original velocity
                    var velocity = body->Velocity;
                    var speed = velocity.Magnitude;
                    
                    // Momentarily make body kinematic to prevent physics issues
                    body->IsKinematic = true;
                    
                    // Teleport the entity
                    transform->Teleport(f, destination.Position);
                    transform->Rotation = destination.Rotation;
                    
                    // Apply exit velocity in the correct direction
                    body->IsKinematic = false;
                    body->Velocity = transform->Up * speed * teleporter->SpeedMultiplier;
                    
                    // Trigger teleport event
                    f.Events.Teleport(info.Entity, destination.Position);
                }
            }
        }
    }
    
    // Component definition in .qtn file
    /*
    component Teleporter {
        FPTransform2D Destination;
        FP SpeedMultiplier;
        [ExcludeFromPrototype] FP EffectTimer;
        FP EffectInterval;
    }
    
    event Teleport {
        EntityRef Entity;
        FPVector2 Destination;
    }
    */
}
```

## Adding a New Game Mode

```csharp
// Checkpoint Race mode - race to complete all checkpoints in any order
using Photon.Deterministic;
using UnityEngine.Scripting;

namespace Quantum
{
    [Preserve]
    public unsafe class CheckpointRaceSystem : SystemMainThread
    {
        public override void OnInit(Frame f)
        {
            // Initialize the race
            f.GetOrAddSingleton<CheckpointRaceManager>();
            var raceConfig = f.FindAsset<CheckpointRaceConfig>(f.RuntimeConfig.CheckpointRaceConfig);
            
            if (f.Unsafe.TryGetPointerSingleton<CheckpointRaceManager>(out var manager))
            {
                // Initialize checkpoint list
                manager->RemainingCheckpoints = f.AllocateList<EntityRef>();
                manager->PlayerCheckpoints = f.AllocateMap<PlayerRef, byte>();
                manager->RaceTime = raceConfig.StartCountdown;
                manager->State = RaceState.Start;
                
                // Populate checkpoint list
                var checkpoints = f.Filter<Transform2D, CheckpointRaceTarget>();
                while (checkpoints.NextUnsafe(out var entity, out _, out _))
                {
                    var list = f.ResolveList(manager->RemainingCheckpoints);
                    list.Add(entity);
                }
            }
        }
        
        public override void Update(Frame f)
        {
            if (f.Unsafe.TryGetPointerSingleton<CheckpointRaceManager>(out var manager))
            {
                switch (manager->State)
                {
                    case RaceState.Start:
                        // Countdown timer
                        manager->RaceTime -= f.DeltaTime;
                        if (manager->RaceTime <= 0)
                        {
                            manager->State = RaceState.Running;
                            manager->RaceTime = 0;
                            FillWithBots(f);
                        }
                        break;
                        
                    case RaceState.Running:
                        // Update race timer
                        manager->RaceTime += f.DeltaTime;
                        
                        // Check if all checkpoints have been collected
                        if (manager->FinishedCount >= f.PlayerCount)
                        {
                            manager->State = RaceState.Finished;
                        }
                        break;
                        
                    case RaceState.Finished:
                        // Race complete
                        break;
                }
            }
        }
        
        // Helper methods omitted
    }
    
    // Component definitions in .qtn file
    /*
    singleton component CheckpointRaceManager {
        list<EntityRef> RemainingCheckpoints;
        map<PlayerRef, byte> PlayerCheckpoints;
        FP RaceTime;
        RaceState State;
        int FinishedCount;
    }
    
    component CheckpointRaceTarget {
        byte CheckpointID;
        bool Collected;
    }
    */
}
```

## Creating Custom Player Controls

```csharp
// Custom control scheme that adds boost functionality
using Quantum;
using UnityEngine;

public class CustomControlHandler : MonoBehaviour
{
    // Boost cooldown tracking
    private float _boostCooldown = 0f;
    private float _maxBoostCooldown = 3f;
    private bool _boostReady = true;
    
    // UI reference
    public UnityEngine.UI.Image BoostCooldownUI;
    
    private void Update()
    {
        if (QuantumRunner.Default == null) return;
        
        // Update boost cooldown
        if (_boostCooldown > 0)
        {
            _boostCooldown -= Time.deltaTime;
            if (_boostCooldown <= 0)
            {
                _boostReady = true;
                _boostCooldown = 0;
            }
            
            // Update UI
            if (BoostCooldownUI != null)
            {
                BoostCooldownUI.fillAmount = 1f - (_boostCooldown / _maxBoostCooldown);
            }
        }
        
        // Get input
        var input = new Quantum.Input();
        
        // Standard controls
        input.RacerAccel.Set(UnityEngine.Input.GetKey(KeyCode.W));
        input.RacerBrake.Set(UnityEngine.Input.GetKey(KeyCode.S));
        input.RacerLeft.Set(UnityEngine.Input.GetKey(KeyCode.A));
        input.RacerRight.Set(UnityEngine.Input.GetKey(KeyCode.D));
        input.RacerLeanLeft.Set(UnityEngine.Input.GetKey(KeyCode.J));
        input.RacerLeanRight.Set(UnityEngine.Input.GetKey(KeyCode.L));
        input.RacerPitchUp.Set(UnityEngine.Input.GetKey(KeyCode.I));
        input.RacerPitchDown.Set(UnityEngine.Input.GetKey(KeyCode.K));
        
        // Boost control (space key)
        input.RacerBoost.Set(UnityEngine.Input.GetKey(KeyCode.Space) && _boostReady);
        
        // Trigger boost cooldown when activated
        if (input.RacerBoost.WasPressed)
        {
            _boostReady = false;
            _boostCooldown = _maxBoostCooldown;
        }
        
        // Send input to Quantum
        QuantumRunner.Default.Game.SendInput(input);
    }
}

// Add to .qtn file
/*
input {
    // Existing inputs...
    button RacerBoost;
}
*/

// Processor in RacerConfig.cs
/*
public void UpdateRacer(Frame f, ref RacerSystem.Filter filter)
{
    // Existing code...
    
    // Process boost
    if (input.RacerBoost.WasPressed)
    {
        // Apply boost effects
        filter.Body->AddForce(filter.Transform->Up * BoostForce * filter.Body->Mass);
        filter.Vehicle->BoostActive = true;
        filter.Vehicle->BoostTimer = BoostDuration;
        
        // Trigger effect
        f.Events.BoostActivated(filter.Entity);
    }
    
    // Update boost state
    if (filter.Vehicle->BoostActive)
    {
        filter.Vehicle->BoostTimer -= f.DeltaTime;
        if (filter.Vehicle->BoostTimer <= 0)
        {
            filter.Vehicle->BoostActive = false;
        }
        else
        {
            // Apply continuous boost effects
            filter.Vehicle->ModifierValues.MaxSpeedMultiplier = BoostSpeedMultiplier;
        }
    }
}
*/
```

## Adding a New Event System

```csharp
// Item pickup and use system
using Photon.Deterministic;
using UnityEngine.Scripting;

namespace Quantum
{
    [Preserve]
    public unsafe class ItemSystem : SystemMainThreadFilter<ItemSystem.Filter>, 
        ISignalOnTriggerEnter2D
    {
        public struct Filter
        {
            public EntityRef Entity;
            public ItemHolder* Items;
            public Racer* Racer;
        }
        
        public override void Update(Frame f, ref Filter filter)
        {
            Input input = default;
            
            // Get player input if applicable
            if (f.TryGet(filter.Entity, out RacerPlayerLink link) && link.Player.IsValid)
            {
                input = *f.GetPlayerInput(link.Player);
            }
            
            // Check for item use
            if (input.UseItem.WasPressed && filter.Items->CurrentItem != ItemType.None)
            {
                UseItem(f, filter.Entity, filter.Items, filter.Racer);
            }
            
            // Update item cooldown
            if (filter.Items->ItemCooldown > 0)
            {
                filter.Items->ItemCooldown -= f.DeltaTime;
            }
        }
        
        private void UseItem(Frame f, EntityRef entity, ItemHolder* items, Racer* racer)
        {
            if (items->ItemCooldown > 0) return;
            
            switch (items->CurrentItem)
            {
                case ItemType.SpeedBoost:
                    // Apply speed boost
                    items->ItemCooldown = 5; // 5 second cooldown
                    racer->ModifierValues.AccelMultiplier = 2;
                    racer->ModifierValues.MaxSpeedMultiplier = 2;
                    racer->BoostTimer = 3; // 3 second duration
                    f.Events.ItemUsed(entity, ItemType.SpeedBoost);
                    break;
                    
                case ItemType.Shield:
                    // Apply shield
                    items->ItemCooldown = 10; // 10 second cooldown
                    racer->ShieldActive = true;
                    racer->ShieldTimer = 5; // 5 second duration
                    f.Events.ItemUsed(entity, ItemType.Shield);
                    break;
                    
                case ItemType.Missile:
                    // Fire missile at car ahead
                    if (racer->CarAhead.IsValid)
                    {
                        items->ItemCooldown = 8; // 8 second cooldown
                        FireMissile(f, entity, racer->CarAhead);
                        f.Events.ItemUsed(entity, ItemType.Missile);
                    }
                    break;
            }
            
            // Clear current item
            items->CurrentItem = ItemType.None;
        }
        
        private void FireMissile(Frame f, EntityRef source, EntityRef target)
        {
            // Create missile entity
            var missilePrototype = f.FindAsset<EntityPrototype>("Missile");
            var missile = f.Create(missilePrototype);
            
            // Set missile properties
            if (f.Unsafe.TryGetPointer(missile, out Missile* missileComponent))
            {
                missileComponent->Source = source;
                missileComponent->Target = target;
                missileComponent->Speed = 20; // FP units per second
                missileComponent->Damage = 5;
            }
            
            // Position missile
            if (f.Unsafe.TryGetPointer(missile, out Transform2D* transform) &&
                f.TryGet<Transform2D>(source, out var sourceTransform))
            {
                transform->Position = sourceTransform.Position;
                transform->Rotation = sourceTransform.Rotation;
            }
        }
        
        public void OnTriggerEnter2D(Frame f, TriggerInfo2D info)
        {
            // Check if trigger is an item box
            if (f.Unsafe.TryGetPointer(info.Static, out ItemBox* itemBox))
            {
                // Check if entering entity has an item holder
                if (f.Unsafe.TryGetPointer(info.Entity, out ItemHolder* items) &&
                    items->CurrentItem == ItemType.None &&
                    items->ItemCooldown <= 0)
                {
                    // Random item selection
                    var itemIndex = f.Global->RngSession.Next(0, 3); // 0-2
                    items->CurrentItem = (ItemType)(itemIndex + 1); // Convert to enum (1-3)
                    
                    // Trigger pickup event
                    f.Events.ItemPickup(info.Entity, items->CurrentItem);
                }
            }
        }
    }
    
    // Component definitions in .qtn file
    /*
    enum ItemType {
        None = 0,
        SpeedBoost = 1,
        Shield = 2,
        Missile = 3
    }
    
    component ItemHolder {
        ItemType CurrentItem;
        [ExcludeFromPrototype] FP ItemCooldown;
    }
    
    component ItemBox {
        int ItemBoxID;
        [ExcludeFromPrototype] FP RespawnTimer;
        FP RespawnDelay;
    }
    
    component Missile {
        EntityRef Source;
        EntityRef Target;
        FP Speed;
        FP Damage;
        [ExcludeFromPrototype] FP Lifetime;
    }
    
    // Add to Racer component
    [ExcludeFromPrototype] FP BoostTimer;
    [ExcludeFromPrototype] bool ShieldActive;
    [ExcludeFromPrototype] FP ShieldTimer;
    
    // Add to Input
    button UseItem;
    
    // Events
    event ItemPickup {
        EntityRef Entity;
        ItemType ItemType;
    }
    
    event ItemUsed {
        EntityRef Entity;
        ItemType ItemType;
    }
    */
}
```

## Implementation Notes

When generating code for Quantum Racer 2.5D, remember these key patterns:

1. **Deterministic Physics**: Always use `FP` (fixed point) for numeric values
2. **Component Access**: Use `f.Unsafe.TryGetPointer` for high-performance component access
3. **Updates**: Implement core logic in `Update` methods that take a `Frame` parameter
4. **Serialization**: Mark components with `[ExcludeFromPrototype]` for runtime-only values
5. **Events**: Use Quantum's event system for gameplay events and animations
6. **Networking**: Never mix Unity physics with Quantum deterministic simulation
7. **Signal Interfaces**: Implement signal interfaces like `ISignalOnTriggerEnter2D` for physics events
8. **Systems**: Inherit from appropriate `System` class based on threading needs
9. **Assets**: Reference game configs via `AssetRef<T>` and load with `f.FindAsset()`
10. **AI Control**: Use the Bot components and config for computer-controlled racers

---

# 11_Asset_Structure.md

# Quantum Racer 2.5D Asset Structure

This document outlines the key assets and their relationships in the Quantum Racer 2.5D game. Understanding this structure is essential for creating or modifying game content.

## Vehicle Assets

Each vehicle in the game consists of several interrelated assets:

### 1. Vehicle Config Asset
```
Assets/QuantumUser/Resources/Racer/CarSpecs/{VehicleName}Config.asset
```

The config asset defines the vehicle's handling characteristics:
- Acceleration, braking, and mass
- Maximum speed and rotation speed
- Drag and friction coefficients
- Lean effects and jump parameters
- Energy (health) values

### 2. Vehicle Prefab
```
Assets/QuantumUser/Resources/Racer/CarSpecs/{VehicleName}.prefab
```

The Unity prefab contains:
- 3D mesh models for the vehicle
- Particle systems for effects
- Audio sources for engine and collision sounds
- Visual components for lean and pitch animations

### 3. Entity Prototype
```
Assets/QuantumUser/Resources/Racer/CarSpecs/{VehicleName}EntityPrototype.qprototype
```

The Quantum prototype defines the entity's components:
- Racer component with config reference
- Transform2D and Transform2DVertical components
- PhysicsBody2D with collision properties
- RacerPlayerLink for player association

Example prototype structure:
```json
{
  "Id": "c653e58a57c5e0f4f927a3aee0a19aed",
  "Name": "BlasterEntityPrototype",
  "Components": [
    {
      "$type": "Quantum.RacerPlayerLink",
      "Player": {
        "IsValid": false,
        "Value": 0
      }
    },
    {
      "$type": "Quantum.Transform2D",
      "Position": {
        "X": 0,
        "Y": 0
      },
      "Rotation": 0
    },
    {
      "$type": "Quantum.Transform2DVertical",
      "Position": 0
    },
    {
      "$type": "Quantum.PhysicsBody2D",
      "Mass": 1.0,
      "AngularDrag": 1.0,
      "IsKinematic": false,
      "Layer": 4,
      "CollisionShape": {
        "$type": "Quantum.CircleCollider2D",
        "Center": {
          "X": 0,
          "Y": 0
        },
        "Radius": 0.5
      }
    },
    {
      "$type": "Quantum.Racer",
      "Config": "Assets/QuantumUser/Resources/Racer/CarSpecs/BlasterConfig.asset",
      "Energy": 10
    }
  ],
  "View": "Assets/QuantumUser/Resources/Racer/CarSpecs/Blaster.prefab"
}
```

## Track Assets

The track is composed of multiple assets that work together:

### 1. Quantum Map Asset
```
Assets/QuantumUser/Resources/QuantumMap.asset
```

The map asset references:
- Physics navigation data
- Static collider geometry
- The main scene to load
- User asset for spawn configuration

### 2. Spawn Config Asset
```
Assets/QuantumUser/Resources/Racer/SpawnMap1.asset
```

Defines race starting parameters:
- Base spawn position
- Grid layout configuration
- Available vehicle references
- Raceline references for AI navigation

### 3. Race Config Asset
```
Assets/QuantumUser/Resources/Racer/BasicRace.asset
```

Controls race parameters:
- Lap count for completion
- Countdown timer duration
- Collision response values
- Respawn behaviors and timers

### 4. Track Tile Prefabs
```
Assets/QuantumUser/Resources/Racer/TrackTiles/
```

Contains modular track pieces:
- Straight sections and curves
- Jumps and ramps
- Modifier trigger zones
- Decoration elements

## Modifier Assets

### 1. Modifier Config Assets
```
Assets/QuantumUser/Resources/Racer/Modifiers/{ModifierName}.asset
```

Each modifier asset defines:
- Effect magnitude and duration
- Visual effects references
- Audio effect references
- Any specific modifier behaviors

Available modifiers include:
- BoosterPatch: Speed and acceleration boost
- OilPatch: Reduced friction
- RoughtPatch: Increased friction
- JumpPad: Vertical launch
- HealthPatch: Energy restoration
- MagnetPatch: Directional force application

### 2. Modifier Prefabs
```
Assets/3rd-party/ModifierPrefabs/{ModifierName}.prefab
```

Visual representation of modifiers including:
- 3D models
- Particle effects
- Trigger colliders
- Visual feedback elements

## Bot/AI Assets

### 1. Bot Config Container
```
Assets/QuantumUser/Resources/Racer/Bots/BotConfigsDefault.asset
```

Contains:
- Array of bot difficulty configurations
- Maximum bot count settings
- Bot nicknames for display
- Bot start delay intervals

### 2. Bot Config Assets
```
Assets/QuantumUser/Resources/Racer/Bots/BotConfig_{Difficulty}.asset
```

Individual bot configurations:
- AI aggressiveness parameters
- Racing line following precision
- Lookahead distance settings
- Speed control behavior

### 3. Checkpoint Data Assets
```
Assets/QuantumUser/Resources/Racer/Bots/Raceline_{TrackName}.asset
```

Contains:
- Sequence of racing line waypoints
- Recommended speeds for each waypoint
- Reference rotation speed values
- Distance between marks for calculations

## Network and Session Assets

### 1. PhotonServerSettings
```
Assets/QuantumUser/Resources/PhotonServerSettings.asset
```

Network configuration including:
- Photon AppID for cloud connection
- Region preferences
- Server connection type
- Default session configuration

### 2. SessionConfig
```
Assets/QuantumUser/Resources/SessionConfig.asset
```

Quantum session parameters:
- Tick rate and update FPS
- Prediction and rollback frame counts
- Input delay configuration
- Snapshot and input send rates
- Player slot allocation

### 3. QuantumDefaultConfigs
```
Assets/QuantumUser/Resources/QuantumDefaultConfigs.asset
```

Core Quantum engine configuration:
- Runtime configuration default
- Dynamic DB definition
- Navigation settings
- Physics parameters

## UI Assets

### 1. Interface Prefabs
```
Assets/QuantumUser/Resources/UI/
```

Contains UI elements for:
- Main menu and lobby interface
- HUD during gameplay
- Race position display
- Lap timer interface
- Vehicle selection interface
- End race scoreboard

### 2. UI Component Assets
```
Assets/QuantumUser/Resources/UI/Components/
```

Reusable UI elements:
- Player nametags
- Minimap display
- Speed indicator
- Energy/health bar
- Item display (if applicable)

## Implementation Notes

When working with Quantum Racer assets:

1. **Entity Prototypes**: Always update both the config asset and entity prototype when changing vehicle parameters
2. **Map Configuration**: When creating a new track, ensure all checkpoint and raceline data are properly linked
3. **Asset References**: Use AssetRef<T> in code to reference proper assets by GUID
4. **Prefab Linking**: Make sure prefabs are correctly referenced in entity prototypes through the View field
5. **Bot Configuration**: Configure bot difficulty through tiered bot config assets
6. **Photon Setup**: Valid AppID must be set in PhotonServerSettings for multiplayer functionality
7. **Asset Dependencies**: Maintain proper references between interdependent assets
8. **Scene References**: Keep track of scene dependencies in the Quantum Map asset

---

# 12_Optimization_Tips.md

# Quantum Racer 2.5D Optimization Tips

This document provides guidance on performance optimization for the Quantum Racer 2.5D game. Following these principles will help maintain smooth gameplay, especially in multiplayer scenarios.

## Deterministic Simulation Optimization

### 1. Component Access Patterns

Use the most efficient component access pattern for each situation:

```csharp
// GOOD: Fastest access when frequently accessing same component
if (f.Unsafe.TryGetPointer(entity, out Racer* racer))
{
    // Direct pointer access is fastest
    var config = f.FindAsset(racer->Config);
    racer->Energy -= damage;
}

// GOOD: For one-time safe access
if (f.TryGet(entity, out Racer racer))
{
    // Safe struct access
    var config = f.FindAsset(racer.Config);
}

// BAD: Repeated GetComponent calls
var racer1 = f.Get<Racer>(entity);  // Gets copy 1
var racer2 = f.Get<Racer>(entity);  // Gets copy 2
racer1.Energy -= damage;
f.Set(entity, racer1);  // Must manually update
```

### 2. System Filter Selection

Choose the right system filter for better performance:

```csharp
// GOOD: Filter with explicit component requirements
public class RacerSystem : SystemMainThreadFilter<RacerSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform2D* Transform;
        public PhysicsBody2D* Body;
        public Racer* Vehicle;
    }
}

// BAD: Filter entities manually in update
public class SlowSystem : SystemMainThread 
{
    public override void Update(Frame f)
    {
        // Manual filtering is slow
        var entities = f.GetEntityArray();
        foreach (var entity in entities)
        {
            if (f.Has<Racer>(entity) && f.Has<Transform2D>(entity))
            {
                // Process entity...
            }
        }
    }
}
```

### 3. Memory Allocation

Avoid runtime allocations in simulation code:

```csharp
// GOOD: Pre-allocate collections
public override void OnInit(Frame f)
{
    f.GetOrAddSingleton<RaceManager>();
    if (f.Unsafe.TryGetPointerSingleton<RaceManager>(out var manager))
    {
        manager->Vehicles = f.AllocateList<EntityRef>();
    }
}

// BAD: Allocating collections during runtime
public override void Update(Frame f)
{
    // Avoid creating new collections each frame
    var newList = new List<EntityRef>();
    // ...
}
```

## Network Synchronization

### 1. Input Prediction Configuration

Optimize input settings in SessionConfig.asset:

```
InputDelayFrames: 2-3 frames for most games
PredictionFrames: 2-3 frames for smooth visual experience
RollbackFrames: 6-12 frames based on expected network conditions
```

### 2. Snapshot Optimization

Balance performance and bandwidth:

```
SnapshotSendRate: 20-30 per second (lower for larger player counts)
InputSendRate: 60 per second for responsive controls
```

### 3. Deterministic RNG

Always use the frame's RNG for random values:

```csharp
// GOOD: Use deterministic RNG
var randomIndex = f.Global->RngSession.Next(0, count);

// BAD: Using non-deterministic random
var randomIndex = UnityEngine.Random.Range(0, count); // NEVER do this!
```

## Physics Optimizations

### 1. Collision Layer Management

Properly configure physics layers to minimize collision checks:

```csharp
// Set specific collision layers
body->Layer = (byte)PhysicsLayer.Vehicle;

// Configure layer collision matrix in physics settings
// Vehicles collide with: Track, Obstacles, Vehicles, Triggers
// But not with: Effects, UI, etc.
```

### 2. Physics Body Types

Use appropriate body types:

```csharp
// Dynamic bodies for vehicles
body->IsKinematic = false;
body->Mass = 2;

// Kinematic bodies for moving platforms/obstacles
trigger->IsKinematic = true;
trigger->IsTrigger = false;

// Trigger volumes for checkpoints and modifiers
checkpoint->IsTrigger = true;
```

### 3. Efficient Collision Shapes

Choose optimal collision shapes:

```csharp
// For vehicles: Use circle or capsule shapes
var collider = new CircleCollider2D() {
    Center = FPVector2.Zero,
    Radius = FP._0_50
};

// For track pieces: Use box or polygon shapes
var trackCollider = new BoxCollider2D() {
    Size = new FPVector2(10, 1),
    Center = FPVector2.Zero
};

// For complex shapes: Use compound colliders
var compound = new CompoundCollider2D();
compound.Colliders = new List<Collider2D>() {
    new CircleCollider2D() { Center = new FPVector2(0, 1), Radius = FP._0_50 },
    new BoxCollider2D() { Center = FPVector2.Zero, Size = new FPVector2(2, 0.5) }
};
```

## View Synchronization

### 1. Prediction Area Management

Optimize network traffic with precise prediction areas:

```csharp
// In camera controller:
Game.SetPredictionArea(transform.position.ToFPVector3(), 20);

// This ensures only nearby entities are predicted in detail
```

### 2. Entity View Pooling

Implement object pooling for entity views:

```csharp
// In EntityViewPool.cs
private Dictionary<string, Queue<GameObject>> _pools = new Dictionary<string, Queue<GameObject>>();

public GameObject Get(string prefabPath, Transform parent)
{
    if (!_pools.TryGetValue(prefabPath, out var pool))
    {
        pool = new Queue<GameObject>();
        _pools[prefabPath] = pool;
    }

    GameObject obj;
    if (pool.Count > 0)
    {
        obj = pool.Dequeue();
        obj.SetActive(true);
    }
    else
    {
        var prefab = Resources.Load<GameObject>(prefabPath);
        obj = Instantiate(prefab);
    }
    
    obj.transform.SetParent(parent);
    return obj;
}

public void Return(string prefabPath, GameObject obj)
{
    obj.SetActive(false);
    if (!_pools.TryGetValue(prefabPath, out var pool))
    {
        pool = new Queue<GameObject>();
        _pools[prefabPath] = pool;
    }
    pool.Enqueue(obj);
}
```

### 3. LOD Implementation

Implement level of detail for distant vehicles:

```csharp
public class RacerLOD : QuantumEntityViewComponent
{
    public GameObject HighDetailModel;
    public GameObject MediumDetailModel;
    public GameObject LowDetailModel;
    
    private Transform _cameraTransform;
    
    public override void OnActivate(Frame frame)
    {
        _cameraTransform = Camera.main.transform;
    }
    
    public override void OnUpdateView()
    {
        var distance = Vector3.Distance(transform.position, _cameraTransform.position);
        
        HighDetailModel.SetActive(distance < 20f);
        MediumDetailModel.SetActive(distance >= 20f && distance < 50f);
        LowDetailModel.SetActive(distance >= 50f);
    }
}
```

## Asset Loading Optimization

### 1. Asset Bundle Configuration

Organize assets into logical bundles:

```
CarBundle: All vehicle models and configs
TrackBundle: All track pieces and textures
EffectsBundle: All particle effects and sounds
```

### 2. Asset Reference Structure

Structure assets to maximize reuse:

```csharp
// Config container referencing shared assets
public class RacingAssetsConfig : AssetObject
{
    public AssetRef<Material>[] CommonMaterials;
    public AssetRef<AudioClip>[] CommonSounds;
    public AssetRef<ParticleSystem>[] CommonEffects;
}
```

### 3. Addressable Asset System

Use Unity's Addressable Asset System for dynamic loading:

```csharp
// Load track dynamically
async void LoadTrack(string trackName)
{
    var trackHandle = Addressables.LoadAssetAsync<GameObject>(trackName);
    await trackHandle.Task;
    var track = trackHandle.Result;
    Instantiate(track);
}
```

## Performance Profiling

### 1. Quantum Profiling

Enable Quantum's built-in profiling:

```csharp
// In game startup code
QuantumRunner.StartGame(..., new RuntimeConfig {
    DebugFlags = DebugFlags.Profiling
});

// Access profiling data
void DisplayProfilingData()
{
    var game = QuantumRunner.Default.Game;
    var profiler = game.Frames.Verified.Profiler;
    
    Debug.Log($"Simulation time: {profiler.GetDataSafe(ProfilerDataType.Simulate).Average}ms");
    Debug.Log($"Physics time: {profiler.GetDataSafe(ProfilerDataType.Physics).Average}ms");
}
```

### 2. Network Statistics Monitoring

Monitor network performance:

```csharp
void DisplayNetworkStats()
{
    var game = QuantumRunner.Default.Game;
    var stats = game.NetworkStatistics;
    
    Debug.Log($"RTT: {stats.RTT}ms");
    Debug.Log($"Received: {stats.BytesReceived} bytes");
    Debug.Log($"Sent: {stats.BytesSent} bytes");
}
```

### 3. Frame Debugging

Debug specific frames when issues occur:

```csharp
public override void OnRollback(QuantumGame game)
{
    Debug.LogWarning($"Rollback occurred at frame {game.Frames.Predicted.Number}");
    
    // Dump frame data for analysis
    var dumpPath = $"frame_dump_{game.Frames.Predicted.Number}.json";
    game.DumpFrame(dumpPath, game.Frames.Predicted);
}
```

## Implementation Notes

- **Profile First**: Always identify bottlenecks before optimizing
- **Batch Processing**: Group similar operations for better performance
- **Memory Management**: Minimize allocation in performance-critical paths
- **Physics Layers**: Configure collision matrix to minimize unnecessary checks
- **Network Settings**: Balance prediction frames against input delay
- **Asset Loading**: Use asynchronous loading for non-critical assets
- **LOD Strategies**: Implement level of detail for distant objects
- **Entity Pooling**: Reuse entity views instead of creating/destroying
- **Validate Determinism**: Test with recorded inputs to ensure deterministic behavior

---

# 00-project-overview.md

# Quantum Simple FPS 3.0.0 Project Overview

This document provides a comprehensive overview of the Quantum Simple FPS sample project for Photon Quantum 3.0.0. These notes are structured to help you understand how a multiplayer FPS game is implemented using Quantum's deterministic networking framework.

## Project Structure

The Simple FPS game demonstrates a multiplayer first-person shooter built with Quantum's deterministic networking framework. The project is organized as follows:

### Core Simulation Code (Quantum)
- **Assets/QuantumUser/Simulation**: Contains all the deterministic simulation code
  - `.qtn` files: Quantum DSL files defining the game state
  - System classes: Implement game logic (Player, Weapons, Health, Gameplay)
  - Asset classes: Define configuration for game objects

### Unity View Code
- **Assets/Scripts**: Contains Unity-side view code
  - Player views and animations
  - Weapon models and visual effects
  - UI elements and HUD
  - Input handling for different platforms

## Key Features Demonstrated

1. **FPS Character Controller**: Deterministic first-person movement using Quantum KCC
2. **Weapons System**: Multiple weapon types with different behaviors
3. **Damage System**: Raycast-based shooting with hit detection
4. **Lag Compensation**: Historical state buffering for fair hit detection
5. **Player Respawn System**: Player respawning after death
6. **Match Flow**: Game state management, including skirmish and game phases
7. **Input Handling**: Player input collection and processing

## Documentation Structure

The following documents provide detailed breakdowns of the different systems in the Simple FPS sample:

1. [Input System](01-input-system.md): How player input is defined and processed
2. [Player System](02-player-system.md): Character movement and controls
3. [Weapons System](03-weapons-system.md): Weapons, firing mechanics, and damage
4. [Health System](04-health-system.md): Health management and damage application
5. [Gameplay System](05-gameplay-system.md): Game state, respawning, and statistics
6. [Lag Compensation](06-lag-compensation.md): Techniques for fair hit detection
7. [Pickups System](07-pickups-system.md): Item collection mechanics

Each document contains code examples that demonstrate Quantum patterns and how they're applied in an actual game.

## Architecture Overview

Quantum Simple FPS follows Quantum's core architecture principles:

### Simulation-View Separation

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

- **Simulation**: Deterministic game logic running in Quantum
- **View**: Visual representation in Unity
- **Events**: One-way communication from simulation to view
- **Input**: Player commands sent from view to simulation

### ECS Implementation

The game uses Quantum's Entity Component System:
- **Entities**: Dynamic game objects (players, weapons, pickups)
- **Components**: Data containers attached to entities
- **Systems**: Logic that processes entities with specific components

### Networking Model

The predict/rollback networking model:
- **Prediction**: Each client predicts game state based on local input
- **Rollback**: When actual input arrives, state is corrected if necessary
- **Determinism**: Same input always produces the same output
- **Lag Compensation**: Historical state buffering for fair hit detection

## Core Systems Overview

### Player System
- Processes player input
- Controls character movement using KCC
- Manages player spawning and linking

### Weapons System
- Handles weapon switching
- Implements firing mechanics
- Manages ammo and reloading
- Performs hit detection using raycasts

### Health System
- Tracks player health
- Handles damage application
- Manages temporary immortality after spawn

### Gameplay System
- Controls game state (skirmish, running, finished)
- Manages player respawning
- Tracks player statistics (kills, deaths)
- Handles match flow and win conditions

### Lag Compensation System
- Buffers historical transform data
- Creates proxy entities for lag-compensated shots
- Ensures fair hit detection regardless of network conditions

## How To Use These Notes

- Start with the Project Overview to understand the game's architecture
- Read the Input System documentation to see how player actions are captured
- Follow other documents based on specific systems you're interested in
- Use the code examples as reference when implementing similar systems

The focus is on presenting accurate, error-free code examples that can be directly used as templates for your own Quantum FPS projects.

---

# 01-input-system.md

# Input System in Quantum Simple FPS

This document explains how player input is defined, captured in Unity, transformed into Quantum's deterministic format, and processed in the simulation for the Quantum Simple FPS game.

## Input Definition

In Quantum Simple FPS, the input structure is defined in `Input.qtn`:

```qtn
input
{
    FPVector2 MoveDirection;
    FPVector2 LookRotationDelta;
    byte      InterpolationOffset;
    byte      InterpolationAlphaEncoded;
    byte      Weapon;
    button    Jump;
    button    Fire;
    button    Reload;
    button    Spray;
}
```

Key components of this input structure:
- `MoveDirection`: Character movement direction (normalized 2D vector)
- `LookRotationDelta`: Mouse/controller look rotation change
- `InterpolationOffset/Alpha`: Used for smooth client-side interpolation
- `Weapon`: Selected weapon slot (1-based index)
- Button states: `Jump`, `Fire`, `Reload`, `Spray`

## Input Extensions

The input definition is extended in `Input.cs` to add helper properties:

```csharp
partial struct Input
{
    // The interpolation alpha is encoded to a single byte for bandwidth optimization
    public FP InterpolationAlpha
    {
        get => ((FP)InterpolationAlphaEncoded) / 255;
        set
        {
            FP clamped = FPMath.Clamp(value * 255, 0, 255);
            InterpolationAlphaEncoded = (byte)clamped.AsInt;
        }
    }
}
```

This extension converts between a full FP value and a byte-encoded value to optimize network bandwidth.

## Input Polling in Unity

The input is captured on the Unity side through the `CharacterInputPoller` component. Here's a simplified version of the implementation:

```csharp
namespace QuantumDemo
{
    // Attached to the character view prefab
    public class CharacterInputPoller : QuantumEntityViewComponent
    {
        // Mouse sensitivity settings
        public float MouseHorizontalSensitivity = 0.8f;
        public float MouseVerticalSensitivity = 0.5f;
        
        // Camera reference
        public Transform CameraTransform;
        
        // Input state
        private Vector2 _lookInput;
        private Vector2 _moveInput;
        private float _rotation;
        private int _lastWeaponIndex;
        
        public override void OnActivate(Frame frame)
        {
            // Only poll input for the local player
            var player = frame.Get<Player>(EntityRef);
            if (frame.PlayerIsLocal(player.PlayerRef))
            {
                QuantumCallback.Subscribe(this, (CallbackPollInput callback) => 
                {
                    PollInput(callback);
                });
            }
        }
        
        private void PollInput(CallbackPollInput callback)
        {
            var input = new Input();
            
            // Movement input
            _moveInput.x = UnityEngine.Input.GetAxisRaw("Horizontal");
            _moveInput.y = UnityEngine.Input.GetAxisRaw("Vertical");
            input.MoveDirection = _moveInput.ToFPVector2();
            
            // Look rotation input
            if (Cursor.lockState == CursorLockMode.Locked)
            {
                _lookInput.x = Input.GetAxis("Mouse X") * MouseHorizontalSensitivity;
                _lookInput.y = Input.GetAxis("Mouse Y") * MouseVerticalSensitivity;
            }
            
            // Convert to Quantum's fixed point format
            input.LookRotationDelta = _lookInput.ToFPVector2();
            
            // Button inputs
            input.Jump = Input.GetKey(KeyCode.Space);
            input.Fire = Input.GetMouseButton(0);
            input.Reload = Input.GetKey(KeyCode.R);
            input.Spray = Input.GetMouseButton(1);
            
            // Weapon selection
            if (Input.GetKeyDown(KeyCode.Alpha1)) _lastWeaponIndex = 1;
            if (Input.GetKeyDown(KeyCode.Alpha2)) _lastWeaponIndex = 2;
            if (Input.GetKeyDown(KeyCode.Alpha3)) _lastWeaponIndex = 3;
            if (Input.GetKeyDown(KeyCode.Alpha4)) _lastWeaponIndex = 4;
            
            input.Weapon = (byte)_lastWeaponIndex;
            
            // Interpolation timing
            input.InterpolationOffset = (byte)callback.InterpolationTarget;
            input.InterpolationAlpha = FP.FromFloat_UNSAFE(callback.InterpolationAlpha);
            
            // Send input to Quantum with the Repeatable flag for determinism
            callback.SetInput(input, DeterministicInputFlags.Repeatable);
        }
    }
}
```

Key aspects of this implementation:
1. It only subscribes to input polling for the local player
2. Captures movement from keyboard (WASD/arrows)
3. Captures look rotation from mouse movement
4. Handles weapon selection via number keys
5. Converts Unity floating-point values to Quantum's fixed-point format
6. Sends the input with the `Repeatable` flag to ensure determinism

## Input Processing in Simulation

The input is processed by various systems in the Quantum simulation:

### Player System

The `PlayerSystem` processes movement input to control the character:

```csharp
[Preserve]
public unsafe class PlayerSystem : SystemMainThreadFilter<PlayerSystem.Filter>
{
    public override void Update(Frame frame, ref Filter filter)
    {
        var player = filter.Player;
        if (player->PlayerRef.IsValid == false)
            return;

        var kcc = filter.KCC;
        var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();
        
        // Don't process input when the game is finished
        if (gameplay->State == EGameplayState.Finished)
        {
            kcc->SetInputDirection(FPVector3.Zero);
            return;
        }

        var input = frame.GetPlayerInput(player->PlayerRef);

        if (filter.Health->IsAlive)
        {
            // Apply look rotation
            kcc->AddLookRotation(input->LookRotationDelta.X, input->LookRotationDelta.Y);
            
            // Convert 2D input to 3D movement vector based on current rotation
            kcc->SetInputDirection(kcc->Data.TransformRotation * input->MoveDirection.XOY);
            kcc->SetKinematicSpeed(player->MoveSpeed);

            // Process jump input
            if (input->Jump.WasPressed && kcc->IsGrounded)
            {
                kcc->Jump(FPVector3.Up * player->JumpForce);
            }
        }
        else
        {
            // Dead players don't move
            kcc->SetInputDirection(FPVector3.Zero);
        }
    }

    public struct Filter
    {
        public EntityRef Entity;
        public Player*   Player;
        public Health*   Health;
        public KCC*      KCC;
    }
}
```

The `KCC` (Kinematic Character Controller) handles the actual movement physics, collision detection, and ground checking.

### Weapons System

The `WeaponsSystem` processes weapon-related input:

```csharp
public override void Update(Frame frame, ref Filter filter)
{
    if (filter.Health->IsAlive == false)
        return;
    if (filter.Player->PlayerRef.IsValid == false)
        return;

    var input = frame.GetPlayerInput(filter.Player->PlayerRef);
    var currentWeapon = frame.Unsafe.GetPointer<Weapon>(filter.Weapons->CurrentWeapon);

    UpdateWeaponSwitch(frame, ref filter);
    UpdateReload(frame, ref filter, currentWeapon);

    filter.Weapons->FireCooldown -= frame.DeltaTime;

    // Process weapon selection input
    if (input->Weapon >= 1)
    {
        TryStartWeaponSwitch(frame, ref filter, (byte)(input->Weapon - 1));
    }

    // Process fire input
    if (input->Fire.IsDown)
    {
        TryFire(frame, ref filter, currentWeapon, input->Fire.WasPressed);

        // Cancel after-spawn immortality when player starts shooting
        filter.Health->StopImmortality();
    }

    // Process reload input
    if (input->Reload.IsDown || currentWeapon->ClipAmmo <= 0)
    {
        TryStartReload(frame, ref filter, currentWeapon);
    }
}
```

## Button State Handling

The `button` type in Quantum provides built-in state tracking for input buttons. Each button has the following states:

- `IsDown`: Whether the button is currently pressed
- `WasPressed`: Whether the button was just pressed this frame
- `WasReleased`: Whether the button was just released this frame

These states are automatically updated by Quantum based on the current and previous input values.

## Input Interpolation

The Simple FPS game uses client-side interpolation to create smooth movement. The input structure includes:

- `InterpolationOffset`: Identifies which historical frame to use for interpolation
- `InterpolationAlpha`: Specifies the blend factor between frames

These values are used by the view layer to interpolate between physics states, creating smooth visual movement while maintaining deterministic simulation.

## Best Practices for FPS Input Handling

1. **Separate look and movement**: Process look rotation and movement independently
2. **Use fixed sensitivities**: Apply consistent sensitivity scaling for different input devices
3. **Convert to fixed point early**: Convert Unity floating-point values to Quantum fixed point as soon as possible
4. **Use deterministic flags**: Always set input with the `Repeatable` flag
5. **Process input in systems**: Keep input processing in Quantum systems, not in Unity scripts
6. **Use button state properties**: Use `WasPressed` and `WasReleased` for one-time actions
7. **Handle dead states**: Disable input processing for dead players
8. **Optimize bandwidth**: Use techniques like byte encoding to minimize input size

These practices ensure consistent, deterministic input handling for a responsive FPS experience across all clients, even with network latency.

---

# 02-player-system.md

# Player System in Quantum Simple FPS

This document explains how the Player System is implemented in the Quantum Simple FPS sample project, covering player entity management, movement, and character control.

## Player Component

The player system is built on the `Player` component defined in the Quantum DSL:

```qtn
component Player
{
    FP MoveSpeed;
    FP JumpForce;
    FP CameraOffset;

    [HideInInspector]
    PlayerRef PlayerRef;
}
```

Key properties of the Player component:
- `MoveSpeed`: Base movement speed of the character
- `JumpForce`: Upward force applied when jumping
- `CameraOffset`: Height offset for the camera/eye position
- `PlayerRef`: Reference to the player's network identity

Additionally, players use several standard Quantum components:
- `Transform3D`: Position and rotation in 3D space
- `KCC`: Kinematic Character Controller for movement and physics
- `PhysicsCollider3D`: For collision detection
- `Health`: Health and damage handling
- `Weapons`: Weapon inventory and management

## Player System Implementation

The `PlayerSystem` processes player input and controls the character:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class PlayerSystem : SystemMainThreadFilter<PlayerSystem.Filter>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            var player = filter.Player;
            if (player->PlayerRef.IsValid == false)
                return;

            var kcc = filter.KCC;

            var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();
            if (gameplay->State == EGameplayState.Finished)
            {
                kcc->SetInputDirection(FPVector3.Zero);
                return;
            }

            var input = frame.GetPlayerInput(player->PlayerRef);

            if (filter.Health->IsAlive)
            {
                // Apply look rotation from input
                kcc->AddLookRotation(input->LookRotationDelta.X, input->LookRotationDelta.Y);
                
                // Convert input direction to world space based on current look direction
                kcc->SetInputDirection(kcc->Data.TransformRotation * input->MoveDirection.XOY);
                kcc->SetKinematicSpeed(player->MoveSpeed);

                // Process jump input
                if (input->Jump.WasPressed && kcc->IsGrounded)
                {
                    kcc->Jump(FPVector3.Up * player->JumpForce);
                }
            }
            else
            {
                // Dead players don't move
                kcc->SetInputDirection(FPVector3.Zero);
            }
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Player*   Player;
            public Health*   Health;
            public KCC*      KCC;
        }
    }
}
```

Key aspects of this system:
1. Uses a filter to process only entities with Player, Health, and KCC components
2. Gets input from the player's network identity
3. Processes input differently based on player state (alive/dead)
4. Delegates actual movement to the KCC system

## Movement Processor

The actual movement physics is handled by the `MoveProcessor` which extends Quantum's KCC system:

```csharp
namespace Quantum
{
    public unsafe class MoveProcessor : KCCProcessor, IBeforeMove, IAfterMoveStep
    {
        public FP UpGravity = 15;
        public FP DownGravity = 25;
        public FP GroundAcceleration = 55;
        public FP GroundDeceleration = 25;
        public FP AirAcceleration = 25;
        public FP AirDeceleration = FP._1 + FP._0_20 + FP._0_10;

        public void BeforeMove(KCCContext context, KCCProcessorInfo processorInfo)
        {
            KCCData data = context.KCC->Data;

            // Configure physics settings
            data.MaxGroundAngle = 60;
            data.MaxWallAngle   = 5;
            data.MaxHangAngle   = 30;

            // Apply asymmetric gravity (faster falling than rising)
            data.Gravity = new FPVector3(0, data.RealVelocity.Y >= 0 ? -UpGravity : -DownGravity, 0);

            // Set up dynamic velocity handling
            EnvironmentProcessor.SetDynamicVelocity(context, ref data, 1, GroundDeceleration, AirDeceleration);

            FP acceleration;

            if (data.InputDirection == FPVector3.Zero)
            {
                // No desired move velocity - we are stopping
                acceleration = data.IsGrounded ? GroundDeceleration : AirDeceleration;
            }
            else
            {
                // Moving in a direction - use appropriate acceleration
                acceleration = data.IsGrounded ? GroundAcceleration : AirAcceleration;
            }

            // Apply smooth acceleration
            data.KinematicVelocity = FPVector3.Lerp(
                data.KinematicVelocity, 
                data.InputDirection * data.KinematicSpeed, 
                acceleration * context.Frame.DeltaTime
            );

            context.KCC->Data = data;
        }

        public void AfterMoveStep(KCCContext context, KCCProcessorInfo processorInfo, KCCOverlapInfo overlapInfo)
        {
            // Handle collision response and step up/down logic
            EnvironmentProcessor.ProcessAfterMoveStep(context, processorInfo, overlapInfo);
        }
    }
}
```

Key aspects of the movement processor:
1. Implements `IBeforeMove` and `IAfterMoveStep` interfaces to hook into the KCC pipeline
2. Uses asymmetric gravity for better game feel (fall faster than rise)
3. Applies different acceleration/deceleration values based on state (grounded/air)
4. Uses smooth lerping for acceleration rather than instant velocity changes
5. Delegates environment collision handling to the built-in `EnvironmentProcessor`

## KCC Context Extensions

The `KCCContext` class is extended to implement custom collision filtering based on player health:

```csharp
namespace Quantum
{
    public unsafe partial class KCCContext
    {
        partial void PrepareUserContext()
        {
            ResolveCollision = ResolvePlayerCollision;
        }

        /// <summary>
        /// Custom collision resolution that ignores collisions between players
        /// when one or both are dead.
        /// </summary>
        private bool ResolvePlayerCollision(KCCContext context, Hit3D hit)
        {
            if (context.Entity.IsValid && hit.Entity.IsValid && 
                context.Frame.TryGet(context.Entity, out Health health) && 
                context.Frame.TryGet(hit.Entity, out Health otherHealth))
            {
                return health.IsAlive && otherHealth.IsAlive;
            }

            return true;
        }
    }
}
```

This extension ensures that:
1. Dead players can't block living players
2. Living players can move through dead players
3. All other collisions work normally

## Player Spawning

Player spawning is handled by the `Gameplay` system:

```csharp
private void RespawnPlayer(Frame frame, PlayerRef playerRef)
{
    var players = frame.ResolveDictionary(PlayerData);

    // Despawn old player object if it exists
    var playerEntity = frame.GetPlayerEntity(playerRef);
    if (playerEntity.IsValid)
    {
        frame.Destroy(playerEntity);
    }

    // Don't spawn disconnected players
    if (players.TryGetValue(playerRef, out PlayerData playerData) == false || 
        playerData.IsConnected == false)
        return;

    // Update player data
    playerData.IsAlive = true;
    players[playerRef] = playerData;

    // Get player avatar from runtime player data
    var runtimePlayer = frame.GetPlayerData(playerRef);
    playerEntity = frame.Create(runtimePlayer.PlayerAvatar);

    // Link entity to player
    frame.AddOrGet<Player>(playerEntity, out var player);
    player->PlayerRef = playerRef;

    // Set spawn position and rotation
    var playerTransform = frame.Unsafe.GetPointer<Transform3D>(playerEntity);
    SpawnPointData spawnPoint = GetSpawnPoint(frame);
    playerTransform->Position = spawnPoint.Position;
    playerTransform->Rotation = spawnPoint.Rotation;

    // Initialize look rotation
    var playerKCC = frame.Unsafe.GetPointer<KCC>(playerEntity);
    playerKCC->SetLookRotation(spawnPoint.Rotation.AsEuler.XY);
}
```

Key aspects of player spawning:
1. Destroys any existing player entity for the same player
2. Creates a new entity from the player prototype
3. Links the entity to the player's network identity
4. Places the player at a spawn point
5. Initializes look rotation based on spawn point orientation

## Player View Integration

The Unity-side view code uses an entity view component:

```csharp
namespace QuantumDemo
{
    public class CharacterView : QuantumEntityViewComponent
    {
        // References to child objects
        public Transform CameraRoot;
        public Transform ModelRoot;
        public Animator Animator;
        
        // Animation parameter hashes
        private static readonly int IsRunning = Animator.StringToHash("IsRunning");
        private static readonly int IsJumping = Animator.StringToHash("IsJumping");
        private static readonly int IsDead = Animator.StringToHash("IsDead");
        
        // Interpolation settings
        public float PositionInterpolationSpeed = 15.0f;
        public float RotationInterpolationSpeed = 15.0f;
        
        private Transform _transform;
        private bool _isLocalPlayer;
        
        public override void OnActivate(Frame frame)
        {
            _transform = transform;
            
            // Check if this is the local player
            var player = frame.Get<Player>(EntityRef);
            _isLocalPlayer = frame.PlayerIsLocal(player.PlayerRef);
            
            // Set up local player camera
            if (_isLocalPlayer)
            {
                // Activate first-person camera
                CameraRoot.gameObject.SetActive(true);
                
                // Hide local player model in first-person view
                ModelRoot.gameObject.SetActive(false);
            }
        }
        
        public override void OnUpdateView()
        {
            var frame = VerifiedFrame;
            if (frame == null) return;
            
            // Get entity components
            var transform3D = frame.Get<Transform3D>(EntityRef);
            var kcc = frame.Get<KCC>(EntityRef);
            var health = frame.Get<Health>(EntityRef);
            
            // Update transform
            _transform.position = Vector3.Lerp(
                _transform.position, 
                transform3D.Position.ToUnityVector3(), 
                Time.deltaTime * PositionInterpolationSpeed
            );
            
            // Update animation parameters
            if (Animator != null)
            {
                Animator.SetBool(IsRunning, kcc.InputDirection.SqrMagnitude > 0.01f);
                Animator.SetBool(IsJumping, !kcc.IsGrounded);
                Animator.SetBool(IsDead, !health.IsAlive);
            }
            
            // For non-local players, update model rotation
            if (!_isLocalPlayer)
            {
                Quaternion targetRotation = transform3D.Rotation.ToUnityQuaternion();
                ModelRoot.rotation = Quaternion.Slerp(
                    ModelRoot.rotation, 
                    targetRotation, 
                    Time.deltaTime * RotationInterpolationSpeed
                );
            }
        }
    }
}
```

Key aspects of the view integration:
1. Different handling for local vs. remote players
2. Smooth interpolation of position and rotation
3. Animation updates based on simulation state
4. First-person camera activation for local player
5. Third-person model shown only for remote players

## Best Practices for FPS Player Implementation

1. **Separate input and physics**: Use a dedicated system to process input and delegate physics to KCC
2. **Use asymmetric gravity**: Faster falling than rising creates better game feel
3. **Smooth acceleration**: Use lerping for smoother movement
4. **Handle player states**: Different behavior for alive/dead states
5. **Custom collision filtering**: Allow players to move through dead bodies
6. **Spawn point management**: Avoid spawning at recently used points
7. **Different local/remote views**: Special handling for the local player's view
8. **Interpolated movement**: Smooth visual movement between simulation steps

These practices ensure responsive player control with deterministic behavior across all clients, while providing suitable visual representation for both local and remote players.

---

# 03-weapons-system.md

# Weapons System in Quantum Simple FPS

This document explains the implementation of the Weapons System in the Quantum Simple FPS sample project, covering weapon management, firing mechanics, and damage handling.

## Weapon Components

The weapons system is built on these components defined in the Quantum DSL:

```qtn
component Weapons
{
    array<asset_ref<EntityPrototype>>[4] WeaponPrototypes;

    LayerMask HitMask;
    FP        WeaponSwitchTime;

    [ExcludeFromPrototype]
    byte      CurrentWeaponId;
    [ExcludeFromPrototype]
    byte      PendingWeaponId;
    [ExcludeFromPrototype]
    FP        FireCooldown;
    [ExcludeFromPrototype]
    FP        ReloadCooldown;
    [ExcludeFromPrototype]
    FP        SwitchCooldown;

    [ExcludeFromPrototype]
    array<EntityRef>[4] WeaponRefs;
}

component Weapon
{
    bool      IsAutomatic;
    int       ClipAmmo;
    int       MaxClipAmmo;
    int       RemainingAmmo;
    int       MaxRemainingAmmo;
    FP        ReloadTime;

    FP        Damage;
    int       FireRate;
    int       ProjectilesPerShot;
    FP        Dispersion;
    FP        MaxHitDistance;

    [ExcludeFromPrototype]
    bool      IsCollected;
    [ExcludeFromPrototype]
    bool      IsReloading;
}
```

Additionally, these signals and events provide communication between simulation and view:

```qtn
signal SwitchWeapon(EntityRef playerEntity, byte weaponId);

event WeaponFired
{
    byte WeaponId;
    EntityRef PlayerEntity;
    bool JustPressed;
    bool IsEmpty;
}

event FireProjectile
{
    byte WeaponId;
    EntityRef PlayerEntity;
    FPVector3 TargetPosition;
    FPVector3 HitNormal;
}

event WeaponSwitchStarted
{
    byte WeaponId;
    EntityRef PlayerEntity;
}

event WeaponReloadStarted
{
    byte WeaponId;
    EntityRef PlayerEntity;
}

synced event DamageInflicted
{
    local player_ref Player;
    bool IsFatal;
    bool IsCritical;
}
```

## Weapons Component Extensions

The `Weapons` component has extensions to simplify access to key state:

```csharp
namespace Quantum
{
    public unsafe partial struct Weapons
    {
        public bool      IsBusy        => IsFiring || IsReloading || IsSwitching;
        public bool      IsFiring      => FireCooldown > 0;
        public bool      IsReloading   => ReloadCooldown > 0;
        public bool      IsSwitching   => SwitchCooldown > 0;
        public EntityRef CurrentWeapon => WeaponRefs[CurrentWeaponId];
    }
}
```

The `Weapon` component also has utility methods:

```csharp
namespace Quantum
{
    public partial struct Weapon
    {
        public bool HasAmmo => ClipAmmo > 0 || RemainingAmmo > 0;

        public bool CanReload()
        {
            if (IsCollected == false)
                return false;

            if (ClipAmmo >= MaxClipAmmo)
                return false;

            return RemainingAmmo > 0;
        }

        public void Reload()
        {
            int reloadAmmo = MaxClipAmmo - ClipAmmo;
            reloadAmmo = Math.Min(reloadAmmo, RemainingAmmo);

            ClipAmmo += reloadAmmo;
            RemainingAmmo -= reloadAmmo;
        }

        public bool CollectOrRefill(int refillAmmo)
        {
            if (IsCollected && RemainingAmmo >= MaxRemainingAmmo)
                return false;

            if (IsCollected)
            {
                // If the weapon is already collected at least refill the ammo
                RemainingAmmo = Math.Min(RemainingAmmo + refillAmmo, MaxRemainingAmmo);
            }
            else
            {
                // Weapon is already present inside Player prefab,
                // marking it as IsCollected is all that is needed
                IsCollected = true;
            }

            return true;
        }
    }
}
```

## Weapons System Implementation

The `WeaponsSystem` handles weapon switching, reloading, and firing:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class WeaponsSystem : SystemMainThreadFilter<WeaponsSystem.Filter>,
        ISignalOnComponentAdded<Weapons>, ISignalOnComponentRemoved<Weapons>,
        ISignalSwitchWeapon
    {
        private const ushort _headShapeUserTag = 1;
        private const ushort _limbShapeUserTag = 2;

        public override void Update(Frame frame, ref Filter filter)
        {
            if (filter.Health->IsAlive == false)
                return;
            if (filter.Player->PlayerRef.IsValid == false)
                return;

            var input = frame.GetPlayerInput(filter.Player->PlayerRef);
            var currentWeapon = frame.Unsafe.GetPointer<Weapon>(filter.Weapons->CurrentWeapon);

            UpdateWeaponSwitch(frame, ref filter);
            UpdateReload(frame, ref filter, currentWeapon);

            filter.Weapons->FireCooldown -= frame.DeltaTime;

            if (input->Weapon >= 1)
            {
                TryStartWeaponSwitch(frame, ref filter, (byte)(input->Weapon - 1));
            }

            if (input->Fire.IsDown)
            {
                TryFire(frame, ref filter, currentWeapon, input->Fire.WasPressed);

                // Cancel after-spawn immortality when player starts shooting
                filter.Health->StopImmortality();
            }

            if (input->Reload.IsDown || currentWeapon->ClipAmmo <= 0)
            {
                TryStartReload(frame, ref filter, currentWeapon);
            }
        }

        private void TryStartWeaponSwitch(Frame frame, ref Filter filter, byte weaponId)
        {
            if (weaponId == filter.Weapons->PendingWeaponId)
                return;

            var weaponRef = filter.Weapons->WeaponRefs[weaponId];
            if (weaponRef.IsValid == false)
                return;

            var weapon = frame.Unsafe.GetPointer<Weapon>(weaponRef);
            if (weapon->IsCollected == false)
                return;

            filter.Weapons->PendingWeaponId = weaponId;
            filter.Weapons->SwitchCooldown = filter.Weapons->WeaponSwitchTime;

            // Stop reload
            filter.Weapons->ReloadCooldown = 0;

            frame.Events.WeaponSwitchStarted(weaponId, filter.Entity);
        }

        private void UpdateWeaponSwitch(Frame frame, ref Filter filter)
        {
            filter.Weapons->SwitchCooldown -= frame.DeltaTime;

            // Switch already completed
            if (filter.Weapons->PendingWeaponId == filter.Weapons->CurrentWeaponId)
                return;

            // Switching too quickly
            if (filter.Weapons->SwitchCooldown > filter.Weapons->WeaponSwitchTime * FP._0_50)
                return;

            // In the middle of the switch we already switch the current weapon
            // but player won't be able to shoot until the switch cooldown expires
            filter.Weapons->CurrentWeaponId = filter.Weapons->PendingWeaponId;
        }

        private void TryStartReload(Frame frame, ref Filter filter, Weapon* weapon)
        {
            if (filter.Weapons->IsBusy)
                return;
            if (weapon->CanReload() == false)
                return;

            filter.Weapons->ReloadCooldown = weapon->ReloadTime;

            frame.Events.WeaponReloadStarted(filter.Weapons->CurrentWeaponId, filter.Entity);
        }

        private void UpdateReload(Frame frame, ref Filter filter, Weapon* weapon)
        {
            if (filter.Weapons->IsReloading == false)
                return;

            filter.Weapons->ReloadCooldown -= frame.DeltaTime;

            if (filter.Weapons->IsReloading == false)
            {
                weapon->Reload();

                // Add small prepare time after reload
                filter.Weapons->FireCooldown = FP._0_25;
            }
        }

        private void TryFire(Frame frame, ref Filter filter, Weapon* weapon, bool justPressed)
        {
            if (filter.Weapons->IsBusy)
                return;
            if (weapon->IsCollected == false)
                return;
            if (justPressed == false && weapon->IsAutomatic == false)
                return;

            filter.Weapons->FireCooldown = (FP)60 / weapon->FireRate;

            if (weapon->ClipAmmo <= 0)
            {
                frame.Events.WeaponFired(filter.Weapons->CurrentWeaponId, filter.Entity, justPressed, true);
                return;
            }

            frame.Events.WeaponFired(filter.Weapons->CurrentWeaponId, filter.Entity, justPressed, false);

            var firePosition = filter.KCC->Data.TargetPosition + filter.Player->CameraOffset * FPVector3.Up;
            var fireRotation = FPQuaternion.LookRotation(filter.KCC->Data.LookDirection);

            DamageData damageData = default;

            for (int i = 0; i < weapon->ProjectilesPerShot; i++)
            {
                var projectileRotation = fireRotation;

                if (weapon->Dispersion > 0)
                {
                    // We use unit sphere on purpose -> non-uniform distribution (more projectiles in the center)
                    var dispersionRotation = FPQuaternion.Euler(RandomInsideUnitCircleNonUniform(frame).XYO * weapon->Dispersion);
                    projectileRotation = fireRotation * dispersionRotation;
                }

                FireProjectile(frame, ref filter, firePosition, projectileRotation * FPVector3.Forward, weapon->MaxHitDistance, weapon->Damage, ref damageData);
            }

            if (damageData.TotalDamage > 0)
            {
                frame.Events.DamageInflicted(filter.Player->PlayerRef, damageData.IsFatal, damageData.IsCritical);
            }

            weapon->ClipAmmo--;
        }

        private void FireProjectile(Frame frame, ref Filter filter, FPVector3 fromPosition, FPVector3 direction, FP maxDistance, FP damage, ref DamageData damageData)
        {
            // Use default layer mask + add lag compensation proxy layer mask based on PlayerRef
            var hitMask = filter.Weapons->HitMask;
            hitMask.BitMask |= LagCompensationUtility.GetProxyCollisionLayerMask(filter.Player->PlayerRef);

            var options = QueryOptions.HitAll | QueryOptions.ComputeDetailedInfo;
            var nullableHit = frame.Physics3D.Raycast(fromPosition, direction, maxDistance, hitMask, options);

            if (nullableHit.HasValue == false)
            {
                // No surface was hit, show projectile visual flying to dummy distant point
                var distantPoint = fromPosition + direction * maxDistance;
                frame.Events.FireProjectile(filter.Weapons->CurrentWeaponId, filter.Entity, distantPoint, FPVector3.Zero);
                return;
            }

            Hit3D hit = nullableHit.Value;

            if (frame.Unsafe.TryGetPointer(hit.Entity, out LagCompensationProxy* lagCompensationProxy))
            {
                // Lag compensation proxy was hit, switching hit entity to its origin entity
                hit.SetHitEntity(lagCompensationProxy->Target);
            }

            // When hitting dynamic colliders (players), hit normal is set to zero and hit impact won't be shown
            var hitNormal = hit.IsDynamic ? FPVector3.Zero : hit.Normal;
            frame.Events.FireProjectile(filter.Weapons->CurrentWeaponId, filter.Entity, hit.Point, hitNormal);

            if (frame.Unsafe.TryGetPointer(hit.Entity, out Health* health) == false)
                return;

            // Hitting different shapes on player body can result in different damage multipliers
            #pragma warning disable 0618
            if (hit.ShapeUserTag == _headShapeUserTag)
            {
                damage *= FP._2;
                damageData.IsCritical = true;
            }
            else if (hit.ShapeUserTag == _limbShapeUserTag)
            {
                damage *= FP._0_50;
            }
            #pragma warning restore 0618

            // At the end of gameplay the damage is doubled
            if (frame.GetSingleton<Gameplay>().IsDoubleDamageActive)
            {
                damage *= 2;
            }

            FP damageDone = health->ApplyDamage(damage);
            if (damageDone > 0)
            {
                damageData.TotalDamage += damageDone;

                if (health->IsAlive == false && frame.Unsafe.TryGetPointer(hit.Entity, out Player* victim))
                {
                    frame.Signals.PlayerKilled(filter.Player->PlayerRef, victim->PlayerRef, filter.Weapons->CurrentWeaponId, false);
                    damageData.IsFatal = true;
                }

                frame.Events.DamageReceived(hit.Entity, hit.Point, hit.Normal);
            }
        }

        void ISignalOnComponentAdded<Weapons>.OnAdded(Frame frame, EntityRef entity, Weapons* component)
        {
            // Prepare player weapons
            for (int i = 0; i < component->WeaponPrototypes.Length; i++)
            {
                var prototype = component->WeaponPrototypes[i];
                if (prototype.IsValid == false)
                    continue;

                component->WeaponRefs[i] = frame.Create(prototype);
            }

            // First weapon is automatically collected
            var currentWeapon = frame.Unsafe.GetPointer<Weapon>(component->CurrentWeapon);
            currentWeapon->IsCollected = true;
        }

        void ISignalOnComponentRemoved<Weapons>.OnRemoved(Frame frame, EntityRef entity, Weapons* component)
        {
            // Destroy player weapons
            for (int i = 0; i < component->WeaponRefs.Length; i++)
            {
                frame.Destroy(component->WeaponRefs[i]);
            }
        }

        void ISignalSwitchWeapon.SwitchWeapon(Frame frame, EntityRef playerEntity, byte weaponId)
        {
            var filter = new Filter
            {
                Entity = playerEntity,
                Weapons = frame.Unsafe.GetPointer<Weapons>(playerEntity),
            };

            TryStartWeaponSwitch(frame, ref filter, weaponId);
        }

        private static FPVector2 RandomInsideUnitCircleNonUniform(Frame frame)
        {
            FP radius = frame.RNG->Next();
            FP angle  = frame.RNG->Next() * 2 * FP.Pi;

            return new FPVector2(radius * FPMath.Cos(angle), radius * FPMath.Sin(angle));
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Player*   Player;
            public Weapons*  Weapons;
            public Health*   Health;
            public KCC*      KCC;
        }

        private struct DamageData
        {
            public FP TotalDamage;
            public bool IsCritical;
            public bool IsFatal;
        }
    }
}
```

Key aspects of the weapons system:
1. Uses a filter to process only entities with Player, Weapons, Health, and KCC components
2. Handles weapon initialization when a Weapons component is added
3. Manages weapon state (switching, reloading, firing)
4. Implements raycast-based shooting with hit detection
5. Applies damage to hit entities
6. Supports shotgun-like multiple projectiles with dispersion
7. Implements different damage multipliers for different body parts
8. Integrates with lag compensation for fair hit detection

## Weapon Pickup System

Weapons can be collected through the `PickupSystem`:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class PickupSystem : SystemMainThreadFilter<PickupSystem.Filter>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            filter.Pickup->Cooldown -= frame.DeltaTime;

            if (filter.Pickup->Cooldown <= 0)
            {
                if (filter.Trigger->OverlapCount > 0)
                {
                    EntityRef overlapEntity = filter.Trigger->GetOverlappingEntity(0);
                    
                    if (frame.Unsafe.TryGetPointer<Weapons>(overlapEntity, out var weapons))
                    {
                        if (filter.Pickup->Settings.IsWeapon)
                        {
                            var weaponPickup = filter.Pickup->Settings.Weapon;
                            var weaponRef = weapons->WeaponRefs[weaponPickup.WeaponID];
                            
                            if (frame.Unsafe.TryGetPointer<Weapon>(weaponRef, out var weapon))
                            {
                                if (weapon->CollectOrRefill(weaponPickup.RefillAmmo))
                                {
                                    // If player doesn't have this weapon selected, switch to it
                                    if (weapons->CurrentWeaponId != weaponPickup.WeaponID)
                                    {
                                        frame.Signals.SwitchWeapon(overlapEntity, weaponPickup.WeaponID);
                                    }
                                    
                                    // Apply pickup cooldown
                                    filter.Pickup->Cooldown = filter.Pickup->PickupCooldown;
                                    
                                    // Trigger pickup event
                                    frame.Events.WeaponPickedUp(filter.Entity, overlapEntity);
                                }
                            }
                        }
                        else if (filter.Pickup->Settings.IsHealth)
                        {
                            var healthPickup = filter.Pickup->Settings.Health;
                            
                            if (frame.Unsafe.TryGetPointer<Health>(overlapEntity, out var health))
                            {
                                if (health->AddHealth(healthPickup.Heal))
                                {
                                    // Apply pickup cooldown
                                    filter.Pickup->Cooldown = filter.Pickup->PickupCooldown;
                                    
                                    // Trigger pickup event
                                    frame.Events.HealthPickedUp(filter.Entity, overlapEntity);
                                }
                            }
                        }
                    }
                }
            }
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Pickup*  Pickup;
            public PhysicsCollider3D* Collider;
            public Trigger3D* Trigger;
        }
    }
}
```

## Weapon View Integration

The Unity-side view code uses event subscriptions to visualize weapon actions:

```csharp
namespace QuantumDemo
{
    public class WeaponView : QuantumMonoBehaviour
    {
        // References
        public WeaponType WeaponType;
        public Transform WeaponModel;
        public ParticleSystem MuzzleFlash;
        public TrailRenderer BulletTrail;
        public AudioSource FireSound;
        public AudioSource EmptySound;
        public AudioSource ReloadSound;
        
        // Internal state
        private bool _isLocal;
        private EntityRef _playerEntity;
        private CharacterView _characterView;
        
        private void OnEnable()
        {
            // Subscribe to weapon events
            QuantumEvent.Subscribe<EventWeaponFired>(this, OnWeaponFired);
            QuantumEvent.Subscribe<EventFireProjectile>(this, OnFireProjectile);
            QuantumEvent.Subscribe<EventWeaponReloadStarted>(this, OnWeaponReloadStarted);
        }
        
        private void OnDisable()
        {
            // Unsubscribe from weapon events
            QuantumEvent.Unsubscribe<EventWeaponFired>(this, OnWeaponFired);
            QuantumEvent.Unsubscribe<EventFireProjectile>(this, OnFireProjectile);
            QuantumEvent.Unsubscribe<EventWeaponReloadStarted>(this, OnWeaponReloadStarted);
        }
        
        public void Initialize(EntityRef playerEntity, CharacterView characterView, bool isLocal)
        {
            _playerEntity = playerEntity;
            _characterView = characterView;
            _isLocal = isLocal;
        }
        
        private void OnWeaponFired(EventWeaponFired e)
        {
            if (e.PlayerEntity != _playerEntity || e.WeaponId != (byte)WeaponType)
                return;
                
            if (e.IsEmpty)
            {
                // Play empty sound
                EmptySound.Play();
            }
            else
            {
                // Play fire sound
                FireSound.Play();
                
                // Play muzzle flash effect
                MuzzleFlash.Play();
            }
        }
        
        private void OnFireProjectile(EventFireProjectile e)
        {
            if (e.PlayerEntity != _playerEntity || e.WeaponId != (byte)WeaponType)
                return;
                
            // Show bullet trail
            var muzzlePosition = MuzzleFlash.transform.position;
            var targetPosition = e.TargetPosition.ToUnityVector3();
            
            var trail = Instantiate(BulletTrail, muzzlePosition, Quaternion.identity);
            
            // Set trail positions
            trail.AddPosition(muzzlePosition);
            trail.transform.position = targetPosition;
            
            // Show impact effect if hit normal is not zero (environment hit)
            if (e.HitNormal != FPVector3.Zero)
            {
                // Create impact effect at hit point
                // using hit normal for rotation
                var rotation = Quaternion.FromToRotation(Vector3.up, e.HitNormal.ToUnityVector3());
                Instantiate(ImpactEffectPrefab, targetPosition, rotation);
            }
        }
        
        private void OnWeaponReloadStarted(EventWeaponReloadStarted e)
        {
            if (e.PlayerEntity != _playerEntity || e.WeaponId != (byte)WeaponType)
                return;
                
            // Play reload sound
            ReloadSound.Play();
        }
    }
}
```

## Weapon Switching UI

The weapon switching is visualized using a UI component:

```csharp
namespace QuantumDemo
{
    public class WeaponSwitchUI : QuantumMonoBehaviour
    {
        public GameObject[] WeaponSlots;
        public Text AmmoText;
        
        private EntityRef _playerEntity;
        
        public void Initialize(EntityRef playerEntity)
        {
            _playerEntity = playerEntity;
            
            // Subscribe to weapon switch events
            QuantumEvent.Subscribe<EventWeaponSwitchStarted>(this, OnWeaponSwitchStarted);
        }
        
        public void OnDestroy()
        {
            QuantumEvent.Unsubscribe<EventWeaponSwitchStarted>(this, OnWeaponSwitchStarted);
        }
        
        private void OnWeaponSwitchStarted(EventWeaponSwitchStarted e)
        {
            if (e.PlayerEntity != _playerEntity)
                return;
                
            // Update UI to show the selected weapon
            for (int i = 0; i < WeaponSlots.Length; i++)
            {
                WeaponSlots[i].SetActive(i == e.WeaponId);
            }
        }
        
        public void Update()
        {
            if (!QuantumRunner.Default.Game.TryGetFrameLocal(out var frame))
                return;
                
            if (!frame.TryGet(_playerEntity, out Weapons weapons))
                return;
                
            // Get current weapon
            var currentWeaponRef = weapons.WeaponRefs[weapons.CurrentWeaponId];
            if (!frame.TryGet(currentWeaponRef, out Weapon currentWeapon))
                return;
                
            // Update ammo text
            AmmoText.text = $"{currentWeapon.ClipAmmo} / {currentWeapon.RemainingAmmo}";
        }
    }
}
```

## Best Practices for FPS Weapon Implementation

1. **Weapon state management**: Track cooldowns for firing, reloading, and switching
2. **Raycast-based shooting**: Use raycasts with proper layer masks for hit detection
3. **Lag compensation integration**: Add proxy layer masks for fair hit detection
4. **Damage multipliers for body parts**: Apply different damage based on hit location
5. **Weapon switching logic**: Allow switching only to collected weapons
6. **Event-based feedback**: Use events to communicate with the view layer
7. **Ammo management**: Track clip ammo and reserve ammo separately
8. **Weapon collection system**: Allow players to pick up weapons and ammo
9. **Support for different weapon types**: Automatic/semi-automatic fire modes, dispersion, fire rate
10. **Visual effects**: Muzzle flash, bullet trails, impact effects

These practices ensure consistent weapon behavior across all clients while providing appropriate visual feedback to players. The systems are designed to be deterministic, ensuring that shots hit the same targets for all players regardless of network conditions.

---

# 04-health-system.md

# Health System in Quantum Simple FPS

This document explains the implementation of the Health System in the Quantum Simple FPS sample project, covering health management, damage application, and player death handling.

## Health Component

The health system is built on the `Health` component defined in the Quantum DSL:

```qtn
component Health
{
    FP MaxHealth;
    FP SpawnImmortalityTime;

    [ExcludeFromPrototype]
    FP CurrentHealth;
    [ExcludeFromPrototype]
    FP ImmortalityCooldown;
}

event DamageReceived
{
    EntityRef Entity;
    FPVector3 HitPoint;
    FPVector3 HitNormal;
}
```

Key properties of the Health component:
- `MaxHealth`: Maximum health value for the entity
- `SpawnImmortalityTime`: Temporary invulnerability period after spawning
- `CurrentHealth`: Current health value (runtime)
- `ImmortalityCooldown`: Countdown for temporary invulnerability

## Health Component Extensions

The `Health` component has extensions to provide utility methods and properties:

```csharp
namespace Quantum
{
    public partial struct Health
    {
        // Properties
        public bool IsAlive => CurrentHealth > 0;
        public bool IsImmortal => ImmortalityCooldown > 0;

        // Methods
        public FP ApplyDamage(FP damage)
        {
            if (CurrentHealth <= 0)
                return 0;

            if (IsImmortal)
                return 0;

            if (damage > CurrentHealth)
            {
                damage = CurrentHealth;
            }

            CurrentHealth -= damage;

            return damage;
        }

        public bool AddHealth(FP health)
        {
            if (CurrentHealth <= 0)
                return false;
            if (CurrentHealth >= MaxHealth)
                return false;

            CurrentHealth = FPMath.Min(CurrentHealth + health, MaxHealth);

            return true;
        }

        public void StopImmortality()
        {
            ImmortalityCooldown = 0;
        }
    }
}
```

Key utility methods:
- `ApplyDamage()`: Safely reduces health by the specified amount
- `AddHealth()`: Increases health up to the maximum
- `StopImmortality()`: Ends temporary invulnerability
- `IsAlive` property: Quick check if entity is alive
- `IsImmortal` property: Check if entity is currently invulnerable

## Health System Implementation

The `HealthSystem` manages health state updates:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class HealthSystem : SystemMainThreadFilter<HealthSystem.Filter>, 
                                       ISignalOnComponentAdded<Health>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            // Update immortality cooldown
            filter.Health->ImmortalityCooldown -= frame.DeltaTime;

            if (filter.Health->ImmortalityCooldown <= 0)
            {
                filter.Health->ImmortalityCooldown = 0;
            }
        }

        void ISignalOnComponentAdded<Health>.OnAdded(Frame frame, EntityRef entity, Health* health)
        {
            // Initialize health values when component is added
            health->CurrentHealth = health->MaxHealth;
            health->ImmortalityCooldown = health->SpawnImmortalityTime;
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Health*   Health;
        }
    }
}
```

The HealthSystem is simple and focused:
1. Tracks and updates the immortality cooldown
2. Initializes health values when a Health component is added to an entity

## Damage Application

Damage is applied to entities through the `ApplyDamage` method on the Health component. This is typically called from the `WeaponsSystem` when a projectile hits an entity:

```csharp
// From WeaponsSystem.FireProjectile method
FP damageDone = health->ApplyDamage(damage);
if (damageDone > 0)
{
    damageData.TotalDamage += damageDone;

    if (health->IsAlive == false && frame.Unsafe.TryGetPointer(hit.Entity, out Player* victim))
    {
        // Signal a kill when target health reaches zero
        frame.Signals.PlayerKilled(filter.Player->PlayerRef, victim->PlayerRef, filter.Weapons->CurrentWeaponId, false);
        damageData.IsFatal = true;
    }

    // Trigger damage visual effect
    frame.Events.DamageReceived(hit.Entity, hit.Point, hit.Normal);
}
```

The damage system includes these key features:
1. Damage reduction based on body part hit (head = 2x damage, limbs = 0.5x damage)
2. Game state-based damage multipliers (e.g., double damage in final phase)
3. Immortality periods after spawning
4. Kill detection and scoring

## Health Pickups

Health can be restored through pickups:

```qtn
struct HealthPickup
{
    FP Heal;
}
```

The pickup system handles health restoration:

```csharp
// From PickupSystem.Update method
if (filter.Pickup->Settings.IsHealth)
{
    var healthPickup = filter.Pickup->Settings.Health;
    
    if (frame.Unsafe.TryGetPointer<Health>(overlapEntity, out var health))
    {
        if (health->AddHealth(healthPickup.Heal))
        {
            // Apply pickup cooldown
            filter.Pickup->Cooldown = filter.Pickup->PickupCooldown;
            
            // Trigger pickup event
            frame.Events.HealthPickedUp(filter.Entity, overlapEntity);
        }
    }
}
```

## Death Handling

When a player's health reaches zero, several systems are triggered:

1. **Kill Signal**: The `PlayerKilled` signal is sent by the WeaponsSystem

```csharp
frame.Signals.PlayerKilled(filter.Player->PlayerRef, victim->PlayerRef, filter.Weapons->CurrentWeaponId, false);
```

2. **Score Update**: The GameplaySystem handles the signal and updates statistics

```csharp
void ISignalPlayerKilled.PlayerKilled(Frame frame, PlayerRef killerPlayerRef, PlayerRef victimPlayerRef, byte weaponType, QBoolean isCriticalKill)
{
    var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();
    var players = frame.ResolveDictionary(gameplay->PlayerData);

    // Update statistics of the killer player
    if (players.TryGetValue(killerPlayerRef, out PlayerData killerData))
    {
        killerData.Kills++;
        killerData.LastKillFrame = frame.Number;
        players[killerPlayerRef] = killerData;
    }

    // Update statistics of the victim player
    if (players.TryGetValue(victimPlayerRef, out PlayerData playerData))
    {
        playerData.Deaths++;
        playerData.IsAlive = false;
        playerData.RespawnTimer = gameplay->PlayerRespawnTime;
        players[victimPlayerRef] = playerData;
    }

    frame.Events.PlayerKilled(killerPlayerRef, victimPlayerRef, weaponType, isCriticalKill);

    gameplay->RecalculateStatisticPositions(frame);
}
```

3. **Respawn Timer**: The GameplaySystem starts a respawn timer for the killed player

4. **Visual Effects**: The `PlayerKilled` event is sent to the view layer for death animations

## Player Respawning

Respawning is handled by the GameplaySystem:

```csharp
public void TryRespawnPlayers(Frame frame)
{
    var players = frame.ResolveDictionary(PlayerData);
    foreach (var playerPair in players)
    {
        var playerData = playerPair.Value;
        if (playerData.RespawnTimer <= 0)
            continue;

        playerData.RespawnTimer -= frame.DeltaTime;
        players[playerData.PlayerRef] = playerData;

        if (playerData.RespawnTimer <= 0)
        {
            RespawnPlayer(frame, playerPair.Key);
        }
    }
}

private void RespawnPlayer(Frame frame, PlayerRef playerRef)
{
    var players = frame.ResolveDictionary(PlayerData);

    // Despawn old player object if it exists
    var playerEntity = frame.GetPlayerEntity(playerRef);
    if (playerEntity.IsValid)
    {
        frame.Destroy(playerEntity);
    }

    // Don't spawn for disconnected clients
    if (players.TryGetValue(playerRef, out PlayerData playerData) == false || 
        playerData.IsConnected == false)
        return;

    // Update player data
    playerData.IsAlive = true;
    players[playerRef] = playerData;

    // Create new player entity
    var runtimePlayer = frame.GetPlayerData(playerRef);
    playerEntity = frame.Create(runtimePlayer.PlayerAvatar);

    // Link entity to player
    frame.AddOrGet<Player>(playerEntity, out var player);
    player->PlayerRef = playerRef;

    // Set spawn position
    var playerTransform = frame.Unsafe.GetPointer<Transform3D>(playerEntity);
    SpawnPointData spawnPoint = GetSpawnPoint(frame);
    playerTransform->Position = spawnPoint.Position;
    playerTransform->Rotation = spawnPoint.Rotation;

    // Initialize look rotation
    var playerKCC = frame.Unsafe.GetPointer<KCC>(playerEntity);
    playerKCC->SetLookRotation(spawnPoint.Rotation.AsEuler.XY);
}
```

When a player respawns:
1. The old player entity is destroyed
2. A new entity is created from the player's avatar prototype
3. The new entity is linked to the player
4. The player is positioned at a spawn point
5. The health component is initialized with full health and temporary immortality

## Health View Integration

The Unity-side view code visualizes health and damage:

```csharp
namespace QuantumDemo
{
    public class HealthView : QuantumEntityViewComponent
    {
        // References
        public Animator Animator;
        public ParticleSystem BloodEffect;
        public AudioSource HitSound;
        public AudioSource DeathSound;
        
        // Animation parameter hashes
        private static readonly int IsDead = Animator.StringToHash("IsDead");
        
        // UI elements
        public Slider HealthBar;
        public Image DamageOverlay;
        
        // Previous health value for detecting changes
        private FP _lastHealth;
        
        // Local player reference
        private bool _isLocalPlayer;
        
        public override void OnActivate(Frame frame)
        {
            var player = frame.Get<Player>(EntityRef);
            _isLocalPlayer = Game.PlayerIsLocal(player.PlayerRef);
            
            // Only show UI for local player
            if (HealthBar != null)
            {
                HealthBar.gameObject.SetActive(_isLocalPlayer);
            }
            
            if (DamageOverlay != null)
            {
                DamageOverlay.gameObject.SetActive(_isLocalPlayer);
            }
            
            // Subscribe to damage events
            QuantumEvent.Subscribe<EventDamageReceived>(this, OnDamageReceived);
        }
        
        public override void OnDeactivate()
        {
            QuantumEvent.Unsubscribe<EventDamageReceived>(this, OnDamageReceived);
        }
        
        public override void OnUpdateView()
        {
            var frame = VerifiedFrame;
            if (frame == null) return;
            
            if (!frame.TryGet(EntityRef, out Health health))
                return;
                
            // Update death state
            Animator.SetBool(IsDead, !health.IsAlive);
            
            // Update health bar for local player
            if (_isLocalPlayer && HealthBar != null)
            {
                HealthBar.value = health.CurrentHealth.AsFloat / health.MaxHealth.AsFloat;
                
                // Fade damage overlay based on health
                if (DamageOverlay != null)
                {
                    float targetAlpha = 1.0f - (health.CurrentHealth.AsFloat / health.MaxHealth.AsFloat);
                    Color color = DamageOverlay.color;
                    color.a = Mathf.Lerp(0.0f, 0.8f, targetAlpha);
                    DamageOverlay.color = color;
                }
            }
            
            // Detect health decrease for non-local players
            if (!_isLocalPlayer && health.CurrentHealth < _lastHealth)
            {
                // Play hit effect
                BloodEffect.Play();
                HitSound.Play();
            }
            
            _lastHealth = health.CurrentHealth;
        }
        
        private void OnDamageReceived(EventDamageReceived e)
        {
            if (e.Entity != EntityRef)
                return;
                
            // Play hit effects
            BloodEffect.transform.position = e.HitPoint.ToUnityVector3();
            BloodEffect.Play();
            
            // Play appropriate sound
            if (!VerifiedFrame.TryGet(EntityRef, out Health health))
                return;
                
            if (health.IsAlive)
            {
                HitSound.Play();
            }
            else
            {
                DeathSound.Play();
            }
        }
    }
}
```

Key aspects of the health visualization:
1. Different handling for local vs. remote players
2. Health bar and damage overlay for local player
3. Blood effects and sounds for all players
4. Separate sounds for hits vs. deaths
5. Animation updates based on alive/dead state

## Best Practices for FPS Health Implementation

1. **Immortality periods**: Temporary invulnerability after spawning prevents spawn-killing
2. **Health clamping**: Ensure health stays within valid ranges
3. **Death detection**: Signal player death to trigger respawn and scoring
4. **Health feedback**: Visual feedback for damage and healing
5. **Local player UI**: Only show health UI elements for the local player
6. **Cancellable immortality**: Option to end immortality when player starts shooting
7. **Damage modifiers**: Different damage based on body part hit
8. **Clean separation**: Health logic separated from visual representation
9. **Health restoration**: Pickups that restore health without exceeding maximum
10. **Respawn system**: Clean player recreation after death

These practices ensure consistent health management across all clients while providing appropriate visual feedback to players. The health system is designed to be fair and deterministic, with special attention to gameplay feel through features like temporary spawn protection.

---

# 05-gameplay-system.md

# Gameplay System in Quantum Simple FPS

This document explains the implementation of the Gameplay System in the Quantum Simple FPS sample project, covering game state management, player statistics, respawning, and match flow.

## Gameplay Components

The gameplay system is built on a singleton component and supporting types defined in the Quantum DSL:

```qtn
singleton component Gameplay
{
    EGameplayState State;
    FP             GameDuration;
    FP             DoubleDamageDuration;
    FP             PlayerRespawnTime;
    FP             RemainingTime;

    [AllocateOnComponentAdded, FreeOnComponentRemoved, ExcludeFromPrototype]
    list<int> RecentSpawnPoints;

    [AllocateOnComponentAdded, FreeOnComponentRemoved]
    dictionary<PlayerRef, PlayerData> PlayerData;
}

enum EGameplayState
{
    Skirmish,
    Running,
    Finished,
}

struct PlayerData
{
    PlayerRef PlayerRef;
    FP        RespawnTimer;
    int       Kills;
    int       Deaths;
    int       LastKillFrame;
    int       StatisticPosition;
    bool      IsAlive;
    bool      IsConnected;
}

signal PlayerKilled(PlayerRef killerPlayerRef, PlayerRef victimPlayerRef, Byte weaponType, Boolean isCriticalKill);

synced event PlayerKilled
{
    PlayerRef KillerPlayerRef;
    PlayerRef VictimPlayerRef;
    Byte WeaponType;
    Boolean IsCriticalKill;
}

synced event GameplayStateChanged
{
	EGameplayState State;
}
```

Additionally, the `GameplayData` asset stores gameplay configuration:

```csharp
public class GameplayData : AssetObject
{
    public SpawnPointData[] SpawnPoints;
}

[Serializable]
public struct SpawnPointData
{
    public FPVector3    Position;
    public FPQuaternion Rotation;
}
```

## Gameplay Extensions

The Gameplay component has extensions to provide utility methods and properties:

```csharp
namespace Quantum
{
    public unsafe partial struct Gameplay
    {
        public bool IsDoubleDamageActive => State == EGameplayState.Running && RemainingTime < DoubleDamageDuration;

        // Additional methods implemented here
    }
}
```

Key properties:
- `IsDoubleDamageActive`: Indicates the final phase of the match with increased damage

## Gameplay System Implementation

The `GameplaySystem` manages the overall game flow:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class GameplaySystem : SystemMainThread, 
                                         ISignalOnPlayerAdded, 
                                         ISignalOnPlayerRemoved, 
                                         ISignalPlayerKilled
    {
        public override void Update(Frame frame)
        {
            var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();

            // Start gameplay when there are enough players connected
            if (gameplay->State == EGameplayState.Skirmish && frame.ComponentCount<Player>() > 1)
            {
                gameplay->StartGameplay(frame);
            }

            if (gameplay->State == EGameplayState.Running)
            {
                gameplay->RemainingTime -= frame.DeltaTime;

                if (gameplay->RemainingTime <= 0)
                {
                    gameplay->StopGameplay(frame);
                }
            }

            if (gameplay->State != EGameplayState.Finished)
            {
                gameplay->TryRespawnPlayers(frame);
            }
        }

        void ISignalOnPlayerAdded.OnPlayerAdded(Frame frame, PlayerRef playerRef, bool firstTime)
        {
            var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();
            gameplay->ConnectPlayer(frame, playerRef);
        }

        void ISignalOnPlayerRemoved.OnPlayerRemoved(Frame frame, PlayerRef playerRef)
        {
            var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();
            gameplay->DisconnectPlayer(frame, playerRef);
        }

        void ISignalPlayerKilled.PlayerKilled(Frame frame, PlayerRef killerPlayerRef, PlayerRef victimPlayerRef, byte weaponType, QBoolean isCriticalKill)
        {
            var gameplay = frame.Unsafe.GetPointerSingleton<Gameplay>();
            var players = frame.ResolveDictionary(gameplay->PlayerData);

            // Update statistics of the killer player
            if (players.TryGetValue(killerPlayerRef, out PlayerData killerData))
            {
                killerData.Kills++;
                killerData.LastKillFrame = frame.Number;
                players[killerPlayerRef] = killerData;
            }

            // Update statistics of the victim player
            if (players.TryGetValue(victimPlayerRef, out PlayerData playerData))
            {
                playerData.Deaths++;
                playerData.IsAlive = false;
                playerData.RespawnTimer = gameplay->PlayerRespawnTime;
                players[victimPlayerRef] = playerData;
            }

            frame.Events.PlayerKilled(killerPlayerRef, victimPlayerRef, weaponType, isCriticalKill);

            gameplay->RecalculateStatisticPositions(frame);
        }
    }
}
```

Key responsibilities of the GameplaySystem:
1. Managing game state transitions (Skirmish → Running → Finished)
2. Tracking match duration and triggering final phase
3. Handling player connections and disconnections
4. Processing player kills and updating statistics
5. Coordinating player respawning

## Gameplay Component Methods

The Gameplay component has several methods for game flow management:

```csharp
public void ConnectPlayer(Frame frame, PlayerRef playerRef)
{
    var players = frame.ResolveDictionary(PlayerData);

    if (players.TryGetValue(playerRef, out var playerData) == false)
    {
        playerData = new PlayerData();
        playerData.PlayerRef = playerRef;
        playerData.StatisticPosition = int.MaxValue;
        playerData.IsAlive = false;
        playerData.IsConnected = false;
    }

    if (playerData.IsConnected)
        return;

    Log.Warn($"{playerRef} connected.");

    playerData.IsConnected = true;
    players[playerRef] = playerData;

    RespawnPlayer(frame, playerRef);
    RecalculateStatisticPositions(frame);
}

public void DisconnectPlayer(Frame frame, PlayerRef playerRef)
{
    var players = frame.ResolveDictionary(PlayerData);

    if (players.TryGetValue(playerRef, out var playerData))
    {
        if (playerData.IsConnected)
        {
            Log.Warn($"{playerRef} disconnected.");
        }

        playerData.IsConnected = false;
        playerData.IsAlive = false;
        players[playerRef] = playerData;
    }

    var playerEntity = frame.GetPlayerEntity(playerRef);
    if (playerEntity.IsValid)
    {
        frame.Destroy(playerEntity);
    }

    RecalculateStatisticPositions(frame);
}

public void StartGameplay(Frame frame)
{
    SetState(frame, EGameplayState.Running);
    RemainingTime = GameDuration;

    // Reset player data after skirmish and respawn players
    var players = frame.ResolveDictionary(PlayerData);
    foreach (var playerPair in players)
    {
        var playerData = playerPair.Value;

        playerData.RespawnTimer = 0;
        playerData.Kills = 0;
        playerData.Deaths = 0;
        playerData.StatisticPosition = int.MaxValue;

        players[playerData.PlayerRef] = playerData;

        RespawnPlayer(frame, playerData.PlayerRef);
    }
}

public void StopGameplay(Frame frame)
{
    RecalculateStatisticPositions(frame);
    SetState(frame, EGameplayState.Finished);
}

public void TryRespawnPlayers(Frame frame)
{
    var players = frame.ResolveDictionary(PlayerData);
    foreach (var playerPair in players)
    {
        var playerData = playerPair.Value;
        if (playerData.RespawnTimer <= 0)
            continue;

        playerData.RespawnTimer -= frame.DeltaTime;
        players[playerData.PlayerRef] = playerData;

        if (playerData.RespawnTimer <= 0)
        {
            RespawnPlayer(frame, playerPair.Key);
        }
    }
}

public void RecalculateStatisticPositions(Frame frame)
{
    if (State == EGameplayState.Finished)
        return;

    var tempPlayerData = new List<PlayerData>();

    var players = frame.ResolveDictionary(PlayerData);
    foreach (var pair in players)
    {
        tempPlayerData.Add(pair.Value);
    }

    tempPlayerData.Sort((a, b) =>
    {
        if (a.Kills != b.Kills)
            return b.Kills.CompareTo(a.Kills);

        return a.LastKillFrame.CompareTo(b.LastKillFrame);
    });

    for (int i = 0; i < tempPlayerData.Count; i++)
    {
        var playerData = tempPlayerData[i];
        playerData.StatisticPosition = playerData.Kills > 0 ? i + 1 : int.MaxValue;

        players[playerData.PlayerRef] = playerData;
    }
}

private void SetState(Frame frame, EGameplayState state)
{
    State = state;
    frame.Events.GameplayStateChanged(state);
}

private void RespawnPlayer(Frame frame, PlayerRef playerRef)
{
    var players = frame.ResolveDictionary(PlayerData);

    // Despawn old player object if it exists
    var playerEntity = frame.GetPlayerEntity(playerRef);
    if (playerEntity.IsValid)
    {
        frame.Destroy(playerEntity);
    }

    // Don't spawn the player for disconnected clients
    if (players.TryGetValue(playerRef, out PlayerData playerData) == false || 
        playerData.IsConnected == false)
        return;

    // Update player data
    playerData.IsAlive = true;
    players[playerRef] = playerData;

    var runtimePlayer = frame.GetPlayerData(playerRef);
    playerEntity = frame.Create(runtimePlayer.PlayerAvatar);

    frame.AddOrGet<Player>(playerEntity, out var player);
    player->PlayerRef = playerRef;

    var playerTransform = frame.Unsafe.GetPointer<Transform3D>(playerEntity);

    SpawnPointData spawnPoint = GetSpawnPoint(frame);
    playerTransform->Position = spawnPoint.Position;
    playerTransform->Rotation = spawnPoint.Rotation;

    var playerKCC = frame.Unsafe.GetPointer<KCC>(playerEntity);
    playerKCC->SetLookRotation(spawnPoint.Rotation.AsEuler.XY);
}

private SpawnPointData GetSpawnPoint(Frame frame)
{
    var gameplayData = frame.FindAsset<GameplayData>(frame.Map.UserAsset);

    SpawnPointData spawnPointData = default;
    int spawnPointIndex = 0;

    var recentSpawnPoints = frame.ResolveList(RecentSpawnPoints);
    int randomOffset = frame.RNG->Next(0, gameplayData.SpawnPoints.Length);

    // Iterate over all spawn points in the scene
    for (int i = 0; i < gameplayData.SpawnPoints.Length; i++)
    {
        spawnPointIndex = (randomOffset + i) % gameplayData.SpawnPoints.Length;
        spawnPointData = gameplayData.SpawnPoints[spawnPointIndex];

        if (recentSpawnPoints.Contains(spawnPointIndex) == false)
            break;
    }

    // Add spawn point to list of recently used spawn points
    recentSpawnPoints.Add(spawnPointIndex);

    // Ignore only last 3 spawn points
    if (recentSpawnPoints.Count > 3)
    {
        recentSpawnPoints.RemoveAt(0);
    }

    return spawnPointData;
}
```

Key methods of the Gameplay component:
1. `ConnectPlayer()`: Handles player connection and first spawn
2. `DisconnectPlayer()`: Handles player disconnection and cleanup
3. `StartGameplay()`: Transitions from Skirmish to Running state
4. `StopGameplay()`: Transitions to Finished state at the end of the match
5. `TryRespawnPlayers()`: Processes respawn timers and respawns players
6. `RecalculateStatisticPositions()`: Updates player rankings based on kills
7. `RespawnPlayer()`: Handles the actual player respawn process
8. `GetSpawnPoint()`: Selects a spawn point, avoiding recently used ones

## Game States

The game flows through three distinct states:

1. **Skirmish**
   - Initial state when players connect
   - Players can join, fight, and test weapons
   - No score tracking or game timer
   - Transitions to Running when enough players join

2. **Running**
   - Main gameplay phase with timer counting down
   - Score tracking is active
   - Special events may occur (double damage phase)
   - Transitions to Finished when timer expires

3. **Finished**
   - End-of-match state
   - Final scores and winner displayed
   - No more respawning
   - Transitions to Skirmish for next match

## Spawn Point Management

The spawn system implements intelligent spawn point selection:

1. Spawn points are defined in the `GameplayData` asset
2. A list of recently used spawn points is maintained
3. When selecting a spawn point:
   - Start from a random index to avoid predictable spawns
   - Skip recently used spawn points to prevent spawn camping
   - Keep only the last 3 used points in "recent" list

```csharp
private SpawnPointData GetSpawnPoint(Frame frame)
{
    var gameplayData = frame.FindAsset<GameplayData>(frame.Map.UserAsset);

    SpawnPointData spawnPointData = default;
    int spawnPointIndex = 0;

    var recentSpawnPoints = frame.ResolveList(RecentSpawnPoints);
    int randomOffset = frame.RNG->Next(0, gameplayData.SpawnPoints.Length);

    // Iterate over all spawn points in the scene
    for (int i = 0; i < gameplayData.SpawnPoints.Length; i++)
    {
        spawnPointIndex = (randomOffset + i) % gameplayData.SpawnPoints.Length;
        spawnPointData = gameplayData.SpawnPoints[spawnPointIndex];

        if (recentSpawnPoints.Contains(spawnPointIndex) == false)
            break;
    }

    // Add spawn point to list of recently used spawn points
    recentSpawnPoints.Add(spawnPointIndex);

    // Ignore only last 3 spawn points
    if (recentSpawnPoints.Count > 3)
    {
        recentSpawnPoints.RemoveAt(0);
    }

    return spawnPointData;
}
```

## Player Statistics

Player statistics are tracked and used for rankings:

1. **Kills**: Incremented when a player kills another player
2. **Deaths**: Incremented when a player is killed
3. **LastKillFrame**: Timestamp of the player's most recent kill
4. **StatisticPosition**: Player's position in the rankings (1 = first place)

Rankings are updated whenever a kill occurs:

```csharp
public void RecalculateStatisticPositions(Frame frame)
{
    if (State == EGameplayState.Finished)
        return;

    var tempPlayerData = new List<PlayerData>();

    var players = frame.ResolveDictionary(PlayerData);
    foreach (var pair in players)
    {
        tempPlayerData.Add(pair.Value);
    }

    tempPlayerData.Sort((a, b) =>
    {
        if (a.Kills != b.Kills)
            return b.Kills.CompareTo(a.Kills);

        return a.LastKillFrame.CompareTo(b.LastKillFrame);
    });

    for (int i = 0; i < tempPlayerData.Count; i++)
    {
        var playerData = tempPlayerData[i];
        playerData.StatisticPosition = playerData.Kills > 0 ? i + 1 : int.MaxValue;

        players[playerData.PlayerRef] = playerData;
    }
}
```

This ranking system:
1. Sorts players primarily by kills (highest first)
2. Uses LastKillFrame as a tiebreaker (earlier kills win)
3. Requires at least one kill to be ranked

## Special Game Mechanics

The gameplay system implements special mechanics to enhance the experience:

1. **Double Damage Phase**
   - Activates during final countdown (DoubleDamageDuration)
   - All weapon damage is doubled
   - Encourages aggressive play at the end

```csharp
public bool IsDoubleDamageActive => State == EGameplayState.Running && RemainingTime < DoubleDamageDuration;
```

This is checked in the WeaponsSystem when applying damage:

```csharp
// At the end of gameplay the damage is doubled
if (frame.GetSingleton<Gameplay>().IsDoubleDamageActive)
{
    damage *= 2;
}
```

2. **Spawn Protection**
   - Temporary immortality after spawning
   - Prevents spawn-killing
   - Canceled when player starts shooting

```csharp
// In WeaponsSystem.TryFire method
if (input->Fire.IsDown)
{
    TryFire(frame, ref filter, currentWeapon, input->Fire.WasPressed);

    // Cancel after-spawn immortality when player starts shooting
    filter.Health->StopImmortality();
}
```

## Game State Communication

Game state changes are communicated to the view through events:

```csharp
private void SetState(Frame frame, EGameplayState state)
{
    State = state;
    frame.Events.GameplayStateChanged(state);
}
```

The Unity view layer subscribes to these events:

```csharp
namespace QuantumDemo
{
    public class GameplayUI : QuantumMonoBehaviour
    {
        // UI references
        public GameObject SkirmishUI;
        public GameObject RunningUI;
        public GameObject FinishedUI;
        public Text TimerText;
        public GameObject DoubleDamageWarning;
        
        // Player score display
        public Transform ScoreboardContent;
        public GameObject ScoreEntryPrefab;
        
        private void OnEnable()
        {
            // Subscribe to gameplay events
            QuantumEvent.Subscribe<EventGameplayStateChanged>(this, OnGameplayStateChanged);
        }
        
        private void OnDisable()
        {
            QuantumEvent.Unsubscribe<EventGameplayStateChanged>(this, OnGameplayStateChanged);
        }
        
        private void OnGameplayStateChanged(EventGameplayStateChanged e)
        {
            // Update UI based on new state
            SkirmishUI.SetActive(e.State == EGameplayState.Skirmish);
            RunningUI.SetActive(e.State == EGameplayState.Running);
            FinishedUI.SetActive(e.State == EGameplayState.Finished);
            
            if (e.State == EGameplayState.Finished)
            {
                // Display final scores
                UpdateScoreboard();
            }
        }
        
        private void Update()
        {
            if (!QuantumRunner.Default.Game.TryGetFrameLocal(out var frame))
                return;
                
            if (!frame.TryGet<Gameplay>(out var gameplay))
                return;
                
            if (gameplay.State == EGameplayState.Running)
            {
                // Update timer
                int minutes = (int)(gameplay.RemainingTime / 60);
                int seconds = (int)(gameplay.RemainingTime % 60);
                TimerText.text = $"{minutes:00}:{seconds:00}";
                
                // Show double damage warning
                DoubleDamageWarning.SetActive(gameplay.IsDoubleDamageActive);
            }
            
            // Update scoreboard periodically
            if (Time.frameCount % 30 == 0)
            {
                UpdateScoreboard();
            }
        }
        
        private void UpdateScoreboard()
        {
            if (!QuantumRunner.Default.Game.TryGetFrameLocal(out var frame))
                return;
                
            if (!frame.TryGet<Gameplay>(out var gameplay))
                return;
                
            // Clear existing entries
            foreach (Transform child in ScoreboardContent)
            {
                Destroy(child.gameObject);
            }
            
            // Get player data
            var players = frame.ResolveDictionary(gameplay.PlayerData);
            
            // Create sorted list
            var sortedPlayers = new List<PlayerData>();
            foreach (var pair in players)
            {
                sortedPlayers.Add(pair.Value);
            }
            
            // Sort by position
            sortedPlayers.Sort((a, b) => a.StatisticPosition.CompareTo(b.StatisticPosition));
            
            // Create entries
            foreach (var playerData in sortedPlayers)
            {
                if (playerData.StatisticPosition == int.MaxValue)
                    continue;
                    
                var entry = Instantiate(ScoreEntryPrefab, ScoreboardContent);
                var scoreEntry = entry.GetComponent<ScoreEntry>();
                
                // Get player name from SessionManager
                string playerName = SessionManager.Instance.GetPlayerName(playerData.PlayerRef);
                
                scoreEntry.SetData(
                    playerData.StatisticPosition,
                    playerName,
                    playerData.Kills,
                    playerData.Deaths,
                    frame.PlayerIsLocal(playerData.PlayerRef)
                );
            }
        }
    }
}
```

## Best Practices for FPS Gameplay Implementation

1. **State machine architecture**: Clear separation between game states
2. **Singleton game controller**: Centralized gameplay management
3. **Player data dictionary**: Efficient player data lookup by PlayerRef
4. **Advanced spawn logic**: Smart spawn point selection to avoid camping
5. **Score-based ranking**: Real-time player rankings with tiebreakers
6. **Game phases**: Changing mechanics during match (double damage)
7. **Event-based UI updates**: Communicate state changes to view layer
8. **Spawn protection**: Temporary immortality after respawning
9. **Clean player cleanup**: Proper handling of disconnected players
10. **Dynamic game start**: Auto-start when enough players join

These practices ensure a fair and engaging multiplayer experience with clear rules and state transitions. The gameplay system manages the overall game flow while providing appropriate feedback to players about the current state and remaining time.

---

# 06-lag-compensation.md

# Lag Compensation in Quantum Simple FPS

This document explains the implementation of the Lag Compensation system in the Quantum Simple FPS sample project, covering historical state buffering, proxy entities, and fair hit detection.

## Lag Compensation Components

The lag compensation system is built on these components defined in the Quantum DSL:

```qtn
component LagCompensationTarget
{
    AssetRef<EntityPrototype> ProxyPrototype;
    [ExcludeFromPrototype]
    array<Transform3D>[32] Buffer;
    [ExcludeFromPrototype]
    int BufferIndex;
}

component LagCompensationProxy
{
    [ExcludeFromPrototype]
    EntityRef Target;
}
```

These components work together to:
1. Store historical transforms for player entities
2. Create proxy entities for lag-compensated hit detection
3. Map hits on proxy entities back to the original targets

## Lag Compensation Utility

The `LagCompensationUtility` class provides helper methods for the lag compensation systems:

```csharp
namespace Quantum
{
    public static class LagCompensationUtility
    {
        // Collision layers start from 0 and go up to 31 inclusive
        private const int BaseProxyLayer = 24;

        /// <summary>
        /// Gets proxy collision layer based on PlayerRef.
        /// Proxy layer is always in range 24-31.
        /// </summary>
        public static int GetProxyCollisionLayer(PlayerRef playerRef)
        {
            return BaseProxyLayer + (playerRef.Index % 8);
        }

        /// <summary>
        /// Gets proxy collision layer mask based on PlayerRef.
        /// This mask includes only the player's proxy layer.
        /// </summary>
        public static int GetProxyCollisionLayerMask(PlayerRef playerRef)
        {
            return 1 << GetProxyCollisionLayer(playerRef);
        }

        /// <summary>
        /// Get proxy collision layer mask that includes all proxy layers.
        /// </summary>
        public static int GetAllProxyCollisionLayerMask()
        {
            // Layers 24-31 are reserved for lag compensation proxies
            return 0xFF000000;
        }

        /// <summary>
        /// Interpolates transforms between two stored transforms based on alpha.
        /// </summary>
        public static Transform3D InterpolateTransform(Transform3D from, Transform3D to, FP alpha)
        {
            Transform3D result = default;
            result.Position = FPVector3.Lerp(from.Position, to.Position, alpha);
            result.Rotation = FPQuaternion.Slerp(from.Rotation, to.Rotation, alpha);
            result.Scale = FPVector3.Lerp(from.Scale, to.Scale, alpha);
            return result;
        }
    }
}
```

## Early Lag Compensation System

The `EarlyLagCompensationSystem` is responsible for buffering historical transforms of player entities:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class EarlyLagCompensationSystem : SystemMainThreadFilter<EarlyLagCompensationSystem.Filter>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            // Store current transform in the buffer
            var bufferIndex = (filter.LagCompensationTarget->BufferIndex + 1) % filter.LagCompensationTarget->Buffer.Length;
            filter.LagCompensationTarget->Buffer[bufferIndex] = *filter.Transform;
            filter.LagCompensationTarget->BufferIndex = bufferIndex;
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Transform3D* Transform;
            public LagCompensationTarget* LagCompensationTarget;
        }
    }
}
```

This system:
1. Runs every frame for entities with Transform3D and LagCompensationTarget components
2. Captures the current transform and stores it in a circular buffer
3. Updates the buffer index for next frame

The buffer size (32 frames) is carefully chosen to provide enough history for typical network latencies while keeping memory usage reasonable.

## Late Lag Compensation System

The `LateLagCompensationSystem` creates proxy entities for lag-compensated hit detection:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class LateLagCompensationSystem : SystemMainThreadFilter<LateLagCompensationSystem.Filter>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            if (filter.Health->IsAlive == false)
                return;

            // Iterate over all players - create a proxy for each player
            var players = frame.GetComponentIterator<Player>();
            while (players.MoveNext())
            {
                var (playerEntity, player) = players.Current;
                
                // Skip creating proxy for myself
                if (playerEntity == filter.Entity)
                    continue;
                
                if (player.PlayerRef.IsValid == false)
                    continue;

                // Create a proxy entity for this player to use for lag compensation
                // when another player shoots
                if (frame.Has<LagCompensationTarget>(playerEntity) == false)
                    continue;

                var targetLCT = frame.Get<LagCompensationTarget>(playerEntity);

                // Extract player input with interpolation data
                var input = frame.GetPlayerInput(player.PlayerRef);
                var offset = input->InterpolationOffset;
                var alpha = input->InterpolationAlpha;

                // The buffer is circular
                int currentIndex = targetLCT.BufferIndex;
                int pastIndex = (currentIndex - offset + targetLCT.Buffer.Length) % targetLCT.Buffer.Length;

                // Create proxy entity
                var proxyEntity = frame.Create(targetLCT.ProxyPrototype);

                // Link proxy to target
                var proxy = frame.Unsafe.GetPointer<LagCompensationProxy>(proxyEntity);
                proxy->Target = playerEntity;

                // Update proxy collider's layer
                var collider = frame.Unsafe.GetPointer<PhysicsCollider3D>(proxyEntity);
                collider->Layer = LagCompensationUtility.GetProxyCollisionLayer(filter.Player->PlayerRef);

                // Get transform for the proxy
                var proxyTransform = frame.Unsafe.GetPointer<Transform3D>(proxyEntity);

                // In case we don't have enough historical data, use the oldest available transform
                if (offset > currentIndex)
                {
                    *proxyTransform = targetLCT.Buffer[0];
                }
                // Interpolate between two buffered transforms
                else
                {
                    var fromTransform = targetLCT.Buffer[pastIndex];
                    var toTransform = targetLCT.Buffer[(pastIndex + 1) % targetLCT.Buffer.Length];

                    *proxyTransform = LagCompensationUtility.InterpolateTransform(fromTransform, toTransform, alpha);
                }
            }
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Player*   Player;
            public Health*   Health;
        }
    }
}
```

Key aspects of this system:
1. Runs for each player that has a player component
2. For each player, creates proxy entities for all other players
3. Uses the player's input.InterpolationOffset to determine how far back in time to look
4. Interpolates between buffered transforms based on input.InterpolationAlpha
5. Places proxy entities on unique collision layers based on the player's PlayerRef

The proxy entities are temporary and only exist for a single frame to handle hit detection.

## Lag Compensation Integration with Weapons

The weapons system integrates with lag compensation when firing projectiles:

```csharp
// From WeaponsSystem.FireProjectile method
private void FireProjectile(Frame frame, ref Filter filter, FPVector3 fromPosition, FPVector3 direction, FP maxDistance, FP damage, ref DamageData damageData)
{
    // Use default layer mask + add lag compensation proxy layer mask based on PlayerRef
    var hitMask = filter.Weapons->HitMask;
    hitMask.BitMask |= LagCompensationUtility.GetProxyCollisionLayerMask(filter.Player->PlayerRef);

    var options = QueryOptions.HitAll | QueryOptions.ComputeDetailedInfo;
    var nullableHit = frame.Physics3D.Raycast(fromPosition, direction, maxDistance, hitMask, options);

    if (nullableHit.HasValue == false)
    {
        // No surface was hit, show projectile visual flying to dummy distant point
        var distantPoint = fromPosition + direction * maxDistance;
        frame.Events.FireProjectile(filter.Weapons->CurrentWeaponId, filter.Entity, distantPoint, FPVector3.Zero);
        return;
    }

    Hit3D hit = nullableHit.Value;

    if (frame.Unsafe.TryGetPointer(hit.Entity, out LagCompensationProxy* lagCompensationProxy))
    {
        // Lag compensation proxy was hit, switching hit entity to its origin entity
        hit.SetHitEntity(lagCompensationProxy->Target);
    }

    // When hitting dynamic colliders (players), hit normal is set to zero and hit impact won't be shown
    var hitNormal = hit.IsDynamic ? FPVector3.Zero : hit.Normal;
    frame.Events.FireProjectile(filter.Weapons->CurrentWeaponId, filter.Entity, hit.Point, hitNormal);

    if (frame.Unsafe.TryGetPointer(hit.Entity, out Health* health) == false)
        return;

    // Apply damage to the entity...
}
```

Key aspects of this integration:
1. Each player's raycast includes their unique proxy layer mask
2. When a proxy entity is hit, the hit entity is redirected to the original target
3. Damage is applied to the original entity, not the proxy

## How Lag Compensation Works in Quantum Simple FPS

The Quantum Simple FPS lag compensation system follows these steps:

1. **Historical State Buffering**
   - Each player entity stores a circular buffer of 32 historical transforms
   - The `EarlyLagCompensationSystem` captures transforms every frame
   - This creates a rolling window of entity positions for the last 32 frames

2. **Proxy Entity Creation**
   - For each player, the `LateLagCompensationSystem` creates proxy entities for all other players
   - Proxy entities are positioned based on the target's historical position
   - The exact historical frame is determined by input.InterpolationOffset

3. **Time Offset from Input**
   - Each player's input contains InterpolationOffset and InterpolationAlpha
   - These values represent how far back in time the client is seeing other players
   - The offset is determined by the client's network latency and prediction settings

4. **Layer-Based Collision Filtering**
   - Each player's proxies are placed on a unique collision layer (24-31)
   - When a player fires, their raycast includes only their specific proxy layer
   - This ensures players only hit their own proxy versions of other players

5. **Entity Redirection on Hit**
   - When a proxy entity is hit, the hit entity is redirected to the original target
   - Damage and effects are applied to the original entity, not the proxy
   - This creates the illusion of hitting where the player saw the target

## Interpolation and Smoothing

The system includes interpolation between historical frames for smoother movement:

```csharp
public static Transform3D InterpolateTransform(Transform3D from, Transform3D to, FP alpha)
{
    Transform3D result = default;
    result.Position = FPVector3.Lerp(from.Position, to.Position, alpha);
    result.Rotation = FPQuaternion.Slerp(from.Rotation, to.Rotation, alpha);
    result.Scale = FPVector3.Lerp(from.Scale, to.Scale, alpha);
    return result;
}
```

This interpolation:
1. Uses linear interpolation (Lerp) for position and scale
2. Uses spherical interpolation (Slerp) for rotation
3. Creates smooth movement between historical frames
4. Is applied based on the input.InterpolationAlpha value

## Input Integration

The lag compensation system relies on interpolation data from player input:

```qtn
input
{
    // ... other input fields
    byte InterpolationOffset;
    byte InterpolationAlphaEncoded;
}
```

These values are captured on the client side during input polling:

```csharp
// In CharacterInputPoller.PollInput
input.InterpolationOffset = (byte)callback.InterpolationTarget;
input.InterpolationAlpha = FP.FromFloat_UNSAFE(callback.InterpolationAlpha);
```

The `InterpolationTarget` and `InterpolationAlpha` values are provided by Quantum's input callback and represent:
1. How many frames back in time this client is seeing other players
2. The fractional interpolation between historical frames

## Proxy Prototype Configuration

The proxy prototype is defined in the Unity Editor:

```csharp
// In LagCompensationTargetEditor.cs
[CustomEditor(typeof(QuantumLagCompensationTargetSettings))]
public class LagCompensationTargetEditor : QuantumEditorBehaviour
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
        
        var settings = target as QuantumLagCompensationTargetSettings;
        
        if (settings.ProxyPrototype == null)
        {
            EditorGUILayout.HelpBox("The Proxy Prototype must be configured to use lag compensation.", MessageType.Warning);
            
            if (GUILayout.Button("Create Default Proxy Prototype"))
            {
                // Create a new entity prototype for the proxy
                var prototype = ScriptableObject.CreateInstance<EntityPrototypeAsset>();
                prototype.name = "LagCompensationProxy";
                
                // Add the required components
                prototype.Container.Add(new LagCompensationProxySettings());
                
                // Add the same colliders as the original entity
                var originalColliders = settings.GetComponent<QuantumCharacterSettings>()?.Colliders;
                if (originalColliders != null)
                {
                    var colliderSettings = new PhysicsCollider3DSettings();
                    colliderSettings.Shapes = originalColliders.Shapes;
                    prototype.Container.Add(colliderSettings);
                }
                
                // Add transform component
                prototype.Container.Add(new Transform3DSettings());
                
                // Save the prototype asset
                AssetDatabase.CreateAsset(prototype, 
                    AssetDatabase.GetAssetPath(settings).Replace(settings.name, "LagCompensationProxy.asset"));
                AssetDatabase.SaveAssets();
                
                // Assign the new prototype
                settings.ProxyPrototype = prototype;
                EditorUtility.SetDirty(settings);
            }
        }
    }
}
```

The proxy prototype typically includes:
1. A Transform3D component
2. A PhysicsCollider3D component with the same shapes as the original entity
3. A LagCompensationProxy component
4. Minimal components to keep the proxy lightweight

## Best Practices for FPS Lag Compensation

1. **Historical state buffering**: Store a sufficient number of past transforms
2. **Layer-based collision filtering**: Use unique layers for each player's proxies
3. **Entity redirection**: Map proxy hits back to original entities
4. **Interpolation between frames**: Smooth movement between historical positions
5. **Input-driven time offset**: Let client latency determine how far back to look
6. **Separate proxy prototypes**: Lightweight entities for efficient hit detection
7. **Early and late systems**: Split buffering and proxy creation for better organization
8. **Circular buffer optimization**: Reuse buffer slots to minimize memory usage
9. **Proper cleanup**: Proxies exist for only one frame to avoid accumulation

These practices ensure fair hit detection in a networked FPS, creating a much better player experience where "if you see it, you can hit it" regardless of network latency. The system is deterministic and runs on all clients, ensuring consistent results across the network.

---

# 07-pickups-system.md

# Pickups System in Quantum Simple FPS

This document explains the implementation of the Pickups System in the Quantum Simple FPS sample project, covering item collection mechanics, weapon pickups, and health restoration.

## Pickup Components

The pickups system is built on these components defined in the Quantum DSL:

```qtn
component Pickup
{
    PickupSettings Settings;
    FP PickupCooldown;

    [ExcludeFromPrototype]
    FP Cooldown;
}

union PickupSettings
{
    HealthPickup Health;
    WeaponPickup Weapon;
}

struct HealthPickup
{
    FP Heal;
}

struct WeaponPickup
{
    Byte WeaponID;
    int RefillAmmo;
}
```

These components define two types of pickups:
1. **Health Pickups**: Restore a specific amount of health
2. **Weapon Pickups**: Provide a weapon or refill ammo for an existing weapon

Pickups also use standard Quantum components:
- `Transform3D`: Position and rotation in the world
- `PhysicsCollider3D`: For collision detection
- `Trigger3D`: To detect when a player enters the pickup area

## Pickup System Implementation

The `PickupSystem` handles the logic for interacting with pickups:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class PickupSystem : SystemMainThreadFilter<PickupSystem.Filter>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            filter.Pickup->Cooldown -= frame.DeltaTime;

            if (filter.Pickup->Cooldown <= 0)
            {
                if (filter.Trigger->OverlapCount > 0)
                {
                    EntityRef overlapEntity = filter.Trigger->GetOverlappingEntity(0);
                    
                    // Process weapon pickups
                    if (filter.Pickup->Settings.IsWeapon)
                    {
                        ProcessWeaponPickup(frame, filter.Entity, overlapEntity, filter.Pickup);
                    }
                    // Process health pickups
                    else if (filter.Pickup->Settings.IsHealth)
                    {
                        ProcessHealthPickup(frame, filter.Entity, overlapEntity, filter.Pickup);
                    }
                }
            }
        }

        private void ProcessWeaponPickup(Frame frame, EntityRef pickupEntity, EntityRef playerEntity, Pickup* pickup)
        {
            if (frame.Unsafe.TryGetPointer<Weapons>(playerEntity, out var weapons))
            {
                var weaponPickup = pickup->Settings.Weapon;
                var weaponRef = weapons->WeaponRefs[weaponPickup.WeaponID];
                
                if (frame.Unsafe.TryGetPointer<Weapon>(weaponRef, out var weapon))
                {
                    if (weapon->CollectOrRefill(weaponPickup.RefillAmmo))
                    {
                        // If player doesn't have this weapon selected, switch to it
                        if (weapons->CurrentWeaponId != weaponPickup.WeaponID)
                        {
                            frame.Signals.SwitchWeapon(playerEntity, weaponPickup.WeaponID);
                        }
                        
                        // Apply pickup cooldown
                        pickup->Cooldown = pickup->PickupCooldown;
                        
                        // Trigger pickup event
                        frame.Events.WeaponPickedUp(pickupEntity, playerEntity);
                    }
                }
            }
        }

        private void ProcessHealthPickup(Frame frame, EntityRef pickupEntity, EntityRef playerEntity, Pickup* pickup)
        {
            if (frame.Unsafe.TryGetPointer<Health>(playerEntity, out var health))
            {
                var healthPickup = pickup->Settings.Health;
                
                if (health->AddHealth(healthPickup.Heal))
                {
                    // Apply pickup cooldown
                    pickup->Cooldown = pickup->PickupCooldown;
                    
                    // Trigger pickup event
                    frame.Events.HealthPickedUp(pickupEntity, playerEntity);
                }
            }
        }

        public struct Filter
        {
            public EntityRef Entity;
            public Pickup*  Pickup;
            public PhysicsCollider3D* Collider;
            public Trigger3D* Trigger;
        }
    }
}
```

Key aspects of the Pickup System:
1. Processes all entities with Pickup, PhysicsCollider3D, and Trigger3D components
2. Checks if players are overlapping with the pickup's trigger
3. Handles different pickup types through specialized methods
4. Applies cooldown to prevent multiple pickup triggers
5. Sends events to notify the view layer

## Weapon Pickup Handling

Weapon pickups integrate with the Weapons system to provide new weapons or refill ammo:

```csharp
private void ProcessWeaponPickup(Frame frame, EntityRef pickupEntity, EntityRef playerEntity, Pickup* pickup)
{
    if (frame.Unsafe.TryGetPointer<Weapons>(playerEntity, out var weapons))
    {
        var weaponPickup = pickup->Settings.Weapon;
        var weaponRef = weapons->WeaponRefs[weaponPickup.WeaponID];
        
        if (frame.Unsafe.TryGetPointer<Weapon>(weaponRef, out var weapon))
        {
            if (weapon->CollectOrRefill(weaponPickup.RefillAmmo))
            {
                // If player doesn't have this weapon selected, switch to it
                if (weapons->CurrentWeaponId != weaponPickup.WeaponID)
                {
                    frame.Signals.SwitchWeapon(playerEntity, weaponPickup.WeaponID);
                }
                
                // Apply pickup cooldown
                pickup->Cooldown = pickup->PickupCooldown;
                
                // Trigger pickup event
                frame.Events.WeaponPickedUp(pickupEntity, playerEntity);
            }
        }
    }
}
```

The `CollectOrRefill` method in the Weapon component:

```csharp
public bool CollectOrRefill(int refillAmmo)
{
    if (IsCollected && RemainingAmmo >= MaxRemainingAmmo)
        return false;

    if (IsCollected)
    {
        // If the weapon is already collected at least refill the ammo
        RemainingAmmo = Math.Min(RemainingAmmo + refillAmmo, MaxRemainingAmmo);
    }
    else
    {
        // Weapon is already present inside Player prefab,
        // marking it as IsCollected is all that is needed
        IsCollected = true;
    }

    return true;
}
```

This mechanism:
1. Checks if the player already has the weapon
2. If not, marks the weapon as collected
3. If already collected, adds ammo (up to the maximum)
4. Automatically switches to the newly collected weapon
5. Returns false if the player already has full ammo

## Health Pickup Handling

Health pickups integrate with the Health system:

```csharp
private void ProcessHealthPickup(Frame frame, EntityRef pickupEntity, EntityRef playerEntity, Pickup* pickup)
{
    if (frame.Unsafe.TryGetPointer<Health>(playerEntity, out var health))
    {
        var healthPickup = pickup->Settings.Health;
        
        if (health->AddHealth(healthPickup.Heal))
        {
            // Apply pickup cooldown
            pickup->Cooldown = pickup->PickupCooldown;
            
            // Trigger pickup event
            frame.Events.HealthPickedUp(pickupEntity, playerEntity);
        }
    }
}
```

The `AddHealth` method in the Health component:

```csharp
public bool AddHealth(FP health)
{
    if (CurrentHealth <= 0)
        return false;
    if (CurrentHealth >= MaxHealth)
        return false;

    CurrentHealth = FPMath.Min(CurrentHealth + health, MaxHealth);

    return true;
}
```

This mechanism:
1. Checks if the player is alive and not at full health
2. Adds health (up to the maximum)
3. Returns false if the player is dead or already at full health

## Pickup Events

Pickups communicate with the view layer through events:

```qtn
event WeaponPickedUp
{
    EntityRef PickupEntity;
    EntityRef PlayerEntity;
}

event HealthPickedUp
{
    EntityRef PickupEntity;
    EntityRef PlayerEntity;
}
```

## Pickup Respawn System

Some pickups respawn after a cooldown period:

```csharp
namespace Quantum
{
    [Preserve]
    public unsafe class PickupRespawnSystem : SystemMainThreadFilter<PickupRespawnSystem.Filter>
    {
        public override void Update(Frame frame, ref Filter filter)
        {
            if (filter.RespawnSettings->IsActive == false)
                return;
                
            // Update cooldown
            filter.RespawnSettings->CurrentCooldown -= frame.DeltaTime;
            
            if (filter.RespawnSettings->CurrentCooldown <= 0)
            {
                // Reset cooldown
                filter.RespawnSettings->CurrentCooldown = filter.RespawnSettings->RespawnCooldown;
                
                // Activate pickup
                filter.RespawnSettings->IsActive = true;
                
                // Enable collider
                var collider = frame.Unsafe.GetPointer<PhysicsCollider3D>(filter.Entity);
                collider->IsTrigger = true;
                
                // Send event for visual feedback
                frame.Events.PickupRespawned(filter.Entity);
            }
        }
        
        public struct Filter
        {
            public EntityRef Entity;
            public PickupRespawnSettings* RespawnSettings;
        }
    }
}
```

This system:
1. Tracks cooldown for respawning pickups
2. Reactivates pickups when their cooldown expires
3. Triggers events for visual feedback

## Pickup View Integration

The Unity-side view code visualizes pickups and their collection:

```csharp
namespace QuantumDemo
{
    public class PickupView : QuantumEntityViewComponent
    {
        // References
        public GameObject ModelRoot;
        public ParticleSystem CollectEffect;
        public AudioSource CollectSound;
        public float RotationSpeed = 90f;
        public float BobAmount = 0.2f;
        public float BobSpeed = 1f;
        
        // Original position for bob effect
        private Vector3 _startPosition;
        private bool _isActive = true;
        
        private void OnEnable()
        {
            // Subscribe to pickup events
            QuantumEvent.Subscribe<EventWeaponPickedUp>(this, OnWeaponPickedUp);
            QuantumEvent.Subscribe<EventHealthPickedUp>(this, OnHealthPickedUp);
            QuantumEvent.Subscribe<EventPickupRespawned>(this, OnPickupRespawned);
            
            // Store original position
            _startPosition = transform.position;
        }
        
        private void OnDisable()
        {
            // Unsubscribe from pickup events
            QuantumEvent.Unsubscribe<EventWeaponPickedUp>(this, OnWeaponPickedUp);
            QuantumEvent.Unsubscribe<EventHealthPickedUp>(this, OnHealthPickedUp);
            QuantumEvent.Unsubscribe<EventPickupRespawned>(this, OnPickupRespawned);
        }
        
        private void Update()
        {
            if (!_isActive)
                return;
                
            // Rotate the pickup
            ModelRoot.transform.Rotate(0, RotationSpeed * Time.deltaTime, 0);
            
            // Bob up and down
            float yOffset = Mathf.Sin(Time.time * BobSpeed) * BobAmount;
            transform.position = _startPosition + new Vector3(0, yOffset, 0);
        }
        
        private void OnWeaponPickedUp(EventWeaponPickedUp e)
        {
            if (e.PickupEntity != EntityRef)
                return;
                
            PlayPickupEffect();
        }
        
        private void OnHealthPickedUp(EventHealthPickedUp e)
        {
            if (e.PickupEntity != EntityRef)
                return;
                
            PlayPickupEffect();
        }
        
        private void OnPickupRespawned(EventPickupRespawned e)
        {
            if (e.Entity != EntityRef)
                return;
                
            // Reactivate pickup
            _isActive = true;
            ModelRoot.SetActive(true);
        }
        
        private void PlayPickupEffect()
        {
            // Hide the pickup model
            _isActive = false;
            ModelRoot.SetActive(false);
            
            // Play visual and audio effects
            CollectEffect.Play();
            CollectSound.Play();
        }
    }
}
```

Key aspects of the pickup visualization:
1. Rotating and bobbing idle animation
2. Visual and audio effects when collected
3. Reactivation when the pickup respawns
4. Event-based communication with the simulation

## Weapon UI Updates

When a weapon is picked up, the UI is updated:

```csharp
namespace QuantumDemo
{
    public class WeaponUIController : QuantumMonoBehaviour
    {
        // References
        public GameObject[] WeaponSlots;
        
        // The local player's entity
        private EntityRef _playerEntity;
        
        public void Initialize(EntityRef playerEntity)
        {
            _playerEntity = playerEntity;
            
            // Subscribe to weapon pickup event
            QuantumEvent.Subscribe<EventWeaponPickedUp>(this, OnWeaponPickedUp);
        }
        
        private void OnDestroy()
        {
            QuantumEvent.Unsubscribe<EventWeaponPickedUp>(this, OnWeaponPickedUp);
        }
        
        private void OnWeaponPickedUp(EventWeaponPickedUp e)
        {
            if (e.PlayerEntity != _playerEntity)
                return;
                
            UpdateWeaponUI();
        }
        
        private void UpdateWeaponUI()
        {
            if (!QuantumRunner.Default.Game.TryGetFrameLocal(out var frame))
                return;
                
            if (!frame.TryGet(_playerEntity, out Weapons weapons))
                return;
                
            // Update UI for each weapon slot
            for (int i = 0; i < WeaponSlots.Length; i++)
            {
                if (i < weapons.WeaponRefs.Length)
                {
                    var weaponRef = weapons.WeaponRefs[i];
                    if (frame.TryGet(weaponRef, out Weapon weapon))
                    {
                        // Show weapon slot if collected
                        WeaponSlots[i].SetActive(weapon.IsCollected);
                    }
                }
            }
        }
    }
}
```

## Health Bar Updates

When health is picked up, the health bar UI is updated:

```csharp
// In HealthView.OnUpdateView()
if (_isLocalPlayer && HealthBar != null)
{
    HealthBar.value = health.CurrentHealth.AsFloat / health.MaxHealth.AsFloat;
    
    // Fade damage overlay based on health
    if (DamageOverlay != null)
    {
        float targetAlpha = 1.0f - (health.CurrentHealth.AsFloat / health.MaxHealth.AsFloat);
        Color color = DamageOverlay.color;
        color.a = Mathf.Lerp(0.0f, 0.8f, targetAlpha);
        DamageOverlay.color = color;
    }
}
```

## Best Practices for FPS Pickup Implementation

1. **Union-based pickup types**: Use a union to handle different pickup types efficiently
2. **Trigger-based detection**: Use physics triggers for reliable pickup detection
3. **Cooldown mechanism**: Prevent spamming pickup triggers
4. **Conditional pickup logic**: Only apply pickups when they would have an effect
5. **Automatic weapon switching**: Switch to newly collected weapons for better UX
6. **Visual feedback**: Provide clear visual and audio cues for pickups
7. **Respawn system**: Allow pickups to reappear after a cooldown
8. **Event-based view updates**: Use events to notify the view layer about pickups
9. **Floating animation**: Create visually appealing idle animations for pickups
10. **Max health/ammo limits**: Respect maximum values when applying pickups

These practices ensure an engaging pickup system that provides clear feedback to players while maintaining deterministic behavior across all clients. The system effectively integrates with the weapons and health systems to ensure a cohesive gameplay experience.

## Pickup Placement and Level Design

Pickups are strategically placed in the level to encourage specific player behaviors:

1. **Health Pickups**:
   - Placed in areas where players might retreat after taking damage
   - Often positioned near cover or in areas away from high-traffic combat zones
   - Encourage players to move around the map when injured

2. **Weapon Pickups**:
   - More powerful weapons placed in high-risk areas
   - Encourage players to compete for control of strategic locations
   - Create focal points for combat

3. **Respawn Timing**:
   - Important pickups have longer respawn timers to make them more valuable
   - Creates rhythms in gameplay as players anticipate respawns
   - Encourages map control and timing-based strategies

All pickup placements are defined in the map data and instantiated when the level loads. This ensures consistent pickup placement across all clients.

## Balancing Considerations

The pickup system is carefully balanced to enhance gameplay:

1. **Health Restoration Amounts**:
   - Small health packs (25 HP): Common, shorter respawn times
   - Large health packs (50 HP): Rare, longer respawn times
   - Values balanced to make health a valuable resource without making players invincible

2. **Weapon Ammo Distribution**:
   - More powerful weapons receive less ammo per pickup
   - Players must make strategic decisions about when to use powerful weapons
   - Creates interesting risk/reward scenarios

3. **Pickup Distribution**:
   - Even distribution ensures no part of the map is overly advantageous
   - Ensures matches remain dynamic with action across the entire level
   - Prevents "camping" by making resources available in multiple areas

These balancing considerations create a dynamic and engaging FPS experience where pickups play a crucial role in player decision-making and strategy.

---

# 00-project-overview.md

# Quantum Twin Stick Shooter Project Overview

This document provides a comprehensive overview of the Quantum Twin Stick Shooter sample project for Photon Quantum 3.0.2. These notes are structured to help you understand how a multiplayer top-down twin stick shooter game is implemented using Quantum's deterministic networking framework.

## Project Structure

The Twin Stick Shooter demonstrates a multiplayer game built with Quantum's deterministic networking framework. The project is organized as follows:

### Core Simulation Code (Quantum)
- **Assets/QuantumUser/Simulation**: Contains all the deterministic simulation code
  - `DSL/*.qtn` files: Quantum DSL files defining the game state
  - `System/*.cs` files: System classes implementing game logic
  - `AI/*.cs` files: AI behaviors and decision making
  - `AssetDefinition/*.cs` files: Define configuration for game objects

### Unity View Code
- **Assets/TwinStickShooter/Scripts**: Contains Unity-side view code
  - Player views and animations
  - Weapon visualizations and effects
  - UI elements and HUD
  - Input handling for different platforms

## Key Features Demonstrated

1. **Top-Down Character Controller**: Deterministic twin-stick movement using Quantum KCC (Kinematic Character Controller)
2. **Skills System**: Data-driven abilities with different behaviors
3. **Bot SDK Integration**: AI-controlled characters using Hierarchical Finite State Machine (HFSM)
4. **Team-Based Gameplay**: Coin collection game mode with team strategy
5. **AI Director**: Team-level strategy management for coordinated AI behavior
6. **Context Steering**: Sophisticated movement behavior for AI characters
7. **Input Handling**: Unified input system for both players and bots
8. **Attributes System**: Character stats and modifiers using a flexible system

## Technical Highlights

### AI Implementation
- **Bot SDK**: Comprehensive use of Quantum's Bot SDK
- **HFSM**: Hierarchical Finite State Machine for AI decision making
- **AI Director**: Team-level coordination of AI characters
- **Data-Driven Sensors**: Configurable perception systems for AI
- **Context Steering**: Multiple weighted vectors for movement decisions
- **AI Memory**: Time-based information storage and recall
- **Bot Replacement**: Automatic replacement of disconnected players with bots

### Game Systems
- **Skill System**: Data-driven abilities with customizable behavior
- **Attributes System**: Flexible stat management with modifiers
- **Team-Based Gameplay**: Coin collection with scoring system
- **Game Flow Management**: HFSM-based game state control
- **Unified Input**: Same input structure used for both players and bots
- **KCC Integration**: Top-down character controller

## Architecture Overview

Quantum Twin Stick Shooter follows Quantum's core architecture principles:

### Simulation-View Separation

```
Simulation (Quantum) → Events → View (Unity)
             ↑           ↓
             └─ Input ───┘
```

- **Simulation**: Deterministic game logic running in Quantum
- **View**: Visual representation in Unity
- **Events**: One-way communication from simulation to view
- **Input**: Player commands sent from view to simulation

### ECS Implementation

The game uses Quantum's Entity Component System:
- **Entities**: Dynamic game objects (characters, skills, attacks)
- **Components**: Data containers attached to entities
- **Systems**: Logic that processes entities with specific components

### Networking Model

The predict/rollback networking model:
- **Prediction**: Each client predicts game state based on local input
- **Rollback**: When actual input arrives, state is corrected if necessary
- **Determinism**: Same input always produces the same output

## Core Systems Overview

### Movement System
- Processes player/bot input
- Controls character movement using KCC
- Handles movement locks during attacks

### Input System
- Handles input from players
- Switches to bot input when players disconnect
- Provides unified input structure for both players and bots

### AI System
- Manages HFSM updates for bot decision making
- Handles context steering for movement
- Updates AI sensors based on game state

### Skills System
- Implements character abilities
- Manages skill activation, updates, and deactivation
- Handles skill effects and attacks

### Attributes System
- Manages character stats (health, speed, etc.)
- Processes modifiers and effects
- Provides a flexible framework for character customization

### Game Manager System
- Controls overall game flow using HFSM
- Manages game states (character selection, playing, game over)
- Handles match timing and victory conditions

## Game Modes

The main game mode is **Coin Grab**:
- Teams collect coins scattered around the map
- The first team to accumulate and maintain 10+ coins for 15 seconds wins
- Strategic elements involve both offensive and defensive play
- AI Director manages team strategies based on game state

## Characters

The game features 3 unique character types:
- Each character has unique stats and abilities
- Each character has 2 skills (basic and special)
- Character selection phase at the beginning of matches
- Character-specific attributes affect gameplay

## Code Examples and Usage Guidelines

The documentation provides accurate, error-free code examples that can be directly used as templates for your own Quantum multiplayer projects. Follow these guidelines:

1. Start with the Project Overview to understand the game's architecture
2. Examine specific systems based on your implementation needs
3. Use the provided code examples as a reference for your own implementation
4. Pay special attention to the data-driven architecture for skills and AI
---

# 01-input-system.md

# Input System

This document explains how the Twin Stick Shooter handles player input and AI control, showing the unified input system that allows seamless switching between player and bot control.

## Input Architecture

The input system in Quantum Twin Stick Shooter follows a unified approach:

1. **Input Definition**: The same `QuantumDemoInputTopDown` structure is used for both player input and bot AI
2. **Input Collection**: Player input is collected on the Unity side and sent to Quantum
3. **Input Application**: The `InputSystem` applies inputs to characters, regardless of source
4. **Automatic Bot Substitution**: When players disconnect, the system seamlessly transfers control to a bot

## Input Structure

The input structure is defined in the DSL:

```csharp
// From Input.qtn
component InputContainer
{
    [HideInInspector] QuantumDemoInputTopDown Input;
}
```

The `QuantumDemoInputTopDown` structure contains:

```csharp
// Generated from Quantum's input system
struct QuantumDemoInputTopDown
{
    FPVector2 MoveDirection;  // Normalized movement direction
    FPVector2 AimDirection;   // Direction for aiming/firing
    Boolean Fire;             // Primary attack button
    Boolean AltFire;          // Secondary attack button
}
```

## Input System Implementation

The Quantum `InputSystem` handles applying input to characters:

```csharp
[Preserve]
public unsafe class InputSystem : SystemMainThreadFilter<InputSystem.Filter>, ISignalOnToggleControllers
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform2D* Transform;
        public Character* Character;
        public InputContainer* InputContainer;
    }

    // This system deals with getting the Input structure from the appropriate place
    // The input can either come from a Player with GetPlayerInput, or from a Bot
    public override void Update(Frame frame, ref Filter filter)
    {
        if (frame.Global->ControllersEnabled == false)
            return;

        int playerRef = frame.Get<PlayerLink>(filter.Entity).PlayerRef;
        bool controlledByBot = IsControlledByAI(frame, filter, playerRef);

        if (controlledByBot == false)
        {
            filter.InputContainer->Input = *frame.GetPlayerInput(playerRef);
        }
        else
        {
            filter.InputContainer->Input = frame.Get<Bot>(filter.Entity).Input;
        }
    }

    // Enable/disable input, used to pause characters when the game is starting/over
    public void OnToggleControllers(Frame frame, QBoolean value)
    {
        frame.Global->ControllersEnabled = value;
    }

    private bool IsControlledByAI(Frame frame, Filter filter, int playerRef)
    {
        // If the player is not connected, we turn it into a bot
        bool playerNotPresent = frame.GetPlayerInputFlags(playerRef).HasFlag(DeterministicInputFlags.PlayerNotPresent) == true;
        if (playerNotPresent == true && frame.Get<Bot>(filter.Entity).IsActive == false)
        {
            if (frame.IsVerified)
            {
                AISetupHelper.Botify(frame, filter.Entity);
            }
        }

        if (frame.TryGet(filter.Entity, out Bot bot) == false)
            return false;

        if(bot.IsActive == false)
        {
            return false;
        }
        return true;
    }
}
```

## Unity Input Collection

On the Unity side, a `TopDownInput` component collects player input and sends it to Quantum:

```csharp
public class TopDownInput : MonoBehaviour
{
    public FP AimSensitivity = 5;
    public CustomViewContext ViewContext;
    
    private FPVector2 _lastDirection = new FPVector2();
    private AttackPreview _attackPreview;
    private PlayerInput _playerInput;

    // Called by Quantum to collect input
    public void PollInput(CallbackPollInput callback)
    {
        Quantum.QuantumDemoInputTopDown input = new Quantum.QuantumDemoInputTopDown();

        // Read movement input from InputSystem
        FPVector2 directional = _playerInput.actions["Move"].ReadValue<Vector2>().ToFPVector2();
        input.MoveDirection = IsInverseControl == true ? -directional : directional;

        // Read firing inputs
#if UNITY_STANDALONE || UNITY_WEBGL
        input.Fire = _playerInput.actions["MouseFire"].IsPressed();
        input.AltFire = _playerInput.actions["MouseSpecial"].IsPressed();
#elif UNITY_ANDROID
        input.Fire = _playerInput.actions["Fire"].IsPressed();
        input.AltFire = _playerInput.actions["Special"].IsPressed();
#endif

        // Handle aim direction calculation
        if (input.Fire == true)
        {
            _lastDirection = _playerInput.actions["AimBasic"].ReadValue<Vector2>().ToFPVector2();
            _lastDirection *= AimSensitivity;
        }

        if (input.AltFire == true)
        {
            _lastDirection = _playerInput.actions["AimSpecial"].ReadValue<Vector2>().ToFPVector2();
            _lastDirection *= AimSensitivity;
        }

        // Calculate final aim direction based on control scheme
        FPVector2 actionVector = default;
#if UNITY_STANDALONE || UNITY_WEBGL
        if (_playerInput.currentControlScheme != null && _playerInput.currentControlScheme.Contains("Joystick"))
        {
            actionVector = IsInverseControl ? -_lastDirection : _lastDirection;
        }
        else
        {
            actionVector = GetDirectionToMouse();
        }
        input.AimDirection = actionVector;
#elif UNITY_ANDROID
        actionVector = IsInverseControl ? -_lastDirection : _lastDirection;
        input.AimDirection = actionVector;
#endif

        // Show attack preview if aiming
        if ((input.Fire == true || input.AltFire == true) && input.AimDirection != FPVector2.Zero)
        {
            _attackPreview.gameObject.SetActive(true);
            _attackPreview.UpdateAttackPreview(actionVector, input.AltFire);
        }

        // Send input to Quantum
        callback.SetInput(input, DeterministicInputFlags.Repeatable);
    }

    // Calculate direction from character to mouse position
    private FPVector2 GetDirectionToMouse()
    {
        if (QuantumRunner.Default == null || QuantumRunner.Default.Game == null)
            return default;

        Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
        if (frame == null)
            return default;

        if (ViewContext.LocalView == null || frame.Exists(ViewContext.LocalView.EntityRef) == false)
            return default;
        
        FPVector2 localCharacterPosition = frame.Get<Transform2D>(ViewContext.LocalView.EntityRef).Position;

        Vector2 mousePosition = _playerInput.actions["Point"].ReadValue<Vector2>();
        Ray ray = Camera.main.ScreenPointToRay(mousePosition);
        UnityEngine.Plane plane = new UnityEngine.Plane(Vector3.up, Vector3.zero);

        if (plane.Raycast(ray, out var enter))
        {
            var dirToMouse = ray.GetPoint(enter).ToFPVector2() - localCharacterPosition;
            return dirToMouse;
        }

        return default;
    }
}
```

## Bot Input Generation

For bots, input is generated through the AI system:

```csharp
// In AISystem.cs
private void HandleContextSteering(Frame frame, Filter filter)
{
    // Process the final desired direction
    FPVector2 desiredDirection = filter.AISteering->GetDesiredDirection(frame, filter.Entity);

    // Lerp the current value towards the desired one so it doesn't turn too sudden
    filter.AISteering->CurrentDirection = FPVector2.MoveTowards(filter.AISteering->CurrentDirection, desiredDirection,
        frame.DeltaTime * filter.AISteering->LerpFactor);

    // Assign movement direction to the bot's input structure
    filter.Bot->Input.MoveDirection = filter.AISteering->CurrentDirection;
    
    // Aim direction and firing inputs are set by behavior tree actions
}
```

## Player to Bot Transition

When a player disconnects, the system automatically converts their character to a bot:

```csharp
// In InputSystem.cs, IsControlledByAI method
bool playerNotPresent = frame.GetPlayerInputFlags(playerRef).HasFlag(DeterministicInputFlags.PlayerNotPresent) == true;
if (playerNotPresent == true && frame.Get<Bot>(filter.Entity).IsActive == false)
{
    if (frame.IsVerified)
    {
        AISetupHelper.Botify(frame, filter.Entity);
    }
}
```

The `AISetupHelper.Botify` method:

```csharp
// From AISetupHelper.cs
public static void Botify(Frame frame, EntityRef entity)
{
    // 1. Set bot component as active
    Bot* bot = frame.Unsafe.GetPointer<Bot>(entity);
    bot->IsActive = true;

    // 2. Setup HFSM brain for AI
    AIConfig aiConfig = frame.FindAsset<AIConfig>(frame.RuntimeConfig.DefaultBotConfig.Id);
    HFSMRoot hfsmRoot = frame.FindAsset<HFSMRoot>(aiConfig.HFSM.Id);
    HFSMData* hfsmData = frame.Unsafe.AddOrGetPointer<HFSMData>(entity);
    hfsmData->Root = hfsmRoot;
    HFSMManager.Init(frame, hfsmData, entity, hfsmRoot);
    
    // 3. Initialize memory for AI
    AIMemory* aiMemory = frame.Unsafe.AddOrGetPointer<AIMemory>(entity);
    aiMemory->Initialize();
    
    // 4. Setup navigation agent
    frame.Unsafe.AddComponent<NavMeshPathfinder>(entity);
    frame.Unsafe.AddComponent<NavMeshSteeringAgent>(entity);
    NavMeshPathfinder* pathfinder = frame.Unsafe.GetPointer<NavMeshPathfinder>(entity);
    pathfinder->Settings = aiConfig.NavMeshPathfinderSettings;
    
    // 5. Add AI steering component for movement control
    AISteering* aiSteering = frame.Unsafe.AddOrGetPointer<AISteering>(entity);
    aiSteering->Initialize();
}
```

## Best Practices

1. **Unified Input Structure**: Use the same input structure for both player and AI control
2. **Seamless Transition**: Design systems to handle player-to-bot transitions without disruption
3. **Input Abstraction**: Keep the character movement and abilities systems decoupled from input source
4. **Platform Adaptation**: Handle multiple input methods (mouse/keyboard, touch, gamepad)
5. **Prediction Handling**: Use `DeterministicInputFlags.Repeatable` for inputs to work with predict/rollback

## Implementation Notes

1. The `QuantumDemoInputTopDown` structure provides a minimal but complete set of inputs for twin-stick shooter gameplay
2. The same input structure is used for both AI-controlled and player-controlled characters
3. The `InputSystem` doesn't care about the source of input (player or AI)
4. Movement and aiming inputs use normalized FPVector2 values for consistency
5. The Unity Input System package is used for input collection on the client side
---

# 02-movement-system.md

# Movement System

This document explains the movement implementation in the Quantum Twin Stick Shooter, focusing on how character movement is handled using Quantum's deterministic physics.

## Overview

The movement system in Twin Stick Shooter is built around Quantum's Kinematic Character Controller (KCC) and provides:

1. **Top-down movement**: Direction-based character control
2. **Speed attributes**: Character-specific movement speeds
3. **Movement locking**: During attacks and skills
4. **Stun effects**: Preventing movement during stun duration
5. **Unified handling**: Same system for both player and bot-controlled characters

## Components and Data Structures

The movement system uses several components defined in DSL:

```csharp
// From Movement.qtn
component MovementData
{
    Boolean IsOnAttackMovementLock;
}

// From kcc.qtn
component KCC
{
    asset_ref<KCCSettings> Settings;
    FP MaxSpeed;
    
    // Internal working data for KCC system (not shown)
}
```

## MovementSystem Implementation

The `MovementSystem` handles character movement based on input:

```csharp
[Preserve]
public unsafe class MovementSystem : SystemMainThreadFilter<MovementSystem.Filter>, ISignalOnComponentAdded<KCC>
{
    public struct Filter
    {
        public EntityRef Entity;
        public InputContainer* InputContainer;
        public KCC* KCC;
        public MovementData* MovementData;
    }

    public void OnAdded(Frame frame, EntityRef entity, KCC* component)
    {
        KCCSettings kccSettings = frame.FindAsset<KCCSettings>(component->Settings.Id);
        kccSettings.Init(ref *component);
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Check if movement is currently locked
        FP stun = AttributesHelper.GetCurrentValue(frame, filter.Entity, EAttributeType.Stun);
        if (stun > 0 || filter.MovementData->IsOnAttackMovementLock == true)
        {
            return;
        }

        // Get character speed from attributes system
        FP characterSpeed = AttributesHelper.GetCurrentValue(frame, filter.Entity, EAttributeType.Speed);
        filter.KCC->MaxSpeed = characterSpeed;

        // Compute movement direction based on input and apply to KCC
        KCCSettings kccSettings = frame.FindAsset<KCCSettings>(filter.KCC->Settings.Id);
        KCCMovementData kccMovementData = kccSettings.ComputeRawMovement(frame,
            filter.Entity, filter.InputContainer->Input.MoveDirection.Normalized);
        kccSettings.SteerAndMove(frame, filter.Entity, in kccMovementData);
    }
}
```

## KCC Movement Flow

The KCC (Kinematic Character Controller) handles movement in these steps:

1. **Input processing**: Convert raw input into movement direction
2. **Speed calculation**: Apply character's speed attribute
3. **Physics interaction**: Handle collisions with the environment
4. **Position update**: Update character transform

## Movement Restrictions

Several systems can restrict character movement:

### Attack Movement Lock

During certain attacks or skills, movement is temporarily locked:

```csharp
// In SkillData.cs (simplified)
public virtual EntityRef OnCreate(Frame frame, EntityRef source, SkillData data,
    FPVector2 characterPos, FPVector2 actionVector)
{
    // Lock movement for the duration specified in the skill
    if (MovementLockDuration > 0)
    {
        MovementData* movementData = frame.Unsafe.GetPointer<MovementData>(source);
        movementData->IsOnAttackMovementLock = true;
        
        // Set a timer to unlock movement after duration
        frame.Timer.Set(source, "MovementLock", data.MovementLockDuration,
            () => { 
                if (frame.Exists(source)) {
                    movementData->IsOnAttackMovementLock = false; 
                }
            });
    }
    
    // Rest of skill creation...
}
```

### Stun Effect

The stun attribute temporarily prevents character movement:

```csharp
// Simplified example of applying stun
public static void ApplyStun(Frame frame, EntityRef target, FP duration)
{
    AttributesHelper.ChangeAttribute(
        frame, 
        target, 
        EAttributeType.Stun, 
        EModifierAppliance.Timer, 
        EModifierOperation.Add, 
        FP._1, 
        duration);
}
```

## Rotation System

Character rotation is handled separately from movement:

```csharp
[Preserve]
public unsafe class RotationSystem : SystemMainThreadFilter<RotationSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform2D* Transform;
        public InputContainer* InputContainer;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Check if rotation is locked due to attack
        if (frame.TryGet(filter.Entity, out Skill skill))
        {
            SkillData skillData = frame.FindAsset<SkillData>(skill.SkillData.Id);
            if (skill.TTL < skillData.RotationLockDuration)
            {
                // Rotation is locked during the start of some skills
                return;
            }
        }

        // Rotate character based on aim direction
        FPVector2 aimDirection = filter.InputContainer->Input.AimDirection;
        if (aimDirection.Magnitude > FP._0_10)
        {
            FP targetRotation = FPMath.Atan2(aimDirection.Y, aimDirection.X);
            filter.Transform->Rotation = targetRotation;
        }
    }
}
```

## AI Movement with Context Steering

For AI-controlled characters, movement is driven by Context Steering, which produces input values that feed into the same movement system:

```csharp
// In AISystem.cs (simplified)
private void HandleContextSteering(Frame frame, Filter filter)
{
    // Process the final desired direction using context steering
    FPVector2 desiredDirection = filter.AISteering->GetDesiredDirection(frame, filter.Entity);

    // Smooth the direction change with lerping
    filter.AISteering->CurrentDirection = FPVector2.MoveTowards(
        filter.AISteering->CurrentDirection, 
        desiredDirection,
        frame.DeltaTime * filter.AISteering->LerpFactor);

    // Apply the direction to the Bot's input
    filter.Bot->Input.MoveDirection = filter.AISteering->CurrentDirection;
}
```

The AISteering component calculates movement direction based on multiple factors:

```csharp
// In AISteering class (simplified)
public unsafe FPVector2 GetDesiredDirection(Frame frame, EntityRef entity)
{
    FPVector2 resultingDirection = FPVector2.Zero;
    int validInfluenceCount = 0;
    
    // Consider various steering influences:
    
    // 1. Main navigation path (highest priority)
    if (IsNavMeshSteering && MainSteeringData.SteeringEntryNavMesh->IsValid)
    {
        resultingDirection += MainSteeringData.SteeringEntryNavMesh->Direction * MainSteeringData.SteeringEntryNavMesh->Weight;
        validInfluenceCount++;
    }
    
    // 2. Threat avoidance
    for (int i = 0; i < ThreatSteeringData.SteeringEntries.Length; i++)
    {
        var entry = ThreatSteeringData.SteeringEntries[i];
        if (entry.IsValid)
        {
            resultingDirection += entry.Direction * entry.Weight;
            validInfluenceCount++;
        }
    }
    
    // 3. General avoidance (characters, obstacles, etc.)
    for (int i = 0; i < AvoidanceSteeringData.SteeringEntries.Length; i++)
    {
        var entry = AvoidanceSteeringData.SteeringEntries[i];
        if (entry.IsValid)
        {
            resultingDirection += entry.Direction * entry.Weight;
            validInfluenceCount++;
        }
    }
    
    // Normalize the result if we have valid influences
    if (validInfluenceCount > 0)
    {
        return resultingDirection.Normalized;
    }
    
    return FPVector2.Zero;
}
```

## Important Movement Concepts

### 1. Deterministic Physics

All movement uses Quantum's deterministic physics to ensure consistent behavior across all clients:

- **Fixed Point Math**: All calculations use `FP` types instead of floats
- **Repeatable Results**: Same input always produces the same output
- **Frame-based Updates**: Movement updates happen in discrete simulation frames

### 2. Integration with Attributes System

Character movement speed is determined by the Attributes system:

```csharp
// In MovementSystem.Update
FP characterSpeed = AttributesHelper.GetCurrentValue(frame, filter.Entity, EAttributeType.Speed);
filter.KCC->MaxSpeed = characterSpeed;
```

### 3. Unified Movement Pipeline

Both player-controlled and AI-controlled characters use the same movement system, just with different sources of input:

- **Player Characters**: Input comes from player controls
- **Bot Characters**: Input comes from AI steering calculations
- **Character KCC**: Processes input the same way regardless of source

## Best Practices

1. **Separate Input from Movement**: Keep input collection separate from movement logic
2. **Use AttributesSystem for Stats**: Store movement speeds in the attributes system for flexibility
3. **Context Steering for AI**: Use weighted influence vectors for natural AI movement
4. **Handle Movement Restrictions**: Implement clean systems for restricting movement during skills/stuns
5. **Deterministic Calculations**: Ensure all calculations use fixed-point math and are deterministic

## Implementation Notes

1. The KCC provides collision detection and resolution against the environment
2. Movement and rotation are handled in separate systems for modularity
3. Context steering provides a flexible framework for AI movement decisions
4. The attributes system allows for dynamic adjustment of movement speed
5. All movement calculations are fully deterministic for network consistency
---

# 03-ai-system.md

# AI System

This document provides a comprehensive overview of the AI implementation in the Quantum Twin Stick Shooter, explaining how bots make decisions and navigate the game world.

## AI Architecture Overview

The AI system in Twin Stick Shooter consists of several integrated components:

1. **HFSM (Hierarchical Finite State Machine)**: The "brain" for decision making
2. **Context Steering**: The "muscles" that produce movement behaviors
3. **AI Memory**: Time-based storage and recall of game information
4. **AI Sensors**: Perception systems that gather information from the game world
5. **AI Director**: Team-level strategy coordination

This multi-layered approach creates sophisticated and responsive bot behavior.

## Core Components

### Bot Component

```csharp
// From Bot.qtn
component Bot
{
    Boolean IsActive;
    QuantumDemoInputTopDown Input;
}
```

### HFSM Agent

```csharp
// Generated from Bot SDK
component HFSMAgent
{
    asset_ref<AIConfig> Config;
    HFSMData Data;
}
```

### AI Memory

```csharp
// From AIMemory.qtn
component AIMemory
{
    QList<AIMemoryEntry> Entries;
    byte NextEntryIndex;
}
```

### AI Steering

```csharp
// From AISteering.qtn
component AISteering
{
    FPVector2 CurrentDirection;
    FP LerpFactor;
    Boolean IsNavMeshSteering;
    SteeringData MainSteeringData;
    SteeringData ThreatSteeringData;
    SteeringData DesireSteeringData;
    SteeringData AvoidanceSteeringData;
}
```

## AI System Implementation

The `AISystem` is the central controller for bot behavior:

```csharp
[Preserve]
public unsafe class AISystem : SystemMainThreadFilter<AISystem.Filter>, 
    ISignalOnComponentAdded<Bot>, 
    ISignalOnNavMeshMoveAgent,
    ISignalOnGameStart, 
    ISignalOnCreateAttack, 
    ISignalOnCreateSkill
{
    public struct Filter
    {
        public EntityRef Entity;
        public Transform2D* Transform;
        public Bot* Bot;
        public Health* Health;
        public AISteering* AISteering;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        if (filter.Bot->IsActive == false)
            return;

        if(filter.Health->IsDead == true)
            return;

        // 1. Update sensors to gather information
        UpdateSensors(frame, filter.Entity);

        // 2. Update movement using context steering
        HandleContextSteering(frame, filter);

        // 3. Update the HFSM for decision making
        HFSMManager.Update(frame, frame.DeltaTime, filter.Entity);
    }
    
    // Other methods...
}
```

## AI Decision Making (HFSM)

The HFSM (Hierarchical Finite State Machine) provides a structured decision-making framework:

```csharp
// Example HFSM setup (simplified)
public static HFSMRoot CreateBotHFSM()
{
    // Create root and main states
    HFSMRoot root = new HFSMRoot();
    
    var idle = root.AddState("Idle");
    var attack = root.AddState("Attack");
    var collect = root.AddState("Collect");
    var escape = root.AddState("Escape");
    var hide = root.AddState("Hide");
    
    // Define transitions between states
    idle.AddTransition(attack, new HasTargetInRange());
    idle.AddTransition(collect, new CollectibleExists());
    attack.AddTransition(escape, new HealthBelowThreshold());
    escape.AddTransition(hide, new FindBushToHide());
    
    // Define behaviors in each state
    idle.SetUpdateAction(new WanderAroundAction());
    attack.SetUpdateAction(new AttackTargetAction());
    collect.SetUpdateAction(new ChaseCollectible());
    escape.SetUpdateAction(new FindEscapeRoute());
    hide.SetUpdateAction(new HideInBush());
    
    return root;
}
```

Each state can contain leaf nodes with specific decision-making logic:

```csharp
// Example of a decision node
public class HasTargetInRange : HFSMDecision
{
    public FP Range = 5;
    
    public override unsafe Boolean Decide(Frame frame, EntityRef entity)
    {
        if (!frame.TryGet(entity, out AIMemory memory))
            return false;
            
        // Check if any detected enemy is within range
        for (int i = 0; i < memory.Entries.Length; i++)
        {
            AIMemoryEntry* entry = &memory.Entries[i];
            if (entry->Type == EMemoryType.Enemy && entry->IsValid)
            {
                FP distanceSq = FPVector2.DistanceSquared(
                    frame.Get<Transform2D>(entity).Position,
                    entry->Position
                );
                
                if (distanceSq <= Range * Range)
                    return true;
            }
        }
        
        return false;
    }
}
```

## AI Memory System

The AI Memory system provides time-based storage and recall of game information:

```csharp
// From MemorySystem.cs (simplified)
[Preserve]
public unsafe class MemorySystem : SystemMainThreadFilter<MemorySystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public AIMemory* Memory;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        for (int i = 0; i < filter.Memory->Entries.Length; i++)
        {
            AIMemoryEntry* entry = &filter.Memory->Entries[i];
            
            if (entry->IsValid == false)
                continue;
                
            // Update entry timer
            entry->TTL += frame.DeltaTime;
            
            // Memory becomes available after delay
            if (entry->RecallDelay > 0 && entry->TTL < entry->RecallDelay)
                continue;
                
            // Memory expires after duration
            if (entry->Duration > 0 && entry->TTL >= entry->Duration)
            {
                entry->IsValid = false;
                continue;
            }
            
            // Update entry-specific data
            UpdateMemoryEntryData(frame, filter.Entity, entry);
        }
    }
    
    private void UpdateMemoryEntryData(Frame frame, EntityRef entity, AIMemoryEntry* entry)
    {
        switch (entry->Type)
        {
            case EMemoryType.Enemy:
                UpdateEnemyMemory(frame, entry);
                break;
                
            case EMemoryType.Collectible:
                UpdateCollectibleMemory(frame, entry);
                break;
                
            // Other memory types...
        }
    }
}
```

Memory entries can be added to store information about game entities:

```csharp
// Adding a memory entry (simplified)
public unsafe AIMemoryEntry* AddMemory(Frame frame, EMemoryType type)
{
    // Find first available slot or overwrite oldest
    byte index = NextEntryIndex;
    NextEntryIndex = (byte)((NextEntryIndex + 1) % Entries.Length);
    
    AIMemoryEntry* entry = &Entries[index];
    entry->Type = type;
    entry->IsValid = true;
    entry->TTL = 0;
    
    // Default values based on type
    switch (type)
    {
        case EMemoryType.Enemy:
            entry->RecallDelay = 0;
            entry->Duration = 5;
            break;
            
        case EMemoryType.Collectible:
            entry->RecallDelay = 0;
            entry->Duration = 10;
            break;
            
        // Other types...
    }
    
    return entry;
}
```

## Context Steering

Context Steering calculates movement direction based on weighted influences:

```csharp
// In AISystem.cs (simplified)
private void HandleContextSteering(Frame frame, Filter filter)
{
    // Get final desired direction from weighted influences
    FPVector2 desiredDirection = filter.AISteering->GetDesiredDirection(frame, filter.Entity);

    // Smooth transitions
    filter.AISteering->CurrentDirection = FPVector2.MoveTowards(
        filter.AISteering->CurrentDirection, 
        desiredDirection,
        frame.DeltaTime * filter.AISteering->LerpFactor);

    // Set as bot input
    filter.Bot->Input.MoveDirection = filter.AISteering->CurrentDirection;
}
```

The steering entries contain weighted influence vectors:

```csharp
// SteeringEntry structure (simplified)
public struct SteeringEntry
{
    public FPVector2 Direction;
    public FP Weight;
    public Boolean IsValid;
    
    public void SetData(FPVector2 direction, FP weight = 1)
    {
        Direction = direction.Normalized;
        Weight = weight;
        IsValid = true;
    }
}
```

## AI Sensors

Sensors gather information from the game world:

```csharp
// Base Sensor class (simplified)
public abstract class Sensor
{
    public int TickRate = 5;
    protected int TickCounter;
    
    public virtual void Execute(Frame frame, EntityRef entity)
    {
        TickCounter++;
        if (TickCounter >= TickRate)
        {
            TickCounter = 0;
            Sense(frame, entity);
        }
    }
    
    protected abstract void Sense(Frame frame, EntityRef entity);
}

// Example sensor implementation
public class SensorEnemies : Sensor
{
    public FP DetectionRadius = 10;
    
    protected override void Sense(Frame frame, EntityRef entity)
    {
        TeamInfo agentTeam = frame.Get<TeamInfo>(entity);
        Transform2D agentTransform = frame.Get<Transform2D>(entity);
        
        // Find all characters in detection radius
        var characters = frame.Filter<Character, TeamInfo, Transform2D>();
        while (characters.NextUnsafe(out EntityRef characterEntity, out Character* character, 
               out TeamInfo* characterTeam, out Transform2D* characterTransform))
        {
            // Ignore same team
            if (agentTeam.Index == characterTeam->Index)
                continue;
                
            // Check distance
            FP distanceSq = FPVector2.DistanceSquared(
                agentTransform.Position, 
                characterTransform->Position);
                
            if (distanceSq <= DetectionRadius * DetectionRadius)
            {
                // Add to memory
                AIMemory* memory = frame.Unsafe.GetPointer<AIMemory>(entity);
                AIMemoryEntry* entry = memory->AddMemory(frame, EMemoryType.Enemy);
                entry->EntityRef = characterEntity;
                entry->Position = characterTransform->Position;
            }
        }
    }
}
```

## AI Director

The AI Director coordinates team-level strategy:

```csharp
// AIDirector data structure (simplified)
struct AIDirector
{
    byte TickInterval;
    int TeamIndex;
    AIDirectorMemory Memory;
}

// Director system (simplified)
[Preserve]
public unsafe class AIDirectorSystem : SystemMainThread
{
    public override void Update(Frame frame)
    {
        // Update each team's director
        for (int i = 0; i < 2; i++)
        {
            AIDirector* director = &frame.Global->AIDirectors[i];
            director->TickInterval++;
            
            if (director->TickInterval >= 30)
            {
                director->TickInterval = 0;
                UpdateTeamStrategy(frame, director);
            }
        }
    }
    
    private void UpdateTeamStrategy(Frame frame, AIDirector* director)
    {
        // Count available coins
        int availableCoins = CountAvailableCoins(frame);
        director->Memory.AvailableCoins = (byte)availableCoins;
        
        // Count team members with coins
        int teamMembersWithCoins = CountTeamMembersWithCoins(frame, director->TeamIndex);
        
        // Determine optimal strategy based on game state
        AITactic teamTactic;
        
        if (teamMembersWithCoins > 2)
        {
            teamTactic = AITactic.Defend;
        }
        else if (availableCoins > 5)
        {
            teamTactic = AITactic.Collect;
        }
        else if (GetOpponentCoins(frame, director->TeamIndex) > 8)
        {
            teamTactic = AITactic.Attack;
        }
        else
        {
            teamTactic = AITactic.Balanced;
        }
        
        // Broadcast tactic to team members
        BroadcastTacticToTeam(frame, director->TeamIndex, teamTactic);
    }
}
```

## Bot Creation and Replacement

Players who disconnect are automatically replaced by bots:

```csharp
// In InputSystem.cs (simplified)
private bool IsControlledByAI(Frame frame, Filter filter, int playerRef)
{
    // If player disconnected, convert to bot
    bool playerNotPresent = frame.GetPlayerInputFlags(playerRef).HasFlag(DeterministicInputFlags.PlayerNotPresent);
    if (playerNotPresent && frame.Get<Bot>(filter.Entity).IsActive == false)
    {
        if (frame.IsVerified)
        {
            AISetupHelper.Botify(frame, filter.Entity);
        }
    }
    
    // Check if entity is controlled by bot
    if (frame.TryGet(filter.Entity, out Bot bot) == false)
        return false;
        
    return bot.IsActive;
}
```

The `AISetupHelper.Botify` method configures a character for AI control:

```csharp
// In AISetupHelper.cs (simplified)
public static void Botify(Frame frame, EntityRef entity)
{
    // Activate bot component
    Bot* bot = frame.Unsafe.GetPointer<Bot>(entity);
    bot->IsActive = true;
    
    // Setup HFSM
    AIConfig aiConfig = frame.FindAsset<AIConfig>(frame.RuntimeConfig.DefaultBotConfig.Id);
    HFSMRoot hfsmRoot = frame.FindAsset<HFSMRoot>(aiConfig.HFSM.Id);
    HFSMData* hfsmData = frame.Unsafe.AddOrGetPointer<HFSMData>(entity);
    hfsmData->Root = hfsmRoot;
    HFSMManager.Init(frame, hfsmData, entity, hfsmRoot);
    
    // Setup memory
    AIMemory* aiMemory = frame.Unsafe.AddOrGetPointer<AIMemory>(entity);
    aiMemory->Initialize();
    
    // Setup navigation components
    frame.Unsafe.AddComponent<NavMeshPathfinder>(entity);
    frame.Unsafe.AddComponent<NavMeshSteeringAgent>(entity);
    NavMeshPathfinder* pathfinder = frame.Unsafe.GetPointer<NavMeshPathfinder>(entity);
    pathfinder->Settings = aiConfig.NavMeshPathfinderSettings;
    
    // Setup steering
    AISteering* aiSteering = frame.Unsafe.AddOrGetPointer<AISteering>(entity);
    aiSteering->Initialize();
}
```

## Best Practices

1. **Modular AI Components**: Separate decision-making (HFSM), movement (steering), and perception (sensors)
2. **Data-Driven Configuration**: Use assets to define AI behaviors, making them easy to adjust
3. **Reuse Player Systems**: Design AI to work with the same systems as player-controlled characters
4. **Memory-Based Perception**: Use a memory system to store and forget information over time
5. **Hierarchical Decision Making**: Use multiple levels (individual HFSM, team director) for coordination
6. **Context Steering**: Combine multiple weighted influences for natural movement
7. **Seamless Player-Bot Transition**: Design systems to handle player disconnections gracefully

## Implementation Notes

1. The AI uses the same input structure as player-controlled characters
2. Sensors perform periodic updates to reduce computational overhead
3. Memory entries have configurable recall delay and duration
4. Context steering combines influences from goals, obstacles, and threats
5. The AI Director provides team-level strategy coordination
6. All AI calculations are fully deterministic for network consistency
---

# 04-skills-system.md

# Skills and Combat System

This document explains the skills and combat implementation in the Quantum Twin Stick Shooter, focusing on how character abilities, attacks, and damage are handled.

## Overview

The skills and combat system in Twin Stick Shooter features:

1. **Data-Driven Skills**: Configurable skill behaviors and effects
2. **Basic and Special Abilities**: Each character has two unique skills
3. **Attack Implementation**: Skills spawn attack entities for damage
4. **Polymorphic Behavior**: Skills can be extended with custom behavior
5. **Resource Management**: Skills cost resources to use (mana, energy, etc.)
6. **Cooldown Management**: Skills have usage restrictions
7. **Visual Effects Integration**: Synchronized effects between simulation and view

## Core Components

### Character Attacks

```csharp
// From Character.qtn
component CharacterAttacks 
{
    asset_ref<SkillData> BasicSkillData;
    asset_ref<SkillData> SpecialSkillData;
}
```

### Skill Component

```csharp
// Generated from Skill.qtn
component Skill
{
    asset_ref<SkillData> SkillData;
    EntityRef Source;
    FP TTL;
    FP ActionTimer;
    FPVector2 ActionVector;
}
```

### Attack Component

```csharp
// From Attack.qtn
component Attack
{
    asset_ref<AttackData> AttackData;
    EntityRef Source;
    FP TTL;
}
```

## SkillData Asset

The `SkillData` class defines the behavior of skills:

```csharp
public abstract unsafe partial class SkillData : AssetObject
{
    // Configuration properties
    public AssetRef<EntityPrototype> SkillPrototype;
    public AssetRef<EntityPrototype> AttackPrototype;
    public bool HasTTL;
    public FP ActionInterval;
    public int ActionAmount;
    public FP RotationLockDuration;
    public FP MovementLockDuration;
    public bool AutoAimCheckSight = true;
    public FP Cost = 1;
    public EAttributeType CostType;
    public FP AutoAimRadius = 10;

    // Called when the skill is initially created
    public virtual EntityRef OnCreate(Frame frame, EntityRef source, SkillData data,
        FPVector2 characterPos, FPVector2 actionVector)
    {
        // Create the skill entity
        EntityRef skillEntity = frame.Create(SkillPrototype);
        Skill* skill = frame.Unsafe.GetPointer<Skill>(skillEntity);
        skill->SkillData = data;
        skill->Source = source;
        skill->ActionTimer = ActionInterval;
        skill->ActionVector = actionVector;

        // Set position
        Transform2D* transform = frame.Unsafe.GetPointer<Transform2D>(skillEntity);
        transform->Position = characterPos;

        // Apply skill cost
        if (Cost != 0)
        {
            AttributesHelper.ChangeAttribute(frame, source, CostType, 
                EModifierAppliance.OneTime, EModifierOperation.Subtract, Cost, 0);
        }
        
        // Apply movement/rotation locks
        if (MovementLockDuration > 0)
        {
            MovementData* movementData = frame.Unsafe.GetPointer<MovementData>(source);
            movementData->IsOnAttackMovementLock = true;
            
            frame.Timer.Set(source, "MovementLock", MovementLockDuration, 
                () => { 
                    if (frame.Exists(source)) {
                        movementData->IsOnAttackMovementLock = false; 
                    }
                });
        }
        
        return skillEntity;
    }

    // Called each frame to update the skill
    public virtual void OnUpdate(Frame frame, EntityRef source, EntityRef skillEntity, Skill* skill)
    {
        if (skill->ActionTimer >= ActionInterval)
        {
            skill->ActionTimer = 0;
            OnAction(frame, source, skillEntity, skill);
        }
        skill->TTL += frame.DeltaTime;
        skill->ActionTimer += frame.DeltaTime;
    }

    // Called when the skill performs its action (e.g., creates an attack)
    public virtual EntityRef OnAction(Frame frame, EntityRef source, EntityRef skillEntity, Skill* skill)
    {
        // Create attack entity
        EntityRef attackEntity = frame.Create(AttackPrototype);
        Transform2D* attackTransform = frame.Unsafe.GetPointer<Transform2D>(attackEntity);

        // Position the attack based on source
        if (source != default)
        {
            Transform2D sourceTransform = frame.Get<Transform2D>(source);
            attackTransform->Position = sourceTransform.Position;
            attackTransform->Rotation = sourceTransform.Rotation;
        }
        else
        {
            Transform2D skillTransform = frame.Get<Transform2D>(skillEntity);
            attackTransform->Position = skillTransform.Position;
            attackTransform->Rotation = skillTransform.Rotation;
        }

        // Setup attack properties
        Attack* attack = frame.Unsafe.GetPointer<Attack>(attackEntity);
        attack->Source = source;
        AttackData data = frame.FindAsset<AttackData>(attack->AttackData.Id);

        // Initialize attack
        data.OnCreate(frame, attackEntity, source, attack);
        
        // Send event for view synchronization
        frame.Events.SkillAction(skill->SkillData.Id);

        return attackEntity;
    }

    // Called when the skill is deactivated
    public virtual void OnDeactivate(Frame frame, EntityRef skillEntity, Skill* skill)
    {
        var skillData = frame.FindAsset<SkillData>(skill->SkillData.Id);
        frame.Signals.OnDisableSkill(skill->Source, skillData);

        frame.Destroy(skillEntity);
    }
}
```

## AttackData Asset

The `AttackData` class defines the behavior of attacks:

```csharp
public abstract unsafe partial class AttackData : AssetObject
{
    public FP Damage;
    public FP TTL;
    public AssetRef<Shape2D> CollisionShape;
    public Boolean IsContinuousDamage;
    public FP DamageInterval;

    // Called when the attack is created
    public virtual void OnCreate(Frame frame, EntityRef attackEntity, 
        EntityRef source, Attack* attack)
    {
        attack->TTL = 0;
        
        // Add physics trigger for damage detection
        if (CollisionShape.Id.IsValid)
        {
            PhysicsCollider2D* collider = frame.Unsafe.AddOrGetPointer<PhysicsCollider2D>(attackEntity);
            collider->Shape = CollisionShape;
            collider->IsTrigger = true;
        }
    }

    // Called each frame to update the attack
    public virtual void OnUpdate(Frame frame, EntityRef attackEntity, Attack* attack)
    {
        // Apply continuous damage if needed
        if (IsContinuousDamage && attack->TTL >= DamageInterval)
        {
            attack->TTL = 0;
            ApplyDamageToOverlappingEntities(frame, attackEntity, attack);
        }
        
        attack->TTL += frame.DeltaTime;
        
        // Destroy attack when TTL expires
        if (TTL > 0 && attack->TTL >= TTL)
        {
            frame.Destroy(attackEntity);
        }
    }
    
    // Apply damage to entities overlapping with the attack
    protected void ApplyDamageToOverlappingEntities(Frame frame, EntityRef attackEntity, Attack* attack)
    {
        // Get all entities overlapping with attack collider
        PhysicsCollider2D collider = frame.Get<PhysicsCollider2D>(attackEntity);
        Transform2D transform = frame.Get<Transform2D>(attackEntity);
        
        // Get team info for friendly fire check
        TeamInfo sourceTeam = default;
        if (frame.Exists(attack->Source))
        {
            sourceTeam = frame.Get<TeamInfo>(attack->Source);
        }
        
        // Check overlapping entities
        foreach (var hit in Physics2D.OverlapShape(frame, collider.Shape, transform))
        {
            // Skip if not a character or same team
            if (!frame.Has<Character>(hit) || !frame.Has<Health>(hit))
                continue;
                
            if (frame.Has<TeamInfo>(hit))
            {
                TeamInfo hitTeam = frame.Get<TeamInfo>(hit);
                if (sourceTeam.Index == hitTeam.Index)
                    continue; // Skip same team
            }
            
            // Apply damage
            Health* health = frame.Unsafe.GetPointer<Health>(hit);
            if (health->IsDead == false)
            {
                HealthSystem.ApplyDamage(frame, hit, attack->Source, Damage);
            }
        }
    }
}
```

## SkillSystem Implementation

The `SkillSystem` handles the creation, update, and deactivation of skills:

```csharp
[Preserve]
public unsafe class SkillSystem : SystemMainThreadFilter<SkillSystem.Filter>, ISignalOnCreateSkill
{
    public struct Filter
    {
        public EntityRef Entity;
        public Skill* Skill;
    }

    // Handle skill creation
    public void OnCreateSkill(Frame frame, EntityRef character, FPVector2 characterPos, 
        SkillData data, FPVector2 actionVector)
    {
        // Call polymorphic OnCreate
        data.OnCreate(frame, character, data, characterPos, actionVector);

        // Trigger view event for animation
        frame.Events.CharacterSkill(character);
    }

    // Update active skills
    public override void Update(Frame frame, ref Filter filter)
    {
        SkillData data = frame.FindAsset<SkillData>(filter.Skill->SkillData.Id);
        
        // Call polymorphic OnUpdate
        data.OnUpdate(frame, filter.Skill->Source, filter.Entity, filter.Skill);
        
        // Check if skill TTL is over
        if (data.HasTTL == true && filter.Skill->TTL >= (data.ActionAmount * data.ActionInterval))
        {
            data.OnDeactivate(frame, filter.Entity, filter.Skill);
        }
    }
}
```

## Attack System Implementation

The `AttackSystem` handles updating active attacks:

```csharp
[Preserve]
public unsafe class AttackSystem : SystemMainThreadFilter<AttackSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Attack* Attack;
    }

    // Update active attacks
    public override void Update(Frame frame, ref Filter filter)
    {
        AttackData data = frame.FindAsset<AttackData>(filter.Attack->AttackData.Id);
        
        // Call polymorphic OnUpdate
        data.OnUpdate(frame, filter.Entity, filter.Attack);
    }
}
```

## Skills Creation System

The `CharacterSkillCreationSystem` handles creating skills when players use abilities:

```csharp
[Preserve]
public unsafe class CharacterSkillCreationSystem : 
    SystemMainThreadFilter<CharacterSkillCreationSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Character* Character;
        public CharacterAttacks* CharacterAttacks;
        public InputContainer* InputContainer;
        public Transform2D* Transform;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Skip if character is dead or inputs disabled
        if (frame.Global->ControllersEnabled == false)
            return;
            
        if (frame.Has<Health>(filter.Entity) && frame.Get<Health>(filter.Entity).IsDead)
            return;

        // Get input
        QuantumDemoInputTopDown input = filter.InputContainer->Input;
        
        // Check for basic attack
        if (input.Fire)
        {
            TryCreateSkill(frame, filter.Entity, filter.Transform->Position, 
                filter.CharacterAttacks->BasicSkillData, input.AimDirection);
        }
        
        // Check for special attack
        else if (input.AltFire)
        {
            TryCreateSkill(frame, filter.Entity, filter.Transform->Position, 
                filter.CharacterAttacks->SpecialSkillData, input.AimDirection);
        }
    }

    private void TryCreateSkill(Frame frame, EntityRef entity, FPVector2 position, 
        AssetRef<SkillData> skillDataRef, FPVector2 actionDirection)
    {
        // Skip if no skill data or invalid direction
        if (skillDataRef.Id.IsValid == false || actionDirection == FPVector2.Zero)
            return;
            
        SkillData skillData = frame.FindAsset<SkillData>(skillDataRef.Id);
        
        // Check if character has enough resource
        FP currentResourceValue = AttributesHelper.GetCurrentValue(
            frame, entity, skillData.CostType);
            
        if (currentResourceValue < skillData.Cost)
            return;
            
        // Check cooldown
        string cooldownKey = $"Skill_{skillDataRef.Id.Value}";
        if (frame.Timer.IsSet(entity, cooldownKey))
            return;
            
        // Auto-aim if needed
        if (skillData.AutoAimRadius > 0)
        {
            actionDirection = TryGetAutoAimDirection(
                frame, entity, position, actionDirection, skillData);
        }
        
        // Create the skill
        frame.Signals.OnCreateSkill(entity, position, skillData, actionDirection);
        
        // Set cooldown
        FP cooldown = AttributesHelper.GetCurrentValue(frame, entity, EAttributeType.SkillCooldown);
        frame.Timer.Set(entity, cooldownKey, cooldown);
    }
    
    private FPVector2 TryGetAutoAimDirection(Frame frame, EntityRef source, 
        FPVector2 position, FPVector2 defaultDirection, SkillData skillData)
    {
        // Implementation of auto-aim logic
        // Find closest enemy within auto-aim radius
        // Check line of sight if required
        // Return direction to enemy or default direction
        
        // ... (simplified for brevity)
        
        return defaultDirection;
    }
}
```

## Health System

The `HealthSystem` manages character health and damage:

```csharp
[Preserve]
public unsafe class HealthSystem : SystemMainThreadFilter<HealthSystem.Filter>, 
    ISignalOnCharacterDamage, ISignalOnSetCharacterImmune
{
    public struct Filter
    {
        public EntityRef Entity;
        public Health* Health;
    }

    // Apply damage to a character
    public static void ApplyDamage(Frame frame, EntityRef target, 
        EntityRef source, FP amount)
    {
        // Skip if target is already dead
        Health* health = frame.Unsafe.GetPointer<Health>(target);
        if (health->IsDead || health->IsImmortal)
            return;
            
        // Reduce armor if available
        FP armor = AttributesHelper.GetCurrentValue(frame, target, EAttributeType.Armor);
        FP damageReduction = FPMath.Min(armor, amount * FP._0_50);
        FP finalDamage = amount - damageReduction;
        
        // Apply damage
        health->Current -= finalDamage;
        
        // Send damage event
        frame.Events.CharacterDamaged(target, finalDamage);
        frame.Signals.OnCharacterDamage(target);
        
        // Check if character died
        if (health->Current <= 0)
        {
            health->Current = 0;
            health->IsDead = true;
            
            // Handle character defeat
            HandleCharacterDefeat(frame, target, source);
        }
    }
    
    // Handle character defeat
    private static void HandleCharacterDefeat(Frame frame, EntityRef character, 
        EntityRef killer)
    {
        // Send defeat event
        frame.Events.CharacterDefeated(character);
        frame.Signals.OnCharacterDefeated(character);
        
        // Increment killer's score if valid
        if (frame.Exists(killer) && frame.Has<Player>(killer))
        {
            Player* player = frame.Unsafe.GetPointer<Player>(killer);
            player->Kills++;
        }
        
        // Handle respawn setup
        if (frame.Has<Respawn>(character))
        {
            Respawn* respawn = frame.Unsafe.GetPointer<Respawn>(character);
            respawn->Timer = 0;
            respawn->IsDead = true;
        }
    }
    
    // Set character temporary immunity (e.g., after respawn)
    public void OnSetCharacterImmune(Frame frame, EntityRef character, FP time)
    {
        if (frame.Has<Health>(character))
        {
            Health* health = frame.Unsafe.GetPointer<Health>(character);
            health->IsImmortal = true;
            
            // Set timer to disable immortality
            frame.Timer.Set(character, "Immortality", time, () => {
                if (frame.Exists(character))
                {
                    Health* h = frame.Unsafe.GetPointer<Health>(character);
                    h->IsImmortal = false;
                }
            });
        }
    }
    
    // Called when character takes damage (for effects, etc.)
    public void OnCharacterDamage(Frame frame, EntityRef character)
    {
        // Implementation of damage reactions
        // e.g., visual effects, interrupt actions, etc.
    }
}
```

## Skill Example: Projectile Skill

Here's an example of a custom skill implementation:

```csharp
// Arrow shot skill (simplified)
public unsafe class ArrowSkillData : SkillData
{
    public FP ProjectileSpeed = 20;
    public int ProjectileCount = 1;
    public FP SpreadAngle = 0;
    
    public override EntityRef OnAction(Frame frame, EntityRef source, 
        EntityRef skillEntity, Skill* skill)
    {
        EntityRef result = default;
        Transform2D sourceTransform = frame.Get<Transform2D>(source);
        
        // Calculate spread for multiple projectiles
        FP baseAngle = sourceTransform.Rotation;
        FP spreadStep = SpreadAngle / FPMath.Max(1, ProjectileCount - 1);
        FP startAngle = baseAngle - SpreadAngle / 2;
        
        // Create each projectile
        for (int i = 0; i < ProjectileCount; i++)
        {
            // Calculate this projectile's angle
            FP angle = startAngle + spreadStep * i;
            FPVector2 direction = FPVector2.FromAngle(angle);
            
            // Create projectile entity
            EntityRef projectile = frame.Create(AttackPrototype);
            
            // Set position and direction
            Transform2D* transform = frame.Unsafe.GetPointer<Transform2D>(projectile);
            transform->Position = sourceTransform.Position;
            transform->Rotation = angle;
            
            // Set projectile properties
            Attack* attack = frame.Unsafe.GetPointer<Attack>(projectile);
            attack->Source = source;
            
            // Add movement component
            PhysicsBody2D* body = frame.Unsafe.AddOrGetPointer<PhysicsBody2D>(projectile);
            body->Velocity = direction * ProjectileSpeed;
            
            // Initialize attack data
            AttackData attackData = frame.FindAsset<AttackData>(attack->AttackData.Id);
            attackData.OnCreate(frame, projectile, source, attack);
            
            result = projectile;
        }
        
        // Play attack sound
        frame.Events.SkillAction(skill->SkillData.Id);
        
        return result;
    }
}
```

## Skill Example: Area Effect

Here's another example of a custom skill:

```csharp
// Spellcaster area effect (simplified)
public unsafe class SpellAreaSkillData : SkillData
{
    public FP Radius = 3;
    public FP GrowthRate = 1;
    public FP MaxRadius = 5;
    
    public override EntityRef OnCreate(Frame frame, EntityRef source, 
        SkillData data, FPVector2 characterPos, FPVector2 actionVector)
    {
        // Calculate target position
        FPVector2 targetPos = characterPos + actionVector.Normalized * Radius;
        
        // Create base skill entity
        EntityRef skillEntity = base.OnCreate(frame, source, data, characterPos, actionVector);
        
        // Set skill position to target position
        Transform2D* transform = frame.Unsafe.GetPointer<Transform2D>(skillEntity);
        transform->Position = targetPos;
        
        return skillEntity;
    }
    
    public override EntityRef OnAction(Frame frame, EntityRef source, 
        EntityRef skillEntity, Skill* skill)
    {
        // Create attack entity
        EntityRef attackEntity = frame.Create(AttackPrototype);
        
        // Position attack at skill position
        Transform2D skillTransform = frame.Get<Transform2D>(skillEntity);
        Transform2D* attackTransform = frame.Unsafe.GetPointer<Transform2D>(attackEntity);
        attackTransform->Position = skillTransform.Position;
        
        // Set attack properties
        Attack* attack = frame.Unsafe.GetPointer<Attack>(attackEntity);
        attack->Source = source;
        
        // Create growing circle collision
        CircleCollider2D* collider = frame.Unsafe.AddOrGetPointer<CircleCollider2D>(attackEntity);
        collider->Radius = Radius + (skill->TTL * GrowthRate);
        collider->Radius = FPMath.Min(collider->Radius, MaxRadius);
        
        // Initialize attack
        AttackData attackData = frame.FindAsset<AttackData>(attack->AttackData.Id);
        attackData.OnCreate(frame, attackEntity, source, attack);
        
        // Play effect
        frame.Events.SkillAction(skill->SkillData.Id);
        
        return attackEntity;
    }
}
```

## Best Practices

1. **Polymorphic Skill Design**: Use inheritance to create specialized skill behaviors
2. **Data-Driven Configuration**: Keep skill parameters in assets for easy tuning
3. **Entity-Based Skills**: Represent skills and attacks as entities in the ECS
4. **Clear Separation of Concerns**:
   - `SkillData`: Defines skill behavior
   - `SkillSystem`: Manages skill lifecycle
   - `AttackData`: Defines attack behavior
   - `AttackSystem`: Manages attack lifecycle
   - `HealthSystem`: Handles damage application
5. **Resource Management**: Tie skill usage to character resources
6. **Cooldown System**: Use timers for skill cooldowns
7. **Event-Based Visual Effects**: Use events to synchronize view effects

## Implementation Notes

1. Skills and attacks are separate concepts - skills create attacks
2. The polymorphic design allows for diverse skill behaviors 
3. The data-driven approach makes balancing and tuning easier
4. Both player and AI characters use the same skill system
5. All calculations are fully deterministic for network consistency
6. Event system synchronizes view effects with simulation
---

# 05-attributes-system.md

# Attributes System

This document explains the attributes system in the Quantum Twin Stick Shooter, focusing on how character stats are managed using a flexible and extensible approach.

## Overview

The attributes system in Twin Stick Shooter provides a framework for managing character statistics:

1. **Attribute Types**: Various character stats (health, speed, mana, etc.)
2. **Flexible Modifiers**: Different ways to modify attributes (add, multiply, etc.)
3. **Timed Effects**: Temporary attribute changes with automatic expiration
4. **Stacking Rules**: How multiple modifiers combine
5. **Attribute-Driven Gameplay**: Character behavior based on attribute values

## Core Components

### Attributes Component

```csharp
// From Attributes.qtn
component Attributes
{
    QList<AttributeEntry> Entries;
}

struct AttributeEntry
{
    EAttributeType Type;
    FP BaseValue;
    QList<ModifierEntry> Modifiers;
}

struct ModifierEntry
{
    EModifierAppliance Appliance;
    EModifierOperation Operation;
    FP Value;
    FP Duration;
    FP Timer;
}
```

### Attribute Types

The game defines various attribute types through an enum:

```csharp
// From Attributes.qtn
enum EAttributeType
{
    // Resources
    Health,
    Mana,
    Energy,
    
    // Stats
    Speed,
    Armor,
    Damage,
    AttackSpeed,
    
    // Special states
    Stun,
    Silence,
    
    // System properties
    SkillCooldown,
    RespawnTime
}
```

### Modifier Operations and Applications

```csharp
// From Attributes.qtn
enum EModifierOperation
{
    Add,        // Simple addition
    Multiply,   // Percentage increase
    Override,   // Replace value
    Max,        // Set minimum value
    Min,        // Set maximum value
    Subtract    // Decrease value
}

enum EModifierAppliance
{
    Permanent,  // Never expires
    Timer,      // Active for a duration
    OneTime     // Applied once, then removed
}
```

## AttributesSystem Implementation

The `AttributesSystem` manages updating and processing attribute modifiers:

```csharp
[Preserve]
public unsafe class AttributesSystem : SystemMainThreadFilter<AttributesSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Attributes* Attributes;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Process each attribute entry
        for (int i = 0; i < filter.Attributes->Entries.Length; i++)
        {
            AttributeEntry* entry = &filter.Attributes->Entries[i];
            
            // Process modifiers for this attribute
            ProcessModifiers(frame, entry, frame.DeltaTime);
        }
    }
    
    private void ProcessModifiers(Frame frame, AttributeEntry* entry, FP deltaTime)
    {
        // Update modifier timers
        for (int i = 0; i < entry->Modifiers.Length; i++)
        {
            ModifierEntry* modifier = &entry->Modifiers[i];
            
            // Skip permanent modifiers
            if (modifier->Appliance == EModifierAppliance.Permanent)
                continue;
                
            // Update timer for timed modifiers
            if (modifier->Appliance == EModifierAppliance.Timer)
            {
                modifier->Timer += deltaTime;
                
                // Remove expired modifiers
                if (modifier->Timer >= modifier->Duration)
                {
                    entry->Modifiers.RemoveAt(i);
                    i--;
                }
            }
            // Remove one-time modifiers after they're processed
            else if (modifier->Appliance == EModifierAppliance.OneTime)
            {
                entry->Modifiers.RemoveAt(i);
                i--;
            }
        }
    }
}
```

## AttributesHelper Utility Class

The `AttributesHelper` provides convenient methods for working with attributes:

```csharp
public static unsafe class AttributesHelper
{
    // Get the current value of an attribute
    public static FP GetCurrentValue(Frame frame, EntityRef entity, EAttributeType type)
    {
        if (!frame.Has<Attributes>(entity))
            return 0;
            
        Attributes* attributes = frame.Unsafe.GetPointer<Attributes>(entity);
        
        // Find the attribute entry for this type
        AttributeEntry* entry = GetEntryOrCreate(frame, attributes, type);
        
        // Start with base value
        FP finalValue = entry->BaseValue;
        
        // Apply additive modifiers first
        for (int i = 0; i < entry->Modifiers.Length; i++)
        {
            ModifierEntry* modifier = &entry->Modifiers[i];
            if (modifier->Operation == EModifierOperation.Add)
            {
                finalValue += modifier->Value;
            }
            else if (modifier->Operation == EModifierOperation.Subtract)
            {
                finalValue -= modifier->Value;
            }
        }
        
        // Apply multiplicative modifiers
        FP multiplier = FP._1;
        for (int i = 0; i < entry->Modifiers.Length; i++)
        {
            ModifierEntry* modifier = &entry->Modifiers[i];
            if (modifier->Operation == EModifierOperation.Multiply)
            {
                multiplier += modifier->Value;
            }
        }
        finalValue *= multiplier;
        
        // Apply min/max modifiers
        for (int i = 0; i < entry->Modifiers.Length; i++)
        {
            ModifierEntry* modifier = &entry->Modifiers[i];
            if (modifier->Operation == EModifierOperation.Min)
            {
                finalValue = FPMath.Min(finalValue, modifier->Value);
            }
            else if (modifier->Operation == EModifierOperation.Max)
            {
                finalValue = FPMath.Max(finalValue, modifier->Value);
            }
            else if (modifier->Operation == EModifierOperation.Override)
            {
                finalValue = modifier->Value;
            }
        }
        
        return finalValue;
    }
    
    // Change an attribute by adding a modifier
    public static void ChangeAttribute(
        Frame frame, 
        EntityRef entity, 
        EAttributeType type, 
        EModifierAppliance appliance, 
        EModifierOperation operation, 
        FP value, 
        FP duration = 0)
    {
        if (!frame.Has<Attributes>(entity))
            return;
            
        Attributes* attributes = frame.Unsafe.GetPointer<Attributes>(entity);
        
        // Find or create the attribute entry
        AttributeEntry* entry = GetEntryOrCreate(frame, attributes, type);
        
        // Create new modifier
        ModifierEntry modifier = new ModifierEntry
        {
            Appliance = appliance,
            Operation = operation,
            Value = value,
            Duration = duration,
            Timer = 0
        };
        
        // Add modifier to the attribute
        entry->Modifiers.Add(frame, modifier);
    }
    
    // Set the base value of an attribute
    public static void SetBaseValue(
        Frame frame, 
        EntityRef entity, 
        EAttributeType type, 
        FP value)
    {
        if (!frame.Has<Attributes>(entity))
            return;
            
        Attributes* attributes = frame.Unsafe.GetPointer<Attributes>(entity);
        
        // Find or create the attribute entry
        AttributeEntry* entry = GetEntryOrCreate(frame, attributes, type);
        
        // Set base value
        entry->BaseValue = value;
    }
    
    // Get or create an attribute entry
    private static AttributeEntry* GetEntryOrCreate(
        Frame frame, 
        Attributes* attributes, 
        EAttributeType type)
    {
        // Try to find existing entry
        for (int i = 0; i < attributes->Entries.Length; i++)
        {
            AttributeEntry* entry = &attributes->Entries[i];
            if (entry->Type == type)
            {
                return entry;
            }
        }
        
        // Create new entry if not found
        AttributeEntry newEntry = new AttributeEntry
        {
            Type = type,
            BaseValue = 0,
            Modifiers = new QList<ModifierEntry>(frame.AllocatorHandle, 4)
        };
        
        attributes->Entries.Add(frame, newEntry);
        
        // Return pointer to the newly added entry
        return &attributes->Entries[attributes->Entries.Length - 1];
    }
    
    // Clear all modifiers of a specific type from an attribute
    public static void ClearModifiers(
        Frame frame, 
        EntityRef entity, 
        EAttributeType type)
    {
        if (!frame.Has<Attributes>(entity))
            return;
            
        Attributes* attributes = frame.Unsafe.GetPointer<Attributes>(entity);
        
        // Find the attribute entry for this type
        for (int i = 0; i < attributes->Entries.Length; i++)
        {
            AttributeEntry* entry = &attributes->Entries[i];
            if (entry->Type == type)
            {
                entry->Modifiers.Clear();
                return;
            }
        }
    }
}
```

## Character Attribute Initialization

When a character is created, its attributes are initialized based on its character type:

```csharp
// From CharacterInitializationSystem.cs (simplified)
public static void InitializeAttributes(Frame frame, EntityRef entity, CharacterInfo characterInfo)
{
    // Create attributes component if not exists
    if (!frame.Has<Attributes>(entity))
    {
        frame.Unsafe.AddComponent<Attributes>(entity);
        Attributes* attributes = frame.Unsafe.GetPointer<Attributes>(entity);
        attributes->Entries = new QList<AttributeEntry>(frame.AllocatorHandle, 8);
    }
    
    // Set base attributes from character info
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.Health, characterInfo.MaxHealth);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.Speed, characterInfo.BaseSpeed);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.Armor, characterInfo.BaseArmor);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.Damage, characterInfo.BaseDamage);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.Mana, characterInfo.MaxMana);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.Energy, characterInfo.MaxEnergy);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.AttackSpeed, characterInfo.BaseAttackSpeed);
    AttributesHelper.SetBaseValue(frame, entity, EAttributeType.SkillCooldown, characterInfo.BaseSkillCooldown);
}
```

## Using Attributes in Game Systems

Various game systems leverage the attributes system:

### Movement System

```csharp
// In MovementSystem.cs (simplified)
public override void Update(Frame frame, ref Filter filter)
{
    // Check if movement is currently locked due to stun
    FP stun = AttributesHelper.GetCurrentValue(frame, filter.Entity, EAttributeType.Stun);
    if (stun > 0)
    {
        return;
    }

    // Get character speed from attributes
    FP characterSpeed = AttributesHelper.GetCurrentValue(frame, filter.Entity, EAttributeType.Speed);
    filter.KCC->MaxSpeed = characterSpeed;
    
    // Rest of movement logic...
}
```

### Skill System

```csharp
// In CharacterSkillCreationSystem.cs (simplified)
private void TryCreateSkill(Frame frame, EntityRef entity, FPVector2 position, 
    AssetRef<SkillData> skillDataRef, FPVector2 actionDirection)
{
    SkillData skillData = frame.FindAsset<SkillData>(skillDataRef.Id);
    
    // Check if character has enough resource for skill
    FP currentResourceValue = AttributesHelper.GetCurrentValue(
        frame, entity, skillData.CostType);
        
    if (currentResourceValue < skillData.Cost)
        return;
        
    // Check silence status (prevents skill use)
    FP silenceValue = AttributesHelper.GetCurrentValue(
        frame, entity, EAttributeType.Silence);
        
    if (silenceValue > 0)
        return;
    
    // Rest of skill creation logic...
}
```

### Combat System

```csharp
// In AttackData.cs (simplified)
protected void ApplyDamageToTarget(Frame frame, EntityRef attackEntity, 
    EntityRef target, Attack* attack)
{
    // Skip if target is invalid
    if (!frame.Exists(target) || !frame.Has<Health>(target))
        return;
        
    // Get base damage from attack
    FP baseDamage = Damage;
    
    // Scale damage based on attacker's damage attribute
    if (frame.Exists(attack->Source))
    {
        FP damageMultiplier = AttributesHelper.GetCurrentValue(
            frame, attack->Source, EAttributeType.Damage);
            
        baseDamage *= FP._1 + (damageMultiplier / FP._100);
    }
    
    // Apply damage to target
    HealthSystem.ApplyDamage(frame, target, attack->Source, baseDamage);
}
```

## Character Buffs and Debuffs

Buffs and debuffs use the attributes system:

```csharp
// Speed boost buff implementation (simplified)
public static void ApplySpeedBoost(Frame frame, EntityRef target, FP multiplier, FP duration)
{
    AttributesHelper.ChangeAttribute(
        frame, 
        target, 
        EAttributeType.Speed, 
        EModifierAppliance.Timer, 
        EModifierOperation.Multiply, 
        multiplier, 
        duration);
        
    // Trigger visual effect
    frame.Events.BuffApplied(target, "SpeedBoost");
}

// Stun debuff implementation (simplified)
public static void ApplyStun(Frame frame, EntityRef target, FP duration)
{
    AttributesHelper.ChangeAttribute(
        frame, 
        target, 
        EAttributeType.Stun, 
        EModifierAppliance.Timer, 
        EModifierOperation.Add, 
        FP._1, 
        duration);
        
    // Trigger visual effect
    frame.Events.DebuffApplied(target, "Stun");
}
```

## Specialized Attribute Implementations

For some specialized attributes, the system provides additional helper functions:

```csharp
// From ImmuneSystem.cs - System that handles immunity frames
public static void SetImmortal(Frame frame, EntityRef entity, FP duration)
{
    if (!frame.Exists(entity) || !frame.Has<Health>(entity))
        return;
        
    Health* health = frame.Unsafe.GetPointer<Health>(entity);
    health->IsImmortal = true;
    
    // Set timer to remove immunity
    frame.Timer.Set(entity, "Immunity", duration, () => {
        if (frame.Exists(entity))
        {
            Health* h = frame.Unsafe.GetPointer<Health>(entity);
            h->IsImmortal = false;
        }
    });
}

// From RespawnSystem.cs - Helper to set respawn time
public static void SetRespawnTime(Frame frame, EntityRef entity)
{
    if (!frame.Exists(entity) || !frame.Has<Respawn>(entity))
        return;
        
    Respawn* respawn = frame.Unsafe.GetPointer<Respawn>(entity);
    respawn->RespawnDelay = AttributesHelper.GetCurrentValue(
        frame, entity, EAttributeType.RespawnTime);
}
```

## Best Practices

1. **Flexible Attribute System**: Design attributes to handle a wide variety of game mechanics
2. **Helper Functions**: Create utility functions to simplify common attribute operations
3. **Timed Modifiers**: Use the timer system for temporary buffs and debuffs
4. **Stacking Rules**: Define clear rules for how multiple modifiers combine
5. **Centralized Access**: Access attributes through helper functions for consistency
6. **Data-Driven Design**: Define base attribute values in character data assets
7. **Type Safety**: Use enums for attribute types to prevent errors

## Implementation Notes

1. The attribute system supports various modifier operations for flexibility
2. Modifiers can be permanent, one-time, or duration-based
3. Modifiers are processed in a specific order: additive → multiplicative → min/max/override
4. The system automatically handles expiration of timed modifiers
5. Helper methods simplify common attribute operations
6. All calculations are deterministic for network consistency
7. The attribute component is dynamically sized, allowing for efficient use of memory
---

# 06-game-management-system.md

# Game Management System

This document explains the game management system in the Quantum Twin Stick Shooter, focusing on how game flow, match management, and team mechanics are handled.

## Overview

The game management system in Twin Stick Shooter provides:

1. **Game State Management**: Controls the flow between game states
2. **Match Timing**: Handles countdown, match duration, and overtime
3. **Team Management**: Tracks team scores and determines victory conditions
4. **Game Mode Implementation**: Manages the Coin Grab game mechanics
5. **HFSM-Based Flow**: Uses Hierarchical Finite State Machine for game states

## Core Components

### Global Game State

```csharp
// From Game.qtn
global
{
    FP MatchTimer;
    FP MatchDuration;

    Boolean ControllersEnabled;
    GameState State;

    HFSMData GameManagerHFSM;
}

enum GameState{
    None,
    CharacterSelection,
    Playing,
    Over
}
```

### Team Component

```csharp
// From Team.qtn
component TeamInfo
{
    int Index;
}

struct TeamData
{
    byte Score;
    byte ScoreTimer;
}
```

### Game Manager HFSM

The Game Manager uses a Hierarchical Finite State Machine to control game flow:

```csharp
// GameManagerSystem.cs
[Preserve]
public unsafe class GameManagerSystem : SystemMainThread, 
    ISignalOnCharacterSelectionStart, ISignalOnGameStart, ISignalOnGameOver
{
    public override void OnInit(Frame frame)
    {
        // Initialize game manager HFSM
        HFSMRoot hfsmRoot = frame.FindAsset<HFSMRoot>(frame.RuntimeConfig.GameManagerHFSM.Id);

        HFSMData* hfsmData = &frame.Global->GameManagerHFSM;
        hfsmData->Root = hfsmRoot;
        HFSMManager.Init(frame, hfsmData, default, hfsmRoot);
    }

    public override void Update(Frame frame)
    {
        // Update game manager HFSM
        HFSMManager.Update(frame, frame.DeltaTime, &frame.Global->GameManagerHFSM, default);
    }

    // State change handlers
    public void OnCharacterSelectionStart(Frame frame)
    {
        frame.Global->State = GameState.CharacterSelection;
    }

    public void OnGameStart(Frame frame)
    {
        frame.Global->State = GameState.Playing;
    }

    public void OnGameOver(Frame frame, QBoolean value)
    {
        frame.Global->State = GameState.Over;
    }
}
```

## Game Manager HFSM Definition

The Game Manager HFSM defines the following states and transitions:

```csharp
// Example of game manager HFSM setup (simplified)
public static HFSMRoot CreateGameManagerHFSM()
{
    HFSMRoot root = new HFSMRoot();
    
    // Main states
    var waitingForPlayers = root.AddState("WaitingForPlayers");
    var characterSelection = root.AddState("CharacterSelection");
    var arenaPresentation = root.AddState("ArenaPresentation");
    var countdown = root.AddState("Countdown");
    var playing = root.AddState("Playing");
    var gameOver = root.AddState("GameOver");
    
    // Define transitions
    waitingForPlayers.AddTransition(characterSelection, new HasEnoughPlayers());
    characterSelection.AddTransition(arenaPresentation, new TimerDecision("CharacterSelection", 30));
    arenaPresentation.AddTransition(countdown, new TimerDecision("ArenaPresentation", 5));
    countdown.AddTransition(playing, new TimerDecision("Countdown", 3));
    playing.AddTransition(gameOver, new TimerDecision("Playing", 300));
    playing.AddTransition(gameOver, new TeamHasWon());
    
    // Define state behaviors
    waitingForPlayers.SetEnterAction(new WaitingForPlayersEnter());
    characterSelection.SetEnterAction(new CharacterSelectionEnter());
    arenaPresentation.SetEnterAction(new ArenaPresentationEnter());
    countdown.SetEnterAction(new CountdownEnter());
    playing.SetEnterAction(new PlayingEnter());
    gameOver.SetEnterAction(new GameOverEnter());
    
    return root;
}
```

## Match System

The `MatchSystem` updates match timers and handles match flow:

```csharp
[Preserve]
public unsafe class MatchSystem : SystemMainThread
{
    public override void Update(Frame frame)
    {
        // Only update timer during "Playing" state
        if (frame.Global->State != GameState.Playing)
            return;
            
        // Update match timer
        frame.Global->MatchTimer += frame.DeltaTime;
        
        // Check for time-based match end
        if (frame.Global->MatchTimer >= frame.Global->MatchDuration)
        {
            int winningTeam = DetermineWinningTeam(frame);
            frame.Events.GameOver(winningTeam);
            frame.Signals.OnGameOver(frame, true);
        }
    }
    
    private int DetermineWinningTeam(Frame frame)
    {
        // Get team scores
        TeamData* teams = frame.Global->Teams;
        
        // Find team with highest score
        int winningTeam = 0;
        byte highestScore = teams[0].Score;
        
        for (int i = 1; i < teams.Length; i++)
        {
            if (teams[i].Score > highestScore)
            {
                winningTeam = i;
                highestScore = teams[i].Score;
            }
        }
        
        return winningTeam;
    }
}
```

## Team Data System

The `TeamDataSystem` tracks team scores and monitors victory conditions:

```csharp
[Preserve]
public unsafe class TeamDataSystem : SystemMainThread
{
    // Score threshold for victory
    private const byte SCORE_THRESHOLD = 10;
    
    // Time required to hold score threshold (in seconds)
    private const byte HOLD_TIME_REQUIRED = 15;
    
    // Update interval in frames
    private const byte UPDATE_INTERVAL = 30;
    
    private byte _updateCounter = 0;

    public override void Update(Frame frame)
    {
        // Only update in "Playing" state
        if (frame.Global->State != GameState.Playing)
            return;
            
        // Update at specified interval
        _updateCounter++;
        if (_updateCounter < UPDATE_INTERVAL)
            return;
            
        _updateCounter = 0;
        
        // Count coins for each team
        UpdateTeamScores(frame);
        
        // Check victory conditions
        CheckVictoryConditions(frame);
    }
    
    private void UpdateTeamScores(Frame frame)
    {
        // Reset team scores
        for (int i = 0; i < frame.Global->Teams.Length; i++)
        {
            frame.Global->Teams[i].Score = 0;
        }
        
        // Count coins held by each team
        var characters = frame.Filter<Character, TeamInfo, Inventory>();
        while (characters.NextUnsafe(out EntityRef entity, out Character* character,
            out TeamInfo* teamInfo, out Inventory* inventory))
        {
            byte coinCount = CountCoins(frame, inventory);
            frame.Global->Teams[teamInfo->Index].Score += coinCount;
        }
    }
    
    private byte CountCoins(Frame frame, Inventory* inventory)
    {
        byte count = 0;
        
        // Count coin items in inventory
        for (int i = 0; i < inventory->Items.Length; i++)
        {
            var item = inventory->Items[i];
            if (item.Type == EItemType.Coin)
            {
                count++;
            }
        }
        
        return count;
    }
    
    private void CheckVictoryConditions(Frame frame)
    {
        // Check each team for victory condition
        for (int i = 0; i < frame.Global->Teams.Length; i++)
        {
            TeamData* team = &frame.Global->Teams[i];
            
            // Check if team has enough coins
            if (team->Score >= SCORE_THRESHOLD)
            {
                // Increment score timer
                team->ScoreTimer++;
                
                // Check if timer reached threshold
                if (team->ScoreTimer >= HOLD_TIME_REQUIRED)
                {
                    // Team wins
                    frame.Events.GameOver(i);
                    frame.Signals.OnGameOver(frame, true);
                    return;
                }
            }
            else
            {
                // Reset timer if score drops below threshold
                team->ScoreTimer = 0;
            }
        }
    }
}
```

## Character Selection System

The `CharacterSelectionSystem` handles the pre-match character selection phase:

```csharp
[Preserve]
public unsafe class CharacterSelectionSystem : SystemMainThreadFilter<CharacterSelectionSystem.Filter>,
    ISignalOnCharacterSelectionStart
{
    public struct Filter
    {
        public EntityRef Entity;
        public CharacterSelection* CharacterSelection;
        public PlayerLink* PlayerLink;
    }

    public void OnCharacterSelectionStart(Frame frame)
    {
        // Create character selection entities for each player
        for (int i = 0; i < frame.RuntimeConfig.PlayerCount; i++)
        {
            if (frame.PlayerIsBot(i))
                continue;
                
            EntityRef selectionEntity = frame.Create(frame.RuntimeConfig.CharacterSelectionPrototype);
            
            CharacterSelection* selection = frame.Unsafe.GetPointer<CharacterSelection>(selectionEntity);
            selection->PlayerRef = i;
            
            PlayerLink* playerLink = frame.Unsafe.GetPointer<PlayerLink>(selectionEntity);
            playerLink->PlayerRef = i;
        }
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Process player inputs for character selection
        QuantumDemoInputTopDown* input = frame.GetPlayerInput(filter.PlayerLink->PlayerRef);
        
        // Change character selection based on input
        if (input->MoveDirection.X > FP._0_50 && filter.CharacterSelection->SelectedIndex < 2)
        {
            filter.CharacterSelection->SelectedIndex++;
            frame.Events.CharacterChanged(filter.Entity, filter.CharacterSelection->SelectedIndex);
        }
        else if (input->MoveDirection.X < -FP._0_50 && filter.CharacterSelection->SelectedIndex > 0)
        {
            filter.CharacterSelection->SelectedIndex--;
            frame.Events.CharacterChanged(filter.Entity, filter.CharacterSelection->SelectedIndex);
        }
        
        // Confirm selection
        if (input->Fire && filter.CharacterSelection->IsConfirmed == false)
        {
            filter.CharacterSelection->IsConfirmed = true;
            frame.Events.CharacterConfirmed(filter.Entity, filter.CharacterSelection->SelectedIndex);
            
            // Check if all players have selected
            CheckAllPlayersSelected(frame);
        }
    }
    
    private void CheckAllPlayersSelected(Frame frame)
    {
        // Count confirmed selections
        int confirmedCount = 0;
        int totalPlayers = 0;
        
        var selections = frame.Filter<CharacterSelection>();
        while (selections.Next(out EntityRef entity, out CharacterSelection selection))
        {
            totalPlayers++;
            if (selection.IsConfirmed)
            {
                confirmedCount++;
            }
        }
        
        // If all players confirmed, move to next phase
        if (confirmedCount == totalPlayers && totalPlayers > 0)
        {
            frame.Events.CharacterSelectionComplete();
        }
    }
}
```

## Player Joining System

The `PlayerJoiningSystem` handles players joining and manages substitution with bots:

```csharp
[Preserve]
public unsafe class PlayerJoiningSystem : SystemMainThread
{
    public override void OnInit(Frame frame)
    {
        // Initialize game with a minimum number of players/bots
        if (frame.RuntimeConfig.AutoFillWithBots)
        {
            for (int i = 0; i < frame.RuntimeConfig.MinimumPlayerCount; i++)
            {
                int playerRef = i;
                int teamIndex = i % 2; // Alternate teams
                
                // If player is connected, create player character
                if (!frame.PlayerIsBot(playerRef))
                {
                    CreatePlayerCharacter(frame, playerRef, teamIndex);
                }
                // Otherwise create bot
                else
                {
                    CreateBotCharacter(frame, playerRef, teamIndex);
                }
            }
        }
    }

    private void CreatePlayerCharacter(Frame frame, int playerRef, int teamIndex)
    {
        // Create character entity for player
        EntityRef characterEntity = frame.Create(frame.RuntimeConfig.DefaultCharacterPrototype);
        
        // Setup player link
        PlayerLink* playerLink = frame.Unsafe.GetPointer<PlayerLink>(characterEntity);
        playerLink->PlayerRef = playerRef;
        
        // Setup team info
        TeamInfo* teamInfo = frame.Unsafe.GetPointer<TeamInfo>(characterEntity);
        teamInfo->Index = teamIndex;
        
        // Add bot component (inactive by default)
        Bot* bot = frame.Unsafe.GetPointer<Bot>(characterEntity);
        bot->IsActive = false;
        
        // Setup other character components
        InitializeCharacter(frame, characterEntity);
    }
    
    private void CreateBotCharacter(Frame frame, int playerRef, int teamIndex)
    {
        // Create character entity for bot
        EntityRef characterEntity = frame.Create(frame.RuntimeConfig.DefaultCharacterPrototype);
        
        // Setup player link
        PlayerLink* playerLink = frame.Unsafe.GetPointer<PlayerLink>(characterEntity);
        playerLink->PlayerRef = playerRef;
        
        // Setup team info
        TeamInfo* teamInfo = frame.Unsafe.GetPointer<TeamInfo>(characterEntity);
        teamInfo->Index = teamIndex;
        
        // Setup bot
        AISetupHelper.Botify(frame, characterEntity);
        
        // Setup other character components
        InitializeCharacter(frame, characterEntity);
    }
    
    private void InitializeCharacter(Frame frame, EntityRef entity)
    {
        // Initialize character components
        CharacterInfo characterInfo = frame.FindAsset<CharacterInfo>(frame.RuntimeConfig.DefaultCharacterInfo.Id);
        
        // Initialize attributes
        InitializeAttributes(frame, entity, characterInfo);
        
        // Initialize inventory
        Inventory* inventory = frame.Unsafe.GetPointer<Inventory>(entity);
        inventory->Items = new QList<InventoryItem>(frame.AllocatorHandle, 5);
        
        // Initialize health
        Health* health = frame.Unsafe.GetPointer<Health>(entity);
        health->Current = characterInfo.MaxHealth;
        
        // Initialize respawn
        Respawn* respawn = frame.Unsafe.GetPointer<Respawn>(entity);
        respawn->RespawnPosition = GetRespawnPosition(frame, frame.Get<TeamInfo>(entity).Index);
        
        // Set random name for player/bot
        Player* player = frame.Unsafe.GetPointer<Player>(entity);
        player->Name = GetRandomName(frame);
    }
    
    private FPVector2 GetRespawnPosition(Frame frame, int teamIndex)
    {
        // Find suitable respawn position based on team
        // ... (implementation details)
        
        return FPVector2.Zero; // Simplified
    }
    
    private string GetRandomName(Frame frame)
    {
        // Get random name from list
        string[] names = {
            "Striker", "Phantom", "Viper", "Shadow", "Blitz",
            "Thunder", "Havoc", "Nova", "Rogue", "Spectre"
        };
        
        int randomIndex = frame.RandomNext() % names.Length;
        return names[randomIndex];
    }
}
```

## Respawn System

The `RespawnSystem` handles character respawning after death:

```csharp
[Preserve]
public unsafe class RespawnSystem : SystemMainThreadFilter<RespawnSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Respawn* Respawn;
        public Health* Health;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Only process dead characters
        if (!filter.Health->IsDead || !filter.Respawn->IsDead)
            return;
        
        // Update respawn timer
        filter.Respawn->Timer += frame.DeltaTime;
        
        // Check if respawn time elapsed
        if (filter.Respawn->Timer >= filter.Respawn->RespawnDelay)
        {
            // Reset respawn data
            filter.Respawn->Timer = 0;
            filter.Respawn->IsDead = false;
            
            // Reset health
            filter.Health->IsDead = false;
            filter.Health->Current = AttributesHelper.GetCurrentValue(frame, filter.Entity, EAttributeType.Health);
            
            // Set temporary immortality
            frame.Signals.OnSetCharacterImmune(filter.Entity, FP._3);
            
            // Position character at respawn point
            Transform2D* transform = frame.Unsafe.GetPointer<Transform2D>(filter.Entity);
            transform->Position = filter.Respawn->RespawnPosition;
            
            // Clear inventory (drop coins)
            if (frame.Has<Inventory>(filter.Entity))
            {
                Inventory* inventory = frame.Unsafe.GetPointer<Inventory>(filter.Entity);
                DropAllCoins(frame, filter.Entity, inventory, transform->Position);
                inventory->Items.Clear();
            }
            
            // Send respawn event
            frame.Events.CharacterRespawned(filter.Entity);
        }
    }
    
    private void DropAllCoins(Frame frame, EntityRef character, Inventory* inventory, FPVector2 position)
    {
        // Count coins in inventory
        int coinCount = 0;
        for (int i = 0; i < inventory->Items.Length; i++)
        {
            if (inventory->Items[i].Type == EItemType.Coin)
            {
                coinCount++;
            }
        }
        
        // Spawn dropped coins
        for (int i = 0; i < coinCount; i++)
        {
            // Calculate random drop position
            FP angle = FP.FromFloat_UNSAFE(frame.RandomInRange(0, 360));
            FP distance = FP.FromFloat_UNSAFE(frame.RandomInRange(1, 3));
            FPVector2 dropPos = position + FPVector2.FromAngle(angle) * distance;
            
            // Create coin entity
            EntityRef coinEntity = frame.Create(frame.RuntimeConfig.CoinPrototype);
            
            // Set position
            Transform2D* coinTransform = frame.Unsafe.GetPointer<Transform2D>(coinEntity);
            coinTransform->Position = dropPos;
        }
    }
}
```

## Objective Point System (Coins)

The `ObjectivePointSystem` manages collectible coins in the game:

```csharp
[Preserve]
public unsafe class ObjectivePointSystem : SystemMainThreadFilter<ObjectivePointSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public ObjectivePoint* ObjectivePoint;
        public Transform2D* Transform;
        public PhysicsCollider2D* Collider;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Skip if not active
        if (!filter.ObjectivePoint->IsActive)
            return;
            
        // Check for characters in range
        var hits = Physics2D.OverlapShape(frame, filter.Collider->Shape, *filter.Transform);
        foreach (var hit in hits)
        {
            // Only process character entities
            if (!frame.Has<Character>(hit) || !frame.Has<Inventory>(hit))
                continue;
                
            // Skip dead characters
            if (frame.Has<Health>(hit) && frame.Get<Health>(hit).IsDead)
                continue;
                
            // Add coin to character inventory
            AddCoinToInventory(frame, hit);
            
            // Deactivate coin
            filter.ObjectivePoint->IsActive = false;
            
            // Set respawn timer
            frame.Timer.Set(filter.Entity, "RespawnTimer", frame.RuntimeConfig.CoinRespawnTime, () => {
                if (frame.Exists(filter.Entity))
                {
                    ObjectivePoint* point = frame.Unsafe.GetPointer<ObjectivePoint>(filter.Entity);
                    point->IsActive = true;
                }
            });
            
            // Send collection event
            frame.Events.CoinCollected(hit);
            
            break;
        }
    }
    
    private void AddCoinToInventory(Frame frame, EntityRef character)
    {
        Inventory* inventory = frame.Unsafe.GetPointer<Inventory>(character);
        
        // Create coin item
        InventoryItem coinItem = new InventoryItem
        {
            Type = EItemType.Coin,
            Value = 1
        };
        
        // Add to inventory
        inventory->Items.Add(frame, coinItem);
    }
}
```

## Game State-Specific Commands

Various commands handle specific game state changes:

```csharp
// Trigger character selection phase
public unsafe class TriggerCharacterSelectionCommand : Command
{
    public override void Execute(Frame frame)
    {
        frame.Events.StartCharacterSelection();
        frame.Signals.OnCharacterSelectionStart(frame);
    }
}

// Trigger arena presentation before match
public unsafe class TriggerArenaPresentationCommand : Command
{
    public override void Execute(Frame frame)
    {
        frame.Events.ArenaPresentation();
    }
}

// Trigger match countdown
public unsafe class TriggerCountdownCommand : Command
{
    public override void Execute(Frame frame)
    {
        frame.Events.CountdownStarted();
        
        // Disable player controls during countdown
        frame.Signals.OnToggleControllers(frame, false);
    }
}

// Start the actual match
public unsafe class StartGameCommand : Command
{
    public override void Execute(Frame frame)
    {
        // Set match duration
        frame.Global->MatchDuration = frame.RuntimeConfig.MatchDuration;
        
        // Reset match timer
        frame.Global->MatchTimer = 0;
        
        // Enable player controls
        frame.Signals.OnToggleControllers(frame, true);
        
        // Trigger game start
        frame.Events.CountdownStopped();
        frame.Signals.OnGameStart(frame);
    }
}
```

## HFSM Decision Classes

Custom HFSM decision classes implement game state transitions:

```csharp
// Check if a team has won the match
public class TeamHasWon : HFSMDecision
{
    private const byte SCORE_THRESHOLD = 10;
    private const byte HOLD_TIME_REQUIRED = 15;
    
    public override Boolean Decide(Frame frame, EntityRef entity)
    {
        // Check each team
        for (int i = 0; i < frame.Global->Teams.Length; i++)
        {
            TeamData* team = &frame.Global->Teams[i];
            
            // Check win condition
            if (team->Score >= SCORE_THRESHOLD && team->ScoreTimer >= HOLD_TIME_REQUIRED)
            {
                return true;
            }
        }
        
        return false;
    }
}

// Check if enough players have joined
public class HasEnoughPlayers : HFSMDecision
{
    public override Boolean Decide(Frame frame, EntityRef entity)
    {
        int playerCount = 0;
        
        // Count connected players
        for (int i = 0; i < frame.RuntimeConfig.PlayerCount; i++)
        {
            if (!frame.PlayerIsBot(i))
            {
                playerCount++;
            }
        }
        
        // Check if minimum player count reached
        return playerCount >= frame.RuntimeConfig.MinimumPlayerCountToStart;
    }
}
```

## Best Practices

1. **HFSM for Game Flow**: Use Hierarchical Finite State Machine for game state management
2. **Clear Game States**: Define explicit game states with clear transitions
3. **Team-Based Logic**: Organize team data and victory conditions
4. **Modular Systems**: Separate concerns into distinct systems
5. **Event-Based Communication**: Use events for synchronizing game state changes
6. **Timed State Transitions**: Use timers for state duration management
7. **Data-Driven Configuration**: Use runtime config for game parameters

## Implementation Notes

1. The game manager uses an HFSM to control the overall game flow
2. The coin grab game mode tracks team scores and victory conditions
3. Character selection occurs before the match starts
4. Players can be replaced by bots when they disconnect
5. All game state changes are communicated through events
6. Match timing and score tracking use deterministic calculations
7. Game configuration parameters are defined in runtime config
---

# 07-inventory-system.md

# Inventory System

This document explains the inventory system in the Quantum Twin Stick Shooter, focusing on how items (especially coins) are collected, stored, and managed.

## Overview

The inventory system in Twin Stick Shooter provides:

1. **Item Collection**: Mechanism for collecting coins and other items
2. **Item Storage**: Data structure for storing collected items
3. **Coin Management**: Central to the Coin Grab game mode
4. **Dropping Items**: On character death
5. **Item Effects**: Applied when items are collected

## Core Components

### Inventory Component

```csharp
// From Inventory.qtn
component Inventory
{
    QList<InventoryItem> Items;
}

struct InventoryItem
{
    EItemType Type;
    FP Value;
}

enum EItemType
{
    None,
    Coin,
    PowerUp,
    HealthKit
}
```

### ObjectivePoint (Collectible) Component

```csharp
// From ObjectivePoint.qtn
component ObjectivePoint
{
    Boolean IsActive;
    EItemType Type;
    FP Value;
}
```

## InventorySystem Implementation

The `InventorySystem` handles managing inventories and applying effects:

```csharp
[Preserve]
public unsafe class InventorySystem : SystemMainThreadFilter<InventorySystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public Inventory* Inventory;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Process inventory items for effects
        for (int i = 0; i < filter.Inventory->Items.Length; i++)
        {
            InventoryItem* item = &filter.Inventory->Items[i];
            
            // Apply item effects
            switch (item->Type)
            {
                case EItemType.PowerUp:
                    ApplyPowerUpEffect(frame, filter.Entity, item);
                    // Remove consumed item
                    filter.Inventory->Items.RemoveAt(i);
                    i--;
                    break;
                    
                case EItemType.HealthKit:
                    ApplyHealthKitEffect(frame, filter.Entity, item);
                    // Remove consumed item
                    filter.Inventory->Items.RemoveAt(i);
                    i--;
                    break;
                
                // Coins are persistent items that don't have immediate effects
                case EItemType.Coin:
                    // No immediate effect, just stored for game objective
                    break;
            }
        }
    }
    
    private void ApplyPowerUpEffect(Frame frame, EntityRef entity, InventoryItem* item)
    {
        // Apply temporary speed boost
        AttributesHelper.ChangeAttribute(
            frame, 
            entity, 
            EAttributeType.Speed, 
            EModifierAppliance.Timer, 
            EModifierOperation.Multiply, 
            FP._0_50, // 50% speed boost
            FP._5);   // 5 second duration
            
        // Send event for visualization
        frame.Events.PowerUpActivated(entity, "SpeedBoost");
    }
    
    private void ApplyHealthKitEffect(Frame frame, EntityRef entity, InventoryItem* item)
    {
        // Only apply if character has health component
        if (!frame.Has<Health>(entity))
            return;
            
        Health* health = frame.Unsafe.GetPointer<Health>(entity);
        
        // Skip if character is dead
        if (health->IsDead)
            return;
            
        // Calculate health to restore
        FP maxHealth = AttributesHelper.GetCurrentValue(frame, entity, EAttributeType.Health);
        FP healAmount = maxHealth * item->Value;
        
        // Apply healing
        health->Current = FPMath.Min(health->Current + healAmount, maxHealth);
        
        // Send event for visualization
        frame.Events.CharacterHealed(entity);
    }
}
```

## ObjectivePointSystem Implementation

The `ObjectivePointSystem` handles collectible objects in the world:

```csharp
[Preserve]
public unsafe class ObjectivePointSystem : SystemMainThreadFilter<ObjectivePointSystem.Filter>
{
    public struct Filter
    {
        public EntityRef Entity;
        public ObjectivePoint* ObjectivePoint;
        public Transform2D* Transform;
        public PhysicsCollider2D* Collider;
    }

    public override void Update(Frame frame, ref Filter filter)
    {
        // Skip if not active
        if (!filter.ObjectivePoint->IsActive)
            return;
            
        // Check for characters in range
        var hits = Physics2D.OverlapShape(frame, filter.Collider->Shape, *filter.Transform);
        foreach (var hit in hits)
        {
            // Only process character entities
            if (!frame.Has<Character>(hit) || !frame.Has<Inventory>(hit))
                continue;
                
            // Skip dead characters
            if (frame.Has<Health>(hit) && frame.Get<Health>(hit).IsDead)
                continue;
                
            // Add item to character inventory
            AddItemToInventory(frame, hit, filter.ObjectivePoint->Type, filter.ObjectivePoint->Value);
            
            // Deactivate collectible
            filter.ObjectivePoint->IsActive = false;
            
            // Set respawn timer based on item type
            FP respawnTime = GetRespawnTimeForItem(frame, filter.ObjectivePoint->Type);
            frame.Timer.Set(filter.Entity, "RespawnTimer", respawnTime, () => {
                if (frame.Exists(filter.Entity))
                {
                    ObjectivePoint* point = frame.Unsafe.GetPointer<ObjectivePoint>(filter.Entity);
                    point->IsActive = true;
                }
            });
            
            // Send collection event
            SendCollectionEvent(frame, hit, filter.ObjectivePoint->Type);
            
            break;
        }
    }
    
    private void AddItemToInventory(Frame frame, EntityRef character, EItemType itemType, FP value)
    {
        Inventory* inventory = frame.Unsafe.GetPointer<Inventory>(character);
        
        // Create item
        InventoryItem item = new InventoryItem
        {
            Type = itemType,
            Value = value
        };
        
        // Add to inventory
        inventory->Items.Add(frame, item);
    }
    
    private FP GetRespawnTimeForItem(Frame frame, EItemType itemType)
    {
        // Different respawn times based on item type
        switch (itemType)
        {
            case EItemType.Coin:
                return frame.RuntimeConfig.CoinRespawnTime;
                
            case EItemType.PowerUp:
                return frame.RuntimeConfig.PowerUpRespawnTime;
                
            case EItemType.HealthKit:
                return frame.RuntimeConfig.HealthKitRespawnTime;
                
            default:
                return FP._10; // Default 10 seconds
        }
    }
    
    private void SendCollectionEvent(Frame frame, EntityRef character, EItemType itemType)
    {
        // Send appropriate event based on item type
        switch (itemType)
        {
            case EItemType.Coin:
                frame.Events.CoinCollected(character);
                break;
                
            case EItemType.PowerUp:
                frame.Events.PowerUpCollected(character);
                break;
                
            case EItemType.HealthKit:
                frame.Events.HealthKitCollected(character);
                break;
        }
    }
}
```

## ItemDrop System

The `ItemDropSystem` handles dropping items when characters die:

```csharp
[Preserve]
public unsafe class ItemDropSystem : SystemMainThread, ISignalOnCharacterDefeated
{
    public void OnCharacterDefeated(Frame frame, EntityRef character)
    {
        // Skip if no inventory
        if (!frame.Has<Inventory>(character) || !frame.Has<Transform2D>(character))
            return;
            
        Inventory* inventory = frame.Unsafe.GetPointer<Inventory>(character);
        Transform2D* transform = frame.Unsafe.GetPointer<Transform2D>(character);
        
        // Count items to drop
        int coinCount = 0;
        
        for (int i = 0; i < inventory->Items.Length; i++)
        {
            if (inventory->Items[i].Type == EItemType.Coin)
            {
                coinCount++;
            }
        }
        
        // Drop all coins
        DropCoins(frame, transform->Position, coinCount);
        
        // Clear inventory
        inventory->Items.Clear();
    }
    
    private void DropCoins(Frame frame, FPVector2 position, int count)
    {
        // No coins to drop
        if (count <= 0)
            return;
            
        // Spawn coins in a random pattern around the drop position
        for (int i = 0; i < count; i++)
        {
            // Calculate random drop position
            FP angle = FP.FromFloat_UNSAFE(frame.RandomInRange(0, 360));
            FP distance = FP.FromFloat_UNSAFE(frame.RandomInRange(1, 3));
            FPVector2 dropPos = position + FPVector2.FromAngle(angle) * distance;
            
            // Create coin entity
            EntityRef coinEntity = frame.Create(frame.RuntimeConfig.CoinPrototype);
            
            // Position the coin
            Transform2D* coinTransform = frame.Unsafe.GetPointer<Transform2D>(coinEntity);
            coinTransform->Position = dropPos;
            
            // Activate the objective point
            ObjectivePoint* objectivePoint = frame.Unsafe.GetPointer<ObjectivePoint>(coinEntity);
            objectivePoint->IsActive = true;
            objectivePoint->Type = EItemType.Coin;
            objectivePoint->Value = FP._1;
        }
    }
}
```

## Team Score Calculation

The inventory system is central to the Coin Grab game mode's scoring:

```csharp
// From TeamDataSystem.cs (simplified)
private void UpdateTeamScores(Frame frame)
{
    // Reset team scores
    for (int i = 0; i < frame.Global->Teams.Length; i++)
    {
        frame.Global->Teams[i].Score = 0;
    }
    
    // Count coins held by each team
    var characters = frame.Filter<Character, TeamInfo, Inventory>();
    while (characters.NextUnsafe(out EntityRef entity, out Character* character,
        out TeamInfo* teamInfo, out Inventory* inventory))
    {
        byte coinCount = CountCoins(frame, inventory);
        frame.Global->Teams[teamInfo->Index].Score += coinCount;
    }
}

private byte CountCoins(Frame frame, Inventory* inventory)
{
    byte count = 0;
    
    // Count coin items in inventory
    for (int i = 0; i < inventory->Items.Length; i++)
    {
        var item = inventory->Items[i];
        if (item.Type == EItemType.Coin)
        {
            count++;
        }
    }
    
    return count;
}
```

## Item Spawner System

The `ItemSpawnerSystem` handles spawning collectibles at the start of the match:

```csharp
[Preserve]
public unsafe class ItemSpawnerSystem : SystemMainThread, ISignalOnGameStart
{
    public void OnGameStart(Frame frame)
    {
        // Spawn coins based on map data
        SpawnItems(frame, EItemType.Coin, frame.RuntimeConfig.CoinSpawnPositions);
        
        // Spawn power-ups
        SpawnItems(frame, EItemType.PowerUp, frame.RuntimeConfig.PowerUpSpawnPositions);
        
        // Spawn health kits
        SpawnItems(frame, EItemType.HealthKit, frame.RuntimeConfig.HealthKitSpawnPositions);
    }
    
    private void SpawnItems(Frame frame, EItemType itemType, FPVector2[] positions)
    {
        // No positions to spawn at
        if (positions == null || positions.Length == 0)
            return;
            
        // Get appropriate prototype based on item type
        AssetRef<EntityPrototype> prototype = GetPrototypeForItemType(frame, itemType);
        if (!prototype.Id.IsValid)
            return;
            
        // Spawn at each position
        for (int i = 0; i < positions.Length; i++)
        {
            // Create entity
            EntityRef itemEntity = frame.Create(prototype);
            
            // Set position
            Transform2D* transform = frame.Unsafe.GetPointer<Transform2D>(itemEntity);
            transform->Position = positions[i];
            
            // Configure objective point
            ObjectivePoint* objectivePoint = frame.Unsafe.GetPointer<ObjectivePoint>(itemEntity);
            objectivePoint->IsActive = true;
            objectivePoint->Type = itemType;
            objectivePoint->Value = GetValueForItemType(itemType);
        }
    }
    
    private AssetRef<EntityPrototype> GetPrototypeForItemType(Frame frame, EItemType itemType)
    {
        switch (itemType)
        {
            case EItemType.Coin:
                return frame.RuntimeConfig.CoinPrototype;
                
            case EItemType.PowerUp:
                return frame.RuntimeConfig.PowerUpPrototype;
                
            case EItemType.HealthKit:
                return frame.RuntimeConfig.HealthKitPrototype;
                
            default:
                return default;
        }
    }
    
    private FP GetValueForItemType(EItemType itemType)
    {
        switch (itemType)
        {
            case EItemType.Coin:
                return FP._1;
                
            case EItemType.PowerUp:
                return FP._0_50; // 50% boost
                
            case EItemType.HealthKit:
                return FP._0_25; // 25% of max health
                
            default:
                return FP._0;
        }
    }
}
```

## Unity View Integration

The inventory system connects to Unity visualization:

```csharp
// In CharacterView.cs (Unity side, simplified)
public class CharacterView : QuantumMonoBehaviour
{
    public GameObject coinVisual;
    public ParticleSystem powerUpEffect;
    public ParticleSystem healthEffect;
    
    private int _lastCoinCount = 0;
    
    protected override void OnEntityInstantiated()
    {
        base.OnEntityInstantiated();
        
        // Hide coin visual initially
        coinVisual.SetActive(false);
    }
    
    protected override void OnEntityUpdated(bool wasSet)
    {
        base.OnEntityUpdated(wasSet);
        
        if (!IsEntityValid)
            return;
            
        // Update coin visual
        int coinCount = GetCoinCount();
        
        if (coinCount > 0)
        {
            coinVisual.SetActive(true);
        }
        else
        {
            coinVisual.SetActive(false);
        }
        
        // Play effects if coin count changed
        if (coinCount > _lastCoinCount)
        {
            AudioManager.Instance.PlaySound("coin_pickup");
        }
        else if (coinCount < _lastCoinCount)
        {
            AudioManager.Instance.PlaySound("coin_drop");
        }
        
        _lastCoinCount = coinCount;
    }
    
    private int GetCoinCount()
    {
        Frame frame = QuantumGame.Current.Frames.Predicted;
        
        if (!frame.Exists(EntityRef) || !frame.Has<Inventory>(EntityRef))
            return 0;
            
        Inventory inventory = frame.Get<Inventory>(EntityRef);
        int count = 0;
        
        // Count coins
        for (int i = 0; i < inventory.Items.Length; i++)
        {
            if (inventory.Items[i].Type == EItemType.Coin)
            {
                count++;
            }
        }
        
        return count;
    }
    
    // Called by events
    public void OnPowerUpCollected()
    {
        powerUpEffect.Play();
        AudioManager.Instance.PlaySound("powerup_pickup");
    }
    
    public void OnHealthKitCollected()
    {
        healthEffect.Play();
        AudioManager.Instance.PlaySound("health_pickup");
    }
}
```

## Best Practices

1. **Simple Inventory Structure**: Keep the inventory system straightforward for a fast-paced game
2. **Event-Based Visualization**: Use events to synchronize inventory changes with visual effects
3. **Type-Based Item Handling**: Use enum types to differentiate item behaviors
4. **Team-Based Coin Counting**: Calculate team scores based on aggregated inventories
5. **Automatic Item Respawning**: Use timers to respawn collected items
6. **Physics-Based Collection**: Use physics triggers for item collection
7. **Deterministic Item Dropping**: Ensure consistent behavior for dropped items

## Implementation Notes

1. The inventory system uses a simple list structure for storing items
2. Coins are the primary collectible in the Coin Grab game mode
3. Items are collected through physics collision detection
4. Items automatically respawn after being collected
5. Characters drop all coins when they die
6. Team scores are calculated by counting coins in all team members' inventories
7. All inventory operations are fully deterministic for network consistency
---

# 08-unity-integration.md

# Unity Integration

This document explains how the Quantum Twin Stick Shooter integrates with Unity, focusing on the connection between the deterministic simulation and the visual representation.

## Overview

The Unity integration in Twin Stick Shooter provides:

1. **Simulation-View Separation**: Clear separation between deterministic logic and visual representation
2. **Event-Based Communication**: One-way communication from simulation to view
3. **Input Handling**: Collection of player input from Unity to Quantum
4. **Visual Feedback**: Representation of game state through animations and effects
5. **UI Elements**: Game interface showing scores, timers, and other information

## Architecture

### Separation of Concerns

```
Quantum (Simulation)  →  Events  →  Unity (View)
           ↑                           ↓
           └───────── Input ──────────┘
```

- **Simulation**: Deterministic game logic running in Quantum
- **View**: Visual representation in Unity
- **Events**: One-way communication from simulation to view
- **Input**: Player commands from Unity to simulation

## Core Unity Components

### CustomViewContext

The `CustomViewContext` serves as a central hub for view-related references:

```csharp
// From TwinStickShooter/Scripts/GameView/CustomViewContext.cs
public class CustomViewContext : MonoBehaviour
{
    public static CustomViewContext Instance;
    
    public Camera MainCamera;
    public CharacterView LocalView { get; set; }
    public HUDView HUD;
    public GameplayRoomManager RoomManager;
    
    private void Awake()
    {
        Instance = this;
    }
    
    public void OnLocalPlayerInstantiated(CharacterView view)
    {
        LocalView = view;
        
        // Setup camera to follow player
        if (MainCamera != null && MainCamera.TryGetComponent<CameraFollow>(out var cameraFollow))
        {
            cameraFollow.SetTarget(view.transform);
        }
        
        // Update HUD
        if (HUD != null)
        {
            HUD.OnLocalPlayerInstantiated(view);
        }
    }
}
```

### EntityViewLinker

The `EntityViewLinker` handles connecting Quantum entities to Unity GameObjects:

```csharp
// From TwinStickShooter/Scripts/GameView/EntityViewLinker.cs
public class EntityViewLinker : QuantumCallbacks
{
    public Dictionary<EntityRef, QuantumMonoBehaviour> EntityViews = new Dictionary<EntityRef, QuantumMonoBehaviour>();
    
    public override void OnEntityDestroyed(EntityRef entityRef)
    {
        // Remove destroyed entities from tracking
        if (EntityViews.TryGetValue(entityRef, out var view))
        {
            if (view != null)
            {
                Destroy(view.gameObject);
            }
            
            EntityViews.Remove(entityRef);
        }
    }
    
    public void RegisterView(EntityRef entityRef, QuantumMonoBehaviour view)
    {
        EntityViews[entityRef] = view;
    }
    
    public T GetView<T>(EntityRef entityRef) where T : QuantumMonoBehaviour
    {
        if (EntityViews.TryGetValue(entityRef, out var view))
        {
            return view as T;
        }
        
        return null;
    }
}
```

### QuantumInstantiator

The `QuantumInstantiator` creates Unity GameObjects for Quantum entities:

```csharp
// From TwinStickShooter/Scripts/GameView/QuantumInstantiator.cs
public class QuantumInstantiator : EntityViewParentBinder
{
    public override void OnEntityCreatedEvent(EntityView view, EntityCreatedEventArgs args)
    {
        base.OnEntityCreatedEvent(view, args);
        
        // Get entity view linker
        var entityViewLinker = QuantumCallback.Find<EntityViewLinker>();
        if (entityViewLinker != null)
        {
            entityViewLinker.RegisterView(args.EntityRef, view.GetComponent<QuantumMonoBehaviour>());
        }
        
        // If this is a character view and owned by local player
        CharacterView characterView = view.GetComponent<CharacterView>();
        if (characterView != null)
        {
            Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
            int playerRef = frame.Get<PlayerLink>(args.EntityRef).PlayerRef;
            
            if (playerRef == QuantumRunner.Default.Game.PlayerInputs.LocalInput.Player)
            {
                // Notify that local player has been instantiated
                characterView.IsLocalPlayer = true;
                CustomViewContext.Instance.OnLocalPlayerInstantiated(characterView);
                CharacterView.OnLocalPlayerInstantiated?.Invoke(characterView);
            }
        }
    }
}
```

## Character View

The `CharacterView` represents a character in Unity:

```csharp
// From TwinStickShooter/Scripts/GameView/CharacterView.cs
public class CharacterView : EntityView
{
    public static Action<CharacterView> OnLocalPlayerInstantiated;
    
    public bool IsLocalPlayer { get; set; }
    
    [Header("Visual Components")]
    public Animator animator;
    public SpriteRenderer characterSprite;
    public GameObject coinVisual;
    
    [Header("Effect Prefabs")]
    public GameObject deathEffect;
    public GameObject respawnEffect;
    public GameObject damageEffect;
    public GameObject healEffect;
    
    // Animation parameter hashes
    private int _movingHash;
    private int _attackHash;
    private int _deadHash;
    
    private Vector2 _lastPosition;
    private bool _isDead;
    
    protected override void OnAwake()
    {
        base.OnAwake();
        
        // Cache animation hashes
        _movingHash = Animator.StringToHash("IsMoving");
        _attackHash = Animator.StringToHash("Attack");
        _deadHash = Animator.StringToHash("IsDead");
        
        _lastPosition = transform.position;
    }
    
    public override void OnEntityDestroyed()
    {
        base.OnEntityDestroyed();
        
        if (IsLocalPlayer)
        {
            IsLocalPlayer = false;
            CustomViewContext.Instance.LocalView = null;
        }
    }
    
    protected override void OnEntityRender(EntityRef entityRef, Frame frame)
    {
        base.OnEntityRender(entityRef, frame);
        
        if (!frame.Exists(entityRef))
            return;
            
        // Update position and rotation
        if (frame.Has<Transform2D>(entityRef))
        {
            var transform2D = frame.Get<Transform2D>(entityRef);
            transform.position = transform2D.Position.ToUnityVector3();
            transform.rotation = Quaternion.Euler(0, 0, transform2D.Rotation.AsFloat * Mathf.Rad2Deg);
        }
        
        // Update character visuals
        if (frame.Has<Health>(entityRef))
        {
            var health = frame.Get<Health>(entityRef);
            bool isDead = health.IsDead;
            
            // State change detection
            if (_isDead != isDead)
            {
                _isDead = isDead;
                
                if (isDead)
                {
                    Instantiate(deathEffect, transform.position, Quaternion.identity);
                }
                
                animator.SetBool(_deadHash, isDead);
            }
        }
        
        // Update movement animation
        Vector2 currentPosition = transform.position;
        bool isMoving = Vector2.Distance(currentPosition, _lastPosition) > 0.01f;
        animator.SetBool(_movingHash, isMoving);
        _lastPosition = currentPosition;
        
        // Update team color
        if (frame.Has<TeamInfo>(entityRef))
        {
            var teamInfo = frame.Get<TeamInfo>(entityRef);
            characterSprite.color = GetTeamColor(teamInfo.Index);
        }
        
        // Update coin visual
        if (frame.Has<Inventory>(entityRef))
        {
            var inventory = frame.Get<Inventory>(entityRef);
            bool hasCoin = false;
            
            for (int i = 0; i < inventory.Items.Length; i++)
            {
                if (inventory.Items[i].Type == EItemType.Coin)
                {
                    hasCoin = true;
                    break;
                }
            }
            
            coinVisual.SetActive(hasCoin);
        }
    }
    
    private Color GetTeamColor(int teamIndex)
    {
        return teamIndex == 0 ? Color.blue : Color.red;
    }
    
    // Event handlers
    public void OnRespawned()
    {
        Instantiate(respawnEffect, transform.position, Quaternion.identity);
    }
    
    public void OnDamaged()
    {
        Instantiate(damageEffect, transform.position, Quaternion.identity);
    }
    
    public void OnHealed()
    {
        Instantiate(healEffect, transform.position, Quaternion.identity);
    }
    
    public void OnAttack()
    {
        animator.SetTrigger(_attackHash);
    }
}
```

## Input Handling

The `TopDownInput` component collects player input for the simulation:

```csharp
// From TwinStickShooter/Scripts/TopDownInput.cs
namespace TwinStickShooter
{
  using Photon.Deterministic;
  using Quantum;
  using UnityEngine;
  using UnityEngine.InputSystem;

  public class TopDownInput : MonoBehaviour
  {
    public FP AimSensitivity = 5;
    public CustomViewContext ViewContext;
    
    private FPVector2 _lastDirection = new FPVector2();
    private AttackPreview _attackPreview;
    private PlayerInput _playerInput;

    public bool IsInverseControl { get; set; } = false;

    private void Start()
    {
      _playerInput = GetComponent<PlayerInput>();
    }

    private void OnEnable()
    {
      CharacterView.OnLocalPlayerInstantiated += OnLocalPlayerInstantiated;
      QuantumCallback.Subscribe(this, (CallbackPollInput callback) => PollInput(callback));
    }

    private void OnDisable()
    {
      CharacterView.OnLocalPlayerInstantiated -= OnLocalPlayerInstantiated;
    }

    private void OnLocalPlayerInstantiated(CharacterView playerView)
    {
      if (_attackPreview != null)
      {
        Destroy(_attackPreview.gameObject);
      }
      _attackPreview = ViewContext.LocalView.GetComponentInChildren<AttackPreview>(true);
      _attackPreview.transform.parent = null;
    }

    private void Update()
    {
      if (_attackPreview != null
#if UNITY_ANDROID
			&& _playerInput.actions["Fire"].IsPressed() == false
			&& _playerInput.actions["Special"].IsPressed() == false
#endif
#if UNITY_STANDALONE || UNITY_WEBGL
          && _playerInput.actions["MouseFire"].IsPressed() == false
          && _playerInput.actions["MouseSpecial"].IsPressed() == false
#endif
         )
      {
        _attackPreview.gameObject.SetActive(false);
      }
    }

    public void PollInput(CallbackPollInput callback)
    {
      Quantum.QuantumDemoInputTopDown input = new Quantum.QuantumDemoInputTopDown();

      FPVector2 directional = _playerInput.actions["Move"].ReadValue<Vector2>().ToFPVector2();
      input.MoveDirection = IsInverseControl == true ? -directional : directional;

#if UNITY_ANDROID
		input.Fire = _playerInput.actions["Fire"].IsPressed();
		input.AltFire = _playerInput.actions["Special"].IsPressed();
#endif
#if UNITY_STANDALONE || UNITY_WEBGL
      input.Fire = _playerInput.actions["MouseFire"].IsPressed();
      input.AltFire = _playerInput.actions["MouseSpecial"].IsPressed();
#endif

      if (input.Fire == true)
      {
        _lastDirection = _playerInput.actions["AimBasic"].ReadValue<Vector2>().ToFPVector2();
        _lastDirection *= AimSensitivity;
      }

      if (input.AltFire == true)
      {
        _lastDirection = _playerInput.actions["AimSpecial"].ReadValue<Vector2>().ToFPVector2();
        _lastDirection *= AimSensitivity;
      }

      FPVector2 actionVector = default;
#if UNITY_STANDALONE || UNITY_WEBGL
      if (_playerInput.currentControlScheme != null
          && _playerInput.currentControlScheme.Contains("Joystick"))
      {
        actionVector = IsInverseControl ? -_lastDirection : _lastDirection;
        input.AimDirection = actionVector;
      }
      else
      {
        actionVector = GetDirectionToMouse();
        input.AimDirection = actionVector;
      }

      if ((input.Fire == true || input.AltFire == true) && input.AimDirection != FPVector2.Zero)
      {
        _attackPreview.gameObject.SetActive(true);
        _attackPreview.UpdateAttackPreview(actionVector, input.AltFire);
      }

      callback.SetInput(input, DeterministicInputFlags.Repeatable);

#elif UNITY_ANDROID
		actionVector = IsInverseControl ? -_lastDirection : _lastDirection;
    input.AimDirection = actionVector;

		if ((input.Fire == true || input.AltFire == true) && actionVector != FPVector2.Zero)
		{
			_attackPreview.gameObject.SetActive(true);
			_attackPreview.UpdateAttackPreview(actionVector, input.AltFire);
		}
		callback.SetInput(input, DeterministicInputFlags.Repeatable);
#endif
    }

    private FPVector2 GetDirectionToMouse()
    {
      if (QuantumRunner.Default == null || QuantumRunner.Default.Game == null)
        return default;

      Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
      if (frame == null)
        return default;

      if (ViewContext.LocalView == null || frame.Exists(ViewContext.LocalView.EntityRef) == false)
        return default;
      
      FPVector2 localCharacterPosition = frame.Get<Transform2D>(ViewContext.LocalView.EntityRef).Position;

      Vector2 mousePosition = _playerInput.actions["Point"].ReadValue<Vector2>();
      Ray ray = Camera.main.ScreenPointToRay(mousePosition);
      UnityEngine.Plane plane = new UnityEngine.Plane(Vector3.up, Vector3.zero);

      if (plane.Raycast(ray, out var enter))
      {
        var dirToMouse = ray.GetPoint(enter).ToFPVector2() - localCharacterPosition;
        return dirToMouse;
      }

      return default;
    }
  }
}
```

## UI Implementation

The `HUDView` handles displaying game information:

```csharp
// From TwinStickShooter/Scripts/UI/HUDView.cs
public class HUDView : MonoBehaviour
{
    [Header("Panels")]
    public GameObject gameplayPanel;
    public GameObject characterSelectionPanel;
    public GameObject gameOverPanel;
    
    [Header("Team Scores")]
    public TextMeshProUGUI team1ScoreText;
    public TextMeshProUGUI team2ScoreText;
    public Image team1ScoreFill;
    public Image team2ScoreFill;
    
    [Header("Character Selection")]
    public CharacterSelectionUI characterSelectionUI;
    
    [Header("Game Over")]
    public TextMeshProUGUI winnerTeamText;
    
    [Header("Match Timer")]
    public TextMeshProUGUI matchTimerText;
    
    [Header("Player UI")]
    public GameObject healthBar;
    public Image healthFill;
    
    private CharacterView _localCharacter;
    
    private void Awake()
    {
        // Hide all panels initially
        gameplayPanel.SetActive(false);
        characterSelectionPanel.SetActive(false);
        gameOverPanel.SetActive(false);
    }
    
    private void OnEnable()
    {
        // Subscribe to game events
        QuantumEvent.Subscribe<StartCharacterSelection>(this, OnCharacterSelectionStart);
        QuantumEvent.Subscribe<CharacterSelectionComplete>(this, OnCharacterSelectionComplete);
        QuantumEvent.Subscribe<CountdownStarted>(this, OnCountdownStarted);
        QuantumEvent.Subscribe<CountdownStopped>(this, OnCountdownStopped);
        QuantumEvent.Subscribe<GameOver>(this, OnGameOver);
    }
    
    private void OnDisable()
    {
        // Unsubscribe from game events
        QuantumEvent.Unsubscribe<StartCharacterSelection>(this, OnCharacterSelectionStart);
        QuantumEvent.Unsubscribe<CharacterSelectionComplete>(this, OnCharacterSelectionComplete);
        QuantumEvent.Unsubscribe<CountdownStarted>(this, OnCountdownStarted);
        QuantumEvent.Unsubscribe<CountdownStopped>(this, OnCountdownStopped);
        QuantumEvent.Unsubscribe<GameOver>(this, OnGameOver);
    }
    
    private void Update()
    {
        // Update match timer
        if (gameplayPanel.activeSelf && QuantumRunner.Default?.Game?.Frames?.Predicted != null)
        {
            Frame frame = QuantumRunner.Default.Game.Frames.Predicted;
            FP matchTimer = frame.Global->MatchTimer;
            FP matchDuration = frame.Global->MatchDuration;
            
            // Format time as MM:SS
            int totalSeconds = Mathf.FloorToInt(matchTimer.AsFloat);
            int minutes = totalSeconds / 60;
            int seconds = totalSeconds % 60;
            matchTimerText.text = $"{minutes:00}:{seconds:00}";
            
            // Update team scores
            UpdateTeamScores(frame);
            
            // Update player health
            UpdatePlayerHealth(frame);
        }
    }
    
    private void UpdateTeamScores(Frame frame)
    {
        byte team1Score = frame.Global->Teams[0].Score;
        byte team2Score = frame.Global->Teams[1].Score;
        
        team1ScoreText.text = team1Score.ToString();
        team2ScoreText.text = team2Score.ToString();
        
        // Update score progress bars (toward victory condition of 10 coins)
        team1ScoreFill.fillAmount = Mathf.Min(1f, team1Score / 10f);
        team2ScoreFill.fillAmount = Mathf.Min(1f, team2Score / 10f);
    }
    
    private void UpdatePlayerHealth(Frame frame)
    {
        if (_localCharacter == null || !frame.Exists(_localCharacter.EntityRef))
            return;
            
        if (frame.Has<Health>(_localCharacter.EntityRef))
        {
            var health = frame.Get<Health>(_localCharacter.EntityRef);
            FP maxHealth = AttributesHelper.GetCurrentValue(frame, _localCharacter.EntityRef, EAttributeType.Health);
            
            healthFill.fillAmount = (health.Current / maxHealth).AsFloat;
        }
    }
    
    public void OnLocalPlayerInstantiated(CharacterView characterView)
    {
        _localCharacter = characterView;
    }
    
    // Event handlers
    private void OnCharacterSelectionStart(StartCharacterSelection e)
    {
        characterSelectionPanel.SetActive(true);
        gameplayPanel.SetActive(false);
        gameOverPanel.SetActive(false);
    }
    
    private void OnCharacterSelectionComplete(CharacterSelectionComplete e)
    {
        characterSelectionPanel.SetActive(false);
    }
    
    private void OnCountdownStarted(CountdownStarted e)
    {
        // Show countdown UI...
    }
    
    private void OnCountdownStopped(CountdownStopped e)
    {
        gameplayPanel.SetActive(true);
    }
    
    private void OnGameOver(GameOver e)
    {
        gameplayPanel.SetActive(false);
        gameOverPanel.SetActive(true);
        
        winnerTeamText.text = $"Team {e.WinnerTeam + 1} Wins!";
        winnerTeamText.color = e.WinnerTeam == 0 ? Color.blue : Color.red;
    }
}
```

## Event Handling

The `QuantumCallbacks` implementation processes simulation events:

```csharp
// From TwinStickShooter/Scripts/GameView/GameEventsHandler.cs
public class GameEventsHandler : QuantumCallbacks
{
    public override void OnGameEvent(GameEventData eventData)
    {
        // Handle game events from the simulation
        EntityViewLinker entityViewLinker = FindObjectOfType<EntityViewLinker>();
        if (entityViewLinker == null)
            return;
            
        switch (eventData.EventName)
        {
            case "CharacterDefeated":
                {
                    // No specific handler needed, handled by CharacterView in OnEntityRender
                }
                break;
                
            case "CharacterRespawned":
                {
                    EntityRef characterRef = (EntityRef)eventData.Data;
                    CharacterView view = entityViewLinker.GetView<CharacterView>(characterRef);
                    
                    if (view != null)
                    {
                        view.OnRespawned();
                    }
                }
                break;
                
            case "CharacterDamaged":
                {
                    var data = (CharacterDamaged)eventData.Data;
                    CharacterView view = entityViewLinker.GetView<CharacterView>(data.target);
                    
                    if (view != null)
                    {
                        view.OnDamaged();
                    }
                }
                break;
                
            case "CharacterHealed":
                {
                    EntityRef characterRef = (EntityRef)eventData.Data;
                    CharacterView view = entityViewLinker.GetView<CharacterView>(characterRef);
                    
                    if (view != null)
                    {
                        view.OnHealed();
                    }
                }
                break;
                
            case "CharacterSkill":
                {
                    EntityRef characterRef = (EntityRef)eventData.Data;
                    CharacterView view = entityViewLinker.GetView<CharacterView>(characterRef);
                    
                    if (view != null)
                    {
                        view.OnAttack();
                    }
                }
                break;
                
            case "SkillAction":
                {
                    AssetRef skillDataRef = (AssetRef)eventData.Data;
                    PlaySkillEffect(skillDataRef);
                }
                break;
                
            case "CoinCollected":
                {
                    EntityRef characterRef = (EntityRef)eventData.Data;
                    PlaySound("coin_pickup");
                }
                break;
        }
    }
    
    private void PlaySkillEffect(AssetRef skillDataRef)
    {
        // Play visual and audio effects for skills
        if (QuantumRunner.Default?.Game?.AssetDatabase?.GetAsset(skillDataRef) is SkillData skillData)
        {
            // Play SFX
            if (skillData.SFX != null)
            {
                AudioManager.Instance.PlaySound(skillData.SFX.name);
            }
        }
    }
    
    private void PlaySound(string soundName)
    {
        AudioManager.Instance.PlaySound(soundName);
    }
}
```

## Camera Follow

The `CameraFollow` script handles following the player:

```csharp
// From TwinStickShooter/Scripts/GameView/CameraFollow.cs
public class CameraFollow : MonoBehaviour
{
    public Transform target;
    public float smoothTime = 0.3f;
    public Vector3 offset = new Vector3(0, 10, -5);
    
    private Vector3 velocity = Vector3.zero;
    
    public void SetTarget(Transform newTarget)
    {
        target = newTarget;
    }
    
    private void LateUpdate()
    {
        if (target == null)
            return;
            
        // Calculate target position
        Vector3 targetPosition = target.position + offset;
        
        // Smoothly move camera to target position
        transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, smoothTime);
        
        // Keep camera looking at target
        transform.LookAt(target);
    }
}
```

## Attack Preview

The `AttackPreview` script visualizes attack trajectories:

```csharp
// From TwinStickShooter/Scripts/GameView/AttackPreview.cs
public class AttackPreview : MonoBehaviour
{
    public SpriteRenderer basicAttackSprite;
    public SpriteRenderer specialAttackSprite;
    
    public void UpdateAttackPreview(FPVector2 direction, bool isSpecial)
    {
        // Hide both previews
        basicAttackSprite.gameObject.SetActive(false);
        specialAttackSprite.gameObject.SetActive(false);
        
        // Show appropriate preview
        if (isSpecial)
        {
            specialAttackSprite.gameObject.SetActive(true);
            UpdatePreviewTransform(specialAttackSprite.transform, direction);
        }
        else
        {
            basicAttackSprite.gameObject.SetActive(true);
            UpdatePreviewTransform(basicAttackSprite.transform, direction);
        }
    }
    
    private void UpdatePreviewTransform(Transform previewTransform, FPVector2 direction)
    {
        // Get character position from view context
        if (CustomViewContext.Instance.LocalView == null)
            return;
            
        // Position preview at character position
        Vector3 characterPosition = CustomViewContext.Instance.LocalView.transform.position;
        previewTransform.position = characterPosition;
        
        // Calculate direction angle
        float angle = Mathf.Atan2(direction.Y.AsFloat, direction.X.AsFloat) * Mathf.Rad2Deg;
        previewTransform.rotation = Quaternion.Euler(0, 0, angle);
    }
}
```

## GameplayRoomManager

The `GameplayRoomManager` handles the Photon Room connection:

```csharp
// From TwinStickShooter/Scripts/GameplayRoomManager.cs
public class GameplayRoomManager : MonoBehaviour, IConnectionCallbacks, IMatchmakingCallbacks
{
    public string gameVersion = "1.0";
    public byte maxPlayersPerRoom = 4;
    public GameObject connectingCanvas;
    public TextMeshProUGUI statusText;
    
    private void Awake()
    {
        // Configure Photon
        PhotonAppSettings.Instance.AppSettings.AppVersion = gameVersion;
        
        // Connect to Photon
        if (!PhotonNetwork.IsConnected)
        {
            connectingCanvas.SetActive(true);
            statusText.text = "Connecting to Photon...";
            PhotonNetwork.AddCallbackTarget(this);
            PhotonNetwork.ConnectUsingSettings();
        }
        else
        {
            connectingCanvas.SetActive(false);
        }
    }
    
    public void OnConnected()
    {
        statusText.text = "Connected to Photon!";
    }
    
    public void OnConnectedToMaster()
    {
        statusText.text = "Connected to Master. Joining Room...";
        
        // Join random room or create one
        PhotonNetwork.JoinRandomRoom();
    }
    
    public void OnJoinedRoom()
    {
        statusText.text = $"Joined Room: {PhotonNetwork.CurrentRoom.Name}";
        connectingCanvas.SetActive(false);
        
        // Start the game once min players joined
        StartGame();
    }
    
    public void OnJoinRandomFailed(short returnCode, string message)
    {
        statusText.text = "Creating new room...";
        
        // Create a new room
        RoomOptions roomOptions = new RoomOptions();
        roomOptions.MaxPlayers = maxPlayersPerRoom;
        PhotonNetwork.CreateRoom(null, roomOptions);
    }
    
    private void StartGame()
    {
        // Start Quantum game
        var config = RuntimeConfig.FromByteArray(Resources.Load<TextAsset>("RuntimeConfig").bytes);
        var runner = QuantumRunner.StartGame("", config, null, PhotonNetwork.LocalPlayer.ActorNumber - 1);
    }
    
    // Other IConnectionCallbacks and IMatchmakingCallbacks methods...
}
```

## Best Practices

1. **Clear Separation**: Keep a clear separation between simulation and visualization
2. **Event-Based Communication**: Use events for one-way communication from simulation to view
3. **Input Collection**: Gather input in Unity and pass to Quantum simulation
4. **Frame Rendering**: Update visuals based on simulation frame data
5. **Central View Context**: Use a central context to reference important view components
6. **Entity-GameObject Mapping**: Maintain clear mapping between simulation entities and Unity GameObjects
7. **Platform-Specific Code**: Use preprocessor directives for platform-specific input handling

## Implementation Notes

1. The simulation runs in Quantum using deterministic physics
2. Unity handles visualization, input collection, and UI
3. Events communicate state changes from simulation to view
4. Input flows from Unity to Quantum simulation
5. EntityView components update GameObject transforms based on simulation state
6. Custom components handle specific visualization needs
7. NetworkView components synchronize player input across the network
---

# README.md

# Quantum Twin Stick Shooter Documentation

This repository contains comprehensive documentation for the Quantum Twin Stick Shooter 3.0.2 sample project. The documentation is designed to help you understand how to implement multiplayer games using Photon Quantum's deterministic networking framework.

## Overview

Quantum Twin Stick Shooter is a sample game built with Photon Quantum 3.0.2 that demonstrates a multiplayer top-down twin stick shooter with team-based gameplay. It showcases key features of Quantum, including:

- Deterministic ECS (Entity Component System) architecture
- Predict/rollback networking
- Bot SDK integration with advanced AI systems
- Data-driven skills and attributes
- Team-based gameplay with Coin Grab game mode
- Unity integration for visualization

The documentation in this repository explains in detail how these systems are implemented, with code examples and best practices.

## Technical Information

- **Unity Version**: 2021.3.30f1
- **Quantum Version**: 3.0.2 (Build 620)
- **Platforms**: PC (Windows/Mac), and Mobile (Android)

## Documentation Structure

1. [**Project Overview**](00-project-overview.md) - High-level overview of the Quantum Twin Stick Shooter
2. [**Input System**](01-input-system.md) - How player and AI input is handled 
3. [**Movement System**](02-movement-system.md) - Character movement and KCC integration
4. [**AI System**](03-ai-system.md) - Bot SDK implementation with HFSM and context steering
5. [**Skills System**](04-skills-system.md) - Character abilities and combat mechanics
6. [**Attributes System**](05-attributes-system.md) - Character stats and modifiers
7. [**Game Management System**](06-game-management-system.md) - Game flow and match management
8. [**Inventory System**](07-inventory-system.md) - Item collection and management
9. [**Unity Integration**](08-unity-integration.md) - Visualization and input collection

Each document is structured to provide clear explanations and accurate code examples that can be used as reference when implementing similar systems.

## Key Features

### AI Implementation
- **Bot SDK**: Comprehensive use of Quantum's Bot SDK
- **HFSM**: Hierarchical Finite State Machine for AI decision making
- **AI Director**: Team-level coordination of AI characters
- **Data-Driven Sensors**: Configurable perception systems for AI
- **Context Steering**: Multiple weighted vectors for movement decisions
- **AI Memory**: Time-based information storage and recall
- **Bot Replacement**: Automatic replacement of disconnected players with bots

### Game Systems
- **Skill System**: Data-driven abilities with customizable behavior
- **Attributes System**: Flexible stat management with modifiers
- **Team-Based Gameplay**: Coin collection with scoring system
- **Game Flow Management**: HFSM-based game state control
- **Unified Input**: Same input structure used for both players and bots
- **KCC Integration**: Top-down character controller

## Game Highlights

- **Coin Grab Game Mode**: Collect coins scattered around the map. The team that keeps 10+ coins for 15 seconds wins.
- **Three Unique Characters**: Each with two unique abilities
- **Team-Based Gameplay**: Coordinate with teammates to collect and protect coins
- **Tactical AI Behaviors**: Bots make intelligent decisions based on game state
- **Cross-Platform Support**: Works on PC and mobile devices

## How to Use This Documentation

- **For learning Quantum**: Start with the Project Overview, then read through the documents in order to understand the fundamental concepts of Quantum.
- **For implementing specific features**: Go directly to the relevant system document.
- **For reference**: Use the code examples as templates for your own implementation.

The code examples are extracted directly from the Quantum Twin Stick Shooter sample project and represent actual working implementations of the various systems.

## LLM Optimization Note

These notes have been specifically crafted for optimal use by Large Language Models. The documentation:

- Uses precise code examples with accurate syntax
- Provides contextual explanations of code functionality
- Follows consistent formatting and structure
- Includes best practices and implementation patterns
- Provides clear descriptions of interfaces between systems

This makes the documentation ideal for generating accurate code when queried about Quantum implementation patterns.

## Additional Resources

For more information about Photon Quantum:

- [Quantum Documentation](https://doc.photonengine.com/quantum/current/getting-started/quantum-intro)
- [Photon Quantum Discord](https://discord.gg/photonengine)
- [Quantum Forum](https://forum.photonengine.com/categories/quantum-showcase-discussion)
- [Download Quantum Samples](https://dashboard.photonengine.com/download/quantum)
---

# README.md

# photon-quantum-llm-notes
 

---

